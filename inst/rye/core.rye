;;; Rye Standard Library - Core Functions

(module core
  (export = error warn assert assert-equal assert-true assert-false assert-eq assert-error suppressWarnings
            identity values values? call-with-values call/cc call-with-current-continuation doc! doc
            funcall r/call)

  ;; Documentation helpers
  (defmacro doc! (sym docstring)
    "Attach docstring to function. Usage: (doc! function-name \"docstring\")"
    `(set! ,sym (rye_set_doc ,sym ,docstring)))

  (define doc
    (lambda (fn)
      "Retrieve docstring from function's rye_doc attribute."
      (rye_get_doc fn)))

  (define funcall
    (lambda (fn args)
      "Apply a function with a provided list of arguments."
      (do.call fn args :quote #t)))

  (define r/call
    (lambda (fn (args (list)) (envir (globalenv)))
      "Call an R function with optional environment. Searches from .GlobalEnv by default, finding base and loaded package functions."
      (define fn-name
        (if (is.symbol fn)
          (as.character fn)
          (if (is.character fn)
            fn
            (error "r/call requires a symbol or string function name"))))
      (define fn-obj (get fn-name :envir envir :inherits #t))
      (funcall fn-obj (as.list args))))  ; as.list handles environments

  (define =
    (lambda (x y)
      "Equality helper using R ==."
      (== x y)))

  (define error
    (lambda (msg)
      "Signal an error with message."
      (stop msg :call. #f)))

  (define warn
    (lambda (msg)
      "Emit warning with message."
      (warning msg :call. #f)))

  (define assert
    (lambda (cond (msg "Assertion failed"))
      "Assert condition or raise error."
      (if cond
        #t
        (error msg))))

  (define assert-equal (lambda (expected actual)
    (if (! (equal? expected actual :num.type.eq #t))
      (begin
        (define error-msg (string-append "Expected: " (->string expected) ", Got: " (->string actual)))
        (error error-msg))
      #t)))

  (define assert-true (lambda (value)
    (if (! value)
      (begin
        (define error-msg (string-append "Expected truthy value, got: " (->string value)))
        (error error-msg))
      #t)))

  (define assert-false (lambda (value)
    (if value
      (begin
        (define error-msg (string-append "Expected falsy value, got: " (->string value)))
        (error error-msg))
      #t)))

  (define assert-eq (lambda (expected actual)
    (if (! (identical? expected actual))
      (begin
        (define error-msg (string-append "Expected (identical?): " (->string expected) ", Got: " (->string actual)))
        (error error-msg))
      #t)))

  (define assert-error (lambda (thunk)
    (define result
      (r/call "tryCatch"
        (dict
          :expr (thunk)
          :error (lambda (e) #t))))
    (if (! (== result #t))
      (error "Expected an error to be thrown, but none was")
      #t)))

  ; we need to avoid evaluating the expr before passing it to suppressWarnings,
  ; because otherwise the warning will already have been generated when we try
  ; to suppress it. evaluation here is eager by default, so we need to use
  ; quote, which requires a macro to enable calling it in the usual way
  (defmacro suppressWarnings (expr)
    (begin
      (define sw (get "suppressWarnings" :envir (baseenv)))
      `(r/eval (call (list ,sw ',expr)) (current-env))))

  (define identity
    (lambda (x)
      "Return argument."
      x))

  (define values
    (lambda (. args)
      "Return multiple values to a call-with-values consumer."
      (r/call "structure" (list args :class "rye_values"))))

  (define values?
    (lambda (x)
      "Return #t if x is a multiple-values container."
      (if (is.list x)
        (isTRUE (inherits x "rye_values"))
        #f)))

  (define call-with-values
    (lambda (producer consumer)
      "Call producer and pass its values to consumer."
      (if (not (is.function producer))
        (stop "call-with-values expects a function as the producer"))
      (if (not (is.function consumer))
        (stop "call-with-values expects a function as the consumer"))
      (define produced (producer))
      (define args
        (if (values? produced)
          (r/call "unclass" (list produced))
          (list produced)))
      (funcall consumer args)))

  (define call/cc callCC)
  (define call-with-current-continuation callCC)

)
