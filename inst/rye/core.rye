;;; Rye Standard Library - Core Functions

(module core
  (export = error warn assert assert-equal assert-true assert-false assert-eq assert-error
            identity values values? call-with-values call/cc call-with-current-continuation doc! doc
            funcall r/call license
            suppressWarnings suppressMessages with within subset transform substitute)

  ;; Documentation helpers
  (defmacro doc! (sym docstring)
    "Attach docstring to function. Usage: (doc! function-name \"docstring\")"
    `(set! ,sym (rye_set_doc ,sym ,docstring)))

  (define doc
    (lambda (fn)
      "Retrieve docstring from function's rye_doc attribute."
      (rye_get_doc fn)))

  (define funcall
    (lambda (fn args)
      "Apply a function with a provided list of arguments."
      (do.call fn args :quote #t)))

  (define r/call
    (lambda (fn (args (list)) (envir (globalenv)))
      "Call an R function with optional environment. Searches from .GlobalEnv by default, finding base and loaded package functions."
      (define fn-name
        (if (is.symbol fn)
          (as.character fn)
          (if (is.character fn)
            fn
            (error "r/call requires a symbol or string function name"))))
      (define fn-obj (get fn-name :envir envir :inherits #t))
      (funcall fn-obj (as.list args))))  ; as.list handles environments

  (define =
    (lambda (x y)
      "Equality helper using R ==."
      (== x y)))

  (define error
    (lambda (msg)
      "Signal an error with message."
      (stop msg :call. #f)))

  (define warn
    (lambda (msg)
      "Emit warning with message."
      (warning msg :call. #f)))

  (define assert
    (lambda (cond (msg "Assertion failed"))
      "Assert condition or raise error."
      (if cond
        #t
        (error msg))))

  (define assert-equal (lambda (expected actual)
    (if (! (equal? expected actual :num.type.eq #t))
      (begin
        (define error-msg (string-append "Expected: " (->string expected) ", Got: " (->string actual)))
        (error error-msg))
      #t)))

  (define assert-true (lambda (value)
    (if (! value)
      (begin
        (define error-msg (string-append "Expected truthy value, got: " (->string value)))
        (error error-msg))
      #t)))

  (define assert-false (lambda (value)
    (if value
      (begin
        (define error-msg (string-append "Expected falsy value, got: " (->string value)))
        (error error-msg))
      #t)))

  (define assert-eq (lambda (expected actual)
    (if (! (identical? expected actual))
      (begin
        (define error-msg (string-append "Expected (identical?): " (->string expected) ", Got: " (->string actual)))
        (error error-msg))
      #t)))

  (define assert-error (lambda (thunk)
    (define result
      (r/call "tryCatch"
        (dict
          :expr (thunk)
          :error (lambda (e) #t))))
    (if (! (== result #t))
      (error "Expected an error to be thrown, but none was")
      #t)))

  (define identity
    (lambda (x)
      "Return argument."
      x))

  (define values
    (lambda (. args)
      "Return multiple values to a call-with-values consumer."
      (r/call "structure" (list args :class "rye_values"))))

  (define values?
    (lambda (x)
      "Return #t if x is a multiple-values container."
      (if (is.list x)
        (isTRUE (inherits x "rye_values"))
        #f)))

  (define call-with-values
    (lambda (producer consumer)
      "Call producer and pass its values to consumer."
      (if (not (is.function producer))
        (stop "call-with-values expects a function as the producer"))
      (if (not (is.function consumer))
        (stop "call-with-values expects a function as the consumer"))
      (define produced (producer))
      (define args
        (if (values? produced)
          (r/call "unclass" (list produced))
          (list produced)))
      (funcall consumer args)))

  (define call/cc callCC)
  (define call-with-current-continuation callCC)

  (define license
    (lambda ()
      "Display Rye and R license information."
      (begin
        (r/call "cat" (list "Rye is licensed under the MIT License:\n\n"))
        (define license-file (r/call "system.file" (list "LICENSE.md" :package "rye")))
        (define license-lines (r/call "readLines" (list license-file)))
        (r/call "cat" (list license-lines :sep "\n"))
        (r/call "cat" (list "\n\nRye is built on R. R's license:\n\n"))
        (r/call "license" (list)))))

  ;; ============================================================================
  ;; Nonstandard Evaluation (NSE) Wrappers
  ;; ============================================================================
  ;;
  ;; These macros wrap base R functions that use nonstandard evaluation.
  ;; NSE functions need unevaluated expressions, but Rye uses eager evaluation
  ;; by default. These macros quote arguments appropriately before passing them
  ;; to the underlying R functions, allowing them to be called in the usual way.

  (defmacro suppressWarnings (expr)
    "Suppress warnings generated by evaluating expr."
    (begin
      (define sw (get "suppressWarnings" :envir (baseenv)))
      `(r/eval (call (list ,sw ',expr)) (current-env))))

  (defmacro suppressMessages (expr)
    "Suppress messages generated by evaluating expr."
    (begin
      (define sm (get "suppressMessages" :envir (baseenv)))
      `(r/eval (call (list ,sm ',expr)) (current-env))))

  (defmacro with (data expr)
    "Evaluate expr in the context of data (a data frame or list)."
    (begin
      (define w (get "with" :envir (baseenv)))
      `(r/eval (call (list ,w ,data ',expr)) (current-env))))

  (defmacro within (data expr)
    "Evaluate expr within data, returning modified data."
    (begin
      (define w (get "within" :envir (baseenv)))
      `(r/eval (call (list ,w ,data ',expr)) (current-env))))

  (defmacro subset (x condition . rest)
    "Subset x using condition. Optional rest args for select, drop, etc."
    (begin
      (define s (get "subset" :envir (baseenv)))
      `(r/eval (call (list ,s ,x ',condition ,@rest)) (current-env))))

  (define transform
    (lambda (. args)
      "transform is difficult to implement and is not yet supported - use within() or dplyr::mutate() instead."
      (error (string-append
        "transform() is difficult to implement and is not yet supported due to its use of R's named argument syntax.\n"
        "Alternatives:\n"
        "  - Use (within df ...) for simple transformations\n"
        "  - Use dplyr::mutate() for more complex cases\n"
        "  - Call R's transform directly from R code if needed"))))

  (define substitute
    (lambda (. args)
      "Perform substitution in an expression, or error if called with 1 arg."
      (define nargs (length args))
      (if (= nargs 1)
        (error (string-append
          "substitute(x) doesn't work in Rye functions due to eager evaluation.\n"
          "Rye evaluates arguments before calling functions, so there's no unevaluated expression to capture.\n"
          "For NSE in Rye:\n"
          "  - Use macros: (defmacro my-fn (x) `(quote ,x))\n"
          "  - Or require explicit quoting: (my-fn 'expr)\n"
          "  - Or use delay: (my-fn (delay expr)) with (promise-expr ...)"))
        (if (= nargs 2)
          (begin
            (define sub (get "substitute" :envir (baseenv)))
            (define expr (car args))
            (define env (car (cdr args)))
            (r/eval (call (list sub expr env)) (current-env)))
          (error "substitute requires 1 or 2 arguments")))))

)
