;;; Rye Standard Library - Dictionary (Hash Table)

(module dict
  (export dict hash dict? dict-get dict-set dict-remove dict-keys dict-values
          dict-has? dict-merge)

  (import types)
  (import list)
  (import looping)

;;' @section Dictionary (Hash Table)
;;' Dictionaries are mutable key-value stores backed by R environments.
;;' Keys must be strings, symbols, or keywords; values can be anything.

;;; Internal helpers (defined early for use in constructors)

;;' @description Create a new empty dictionary environment.
(define dict-new
  (lambda ()
    (define dict-obj (r/call "new.env" (list :hash #t :parent (r/call "emptyenv" (list)))))
    (r/call "class<-" (list dict-obj (c (list "rye_dict") (r/call "class" (list dict-obj)))))
    (r/call "assign" (list ".rye_keys" (r/call "character" (list 0)) :envir dict-obj))
    dict-obj))

;;' @description Convert key to string name for dict storage.
(define dict-key-to-name
  (lambda (key)
    (if (r/call "is.character" (list key))
      key
      (if (or (r/call "inherits" (list key "rye_keyword")) (r/call "is.symbol" (list key)))
        (r/call "as.character" (list key))
        #nil))))

;;; Dictionary constructor

;;' @description Create a hash-backed dictionary from key/value pairs.
;;' @examples
;;' (dict :x 1 :y 2)           ; => dict with keys "x" and "y"
;;' (dict)                      ; => empty dict
;;' (define d (dict :name "Alice" :age 30))
;;' (dict-get d "name")         ; => "Alice"
;;' @seealso hash
(define dict
  (lambda (. args)
    (define dict-obj (dict-new))
    (if (= (length args) 0)
      dict-obj
      (begin
        (define arg-names (r/call "names" (list args)))
        (if (or (is.null arg-names) (r/call "any" (list (r/call "!" (list (r/call "nzchar" (list arg-names)))))))
          (error "dict requires named arguments")
          (begin
            (define keys (r/call "as.character" (list arg-names)))
            (define assign-pair
              (lambda (i)
                (begin
                  (define key (r/call "[[" (list keys i)))
                  (define value (r/call "[[" (list args i)))
                  (r/call "assign" (list key value :envir dict-obj)))))
            (r/call "lapply" (list (r/call "seq_len" (list (length keys))) assign-pair))
            (r/call "assign" (list ".rye_keys" keys :envir dict-obj))
            dict-obj))))))

;;' @signature (hash . args)
;;' @note Alias for `dict`.
;;' @seealso dict
(define hash dict)

;;; Type predicate

;;' @description Return #t if x is a dictionary.
;;' @examples
;;' (dict? (dict :x 1))        ; => #t
;;' (dict? (list 1 2))         ; => #f
;;' (dict? 42)                 ; => #f
(define dict?
  (lambda (x)
    (and (r/call "is.environment" (list x)) (r/call "inherits" (list x "rye_dict")))))

;;; Internal helper (defined early for forward references)

;;' @description Return ordered keys vector (internal helper).
(define dict-keys-ordered
  (lambda (dict)
    (if (not (dict? dict))
      (r/call "character" (list 0))
      (begin
        (define keys (r/call "get0" (list ".rye_keys" :envir dict :inherits #f)))
        (if (is.null keys)
          (r/call "sort" (list (r/call "ls" (list :envir dict :all.names #f))))
          keys)))))

;;; Dictionary operations

;;' @description Get value for key or default if missing.
;;' @examples
;;' (define d (dict :x 1 :y 2))
;;' (dict-get d "x")           ; => 1
;;' (dict-get d "z")           ; => #nil
;;' (dict-get d "z" 99)        ; => 99  (default value)
;;' @seealso dict-set, dict-has?
(define dict-get
  (lambda (dict key . rest)
    (define default (if (= (length rest) 0) #nil (car rest)))
    (define name (dict-key-to-name key))
    (if (or (is.null name) (not (dict? dict)))
      default
      (if (r/call "exists" (list name :envir dict :inherits #f))
        (r/call "get" (list name :envir dict :inherits #f))
        default))))

;;' @description Set key to value in dict and return dict.
;;' @examples
;;' (define d (dict))
;;' (dict-set d "x" 42)        ; => d (mutated, x=42)
;;' (dict-get d "x")           ; => 42
;;' @seealso dict-get, dict-remove
(define dict-set
  (lambda (dict key value)
    (define name (dict-key-to-name key))
    (if (is.null name)
      (error "dict-set requires a string, symbol, or keyword key")
      (if (not (dict? dict))
        (error "dict-set requires a dict")
        (begin
          (define keys (dict-keys-ordered dict))
          (if (not (r/call "%in%" (list name keys)))
            (r/call "assign" (list ".rye_keys" (c keys (list name)) :envir dict)))
          (r/call "assign" (list name value :envir dict))
          dict)))))

;;' @description Remove key from dict and return dict.
;;' @examples
;;' (define d (dict :x 1 :y 2))
;;' (dict-remove d "x")        ; => d (mutated, x removed)
;;' (dict-has? d "x")          ; => #f
;;' @seealso dict-set
(define dict-remove
  (lambda (dict key)
    (define name (dict-key-to-name key))
    (if (or (is.null name) (not (dict? dict)))
      dict
      (if (r/call "exists" (list name :envir dict :inherits #f))
        (begin
          (r/call "rm" (list :list (c name) :envir dict :inherits #f))
          (define keys (dict-keys-ordered dict))
          (if (> (length keys) 0)
            (r/call "assign" (list ".rye_keys" (r/call "as.character" (list (filter (lambda (k) (not (= k name))) (as.list keys)))) :envir dict)))
          dict)
        dict))))

;;' @description Return a list of dict keys.
;;' @examples
;;' (define d (dict :x 1 :y 2))
;;' (dict-keys d)              ; => ("x" "y")
;;' (dict-keys (dict))         ; => ()
;;' @seealso dict-values
(define dict-keys
  (lambda (dict)
    (if (not (dict? dict))
      (list)
      (begin
        (define keys (dict-keys-ordered dict))
        (__as-list keys)))))

;;' @description Return a list of dict values.
;;' @examples
;;' (define d (dict :x 1 :y 2))
;;' (dict-values d)            ; => (1 2)
;;' @seealso dict-keys
(define dict-values
  (lambda (dict)
    (if (not (dict? dict))
      (list)
      (begin
        (define keys (dict-keys-ordered dict))
        (if (= (length keys) 0)
          (list)
          (begin
            (define values (r/call "mget" (list keys :envir dict :inherits #f)))
            (__as-list (r/call "unname" (list values)))))))))

;;' @description Return #t if dict contains key.
;;' @examples
;;' (define d (dict :x 1 :y 2))
;;' (dict-has? d "x")          ; => #t
;;' (dict-has? d "z")          ; => #f
;;' @seealso dict-get
(define dict-has?
  (lambda (dict key)
    (define name (dict-key-to-name key))
    (if (or (is.null name) (not (dict? dict)))
      #f
      (r/call "exists" (list name :envir dict :inherits #f)))))

;;' @description Merge dicts, later values override earlier.
;;' @examples
;;' (define a (dict :x 1 :y 2))
;;' (define b (dict :y 99 :z 3))
;;' (define m (dict-merge a b))
;;' (dict-get m "y")           ; => 99  (b overrides a)
;;' (dict-get m "z")           ; => 3
;;' @seealso dict, dict-set
(define dict-merge
  (lambda (. dicts)
    (define result (dict-new))
    (define result-keys (list))
    (define merge-dict
      (lambda (d)
        (if (dict? d)
          (begin
            (define keys (dict-keys-ordered d))
            (define merge-key
              (lambda (name)
                (begin
                  (define value (r/call "get" (list name :envir d :inherits #f)))
                  (r/call "assign" (list name value :envir result))
                  (if (not (r/call "%in%" (list name (r/call "as.character" (list result-keys)))))
                    (set! result-keys (c result-keys (list name)))))))
            (if (> (length keys) 0)
              (r/call "lapply" (list (as.list keys) merge-key)))))))
    (define remaining dicts)
    (while (> (length remaining) 0)
      (begin
        (merge-dict (car remaining))
        (set! remaining (cdr remaining))))
    (r/call "assign" (list ".rye_keys" (r/call "as.character" (list result-keys)) :envir result))
    result))
)
