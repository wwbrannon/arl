;;; Rye Standard Library - Predicates

(module predicates
  (export list? pair? null? nil?
          symbol? keyword? number? string? vector?
          true? false? boolean? fn? callable? not xor
          empty?
          length= length> length<
          eq? eqv? equal?
          atom? procedure? rational? real? complex?
          symbol->string string->symbol
          ->symbol ->number ->list ->vector
          type-of)

  (import list)
  (import core)  ; for doc!

  ;; DESIGN NOTE: Simple one-argument pass-through functions use direct assignment
  ;; to avoid unnecessary stack frames. Docstrings attached using doc!.

  (define list?
    (lambda (x)
      "Return #t if x is a list or call."
      (if (is.list x) #t (if (is.call x) #t #f))))

  (define pair?
    (lambda (x)
      "Return #t if x is a non-empty list."
      (if (list? x) (if (> (length x) 0) #t #f) #f)))

  (define null?
    (lambda (x)
      "Return #t for empty list or #nil."
      (if (is.null x)
        #t
        (if (is.list x)
          (if (= (length x) 0) #t #f)
          (if (is.call x)
            (if (= (length x) 0) #t #f)
            #f)))))

  (define nil?
    (lambda (x)
      "Alias for null?."
      (null? x)))

  (define symbol? is.symbol)
  (doc! symbol? "Return #t if x is a symbol.")

  (define keyword?
    (lambda (x)
      "Return #t if x is a Rye keyword."
      (isTRUE (inherits x "rye_keyword"))))

  (define number? is.numeric)
  (doc! number? "Return #t if x is numeric.")

  (define string? is.character)
  (doc! string? "Return #t if x is character.")

  (define vector?
    (lambda (x)
      "Return #t if x is a non-list atomic vector."
      (if (is.atomic x)
        (if (is.character x) #f (if (is.list x) #f #t))
        #f)))

  (define true?
    (lambda (x)
      "Return #t if x is TRUE."
      (isTRUE x)))

  (define false?
    (lambda (x)
      "Return #t if x is #f."
      (identical x #f)))

  (define boolean?
    (lambda (x)
      "Return #t if x is a single logical value."
      (if (is.logical x)
        (isTRUE (== (length x) 1))
        #f)))

  (define fn? is.function)
  (doc! fn? "Return #t if x is a function.")

  (define callable? fn?)
  (doc! callable? "Alias for fn?.")

  (define not
    (lambda (x)
      "Logical negation with Rye truthiness."
      (if x #f #t)))

  (define xor
    (lambda (a b)
      "Logical exclusive OR with Rye truthiness."
      (if a
        (if b #f #t)
        (if b #t #f))))


  (define empty?
    (lambda (x)
      "Return #t if x is an empty list, call, string, or vector."
      (if (null? x)
        #t
        (if (is.list x)
          (isTRUE (== (length x) 0))
          (if (is.call x)
            (isTRUE (== (length x) 0))
            (if (is.character x)
              (isTRUE (== (length x) 0))
              (if (is.atomic x)
                (isTRUE (== (length x) 0))
                #f)))))))

  (define length=
    (lambda (x n)
      "Return #t if length of x equals n."
      (isTRUE (== (length x) n))))

  (define length>
    (lambda (x n)
      "Return #t if length of x is greater than n."
      (isTRUE (> (length x) n))))

  (define length<
    (lambda (x n)
      "Return #t if length of x is less than n."
      (isTRUE (< (length x) n))))

  ;; ============================================================================
  ;; Phase 4: Enhanced Equality & Type Predicates
  ;; ============================================================================

  ;; Equality predicates
  ;;
  ;; NOTE: True Scheme eq? and eqv? semantics cannot be properly implemented in R
  ;; because R does not provide reliable pointer equality for all object types.
  ;; R's identical() does structural comparison for some types (lists, vectors)
  ;; but pointer comparison for others (environments, reference classes).

  (define eq?
    (lambda (a b)
      "eq? cannot be properly implemented in R. Use identical? for R's native equality, or equal? for deep structural equality."
      (error "eq? cannot be properly implemented in R. Use identical? for R's native equality, or equal? for deep structural equality.")))

  (define eqv?
    (lambda (a b)
      "eqv? cannot be properly implemented in R. Use identical? for R's native equality, or equal? for deep structural equality."
      (error "eqv? cannot be properly implemented in R. Use identical? for R's native equality, or equal? for deep structural equality.")))

  ;; identical? is implemented natively in R (see R/rye-engine.R)
  ;; We don't redefine it, it's already in the environment

  ;; Helper predicates for equal?
  (define environment?
    (lambda (x)
      "Test if x is an environment (including R6 objects)."
      (r/call "is.environment" (list x))))

  (define is-refclass?
    (lambda (x)
      "Test if x is a Reference Class object."
      (and (r/call "isS4" (list x))
           (r/call "is" (list x "refClass")))))

  ;; Helper: compare environment contents
  (define env-equal?
    (lambda (env1 env2)
      "Compare two environments by their bindings and values."
      (define names1 (sort (r/call "ls" (list env1 :all.names #t)) string<?))
      (define names2 (sort (r/call "ls" (list env2 :all.names #t)) string<?))
      (if (equal? names1 names2)
        ;; Same names - recursively compare values
        (begin
          (define check-values
            (lambda (names)
              (if (null? names)
                #t
                (if (equal? (r/call "get" (list (car names) :envir env1))
                            (r/call "get" (list (car names) :envir env2)))
                  (check-values (cdr names))
                  #f))))
          (check-values names1))
        #f)))

  ;; Helper: recursively compare lists
  (define list-equal?
    (lambda (lst1 lst2)
      "Recursively compare list elements."
      (if (== (length lst1) (length lst2))
        (begin
          (define compare-elements
            (lambda (l1 l2)
              (if (null? l1)
                #t
                (if (equal? (car l1) (car l2))
                  (compare-elements (cdr l1) (cdr l2))
                  #f))))
          (compare-elements lst1 lst2))
        #f)))

  ;; equal? - proper deep structural equality
  ;; Handles reference-semantic types (environments, RC) by comparing contents
  ;; Handles containers (lists, including data.frames and list-arrays) recursively
  (define equal?
    (lambda (a b . kwargs)
      "Deep structural equality - recursively compare structure and contents.
       Optional keyword argument :num.type.eq #t enables numeric type coercion (e.g., 4 == 4L)."
      ;; Call identical? once with kwargs and reuse the result to avoid overhead
      (define id-result (apply identical? (list* a b kwargs)))
      (if id-result
        #t
        (cond
          ;; Environments (incl. R6 objects + refclasses) - compare contents
          ;; R6 objects are currently implemented as environments, so they're
          ;; caught here. If R6 switches to a compiled implementation in the
          ;; future, we may need to add special handling. Similarly with R's
          ;; built-in reference class system: these are environments.
          ((and (environment? a) (environment? b)) (env-equal? a b))

          ;; Lists (including data.frames, list-arrays) - recursive comparison
          ;; This handles lists containing reference-semantic objects correctly
          ((and (list? a) (list? b)) (list-equal? a b))

          ;; Everything else: atomic vectors, arrays, S3, S4, external pointers
          ;; For external pointers, identical() does pointer comparison, which is
          ;; the best we can do (we can't inspect arbitrary C struct contents).
          ;; For value-semantic types, identical() does structural comparison.
          (else id-result)))))

  ;; Additional type predicates
  (define atom?
    (lambda (x)
      "Return #t if x is not a pair (i.e., not a non-empty list)."
      (not (pair? x))))

  (define procedure?
    (lambda (x)
      "Alias for fn? - return #t if x is a function."
      (fn? x)))

  (define rational?
    (lambda (x)
      "Return #t if x is a rational number (all R numerics are rational or special)."
      ;; In R, all finite numerics can be considered rational
      (if (number? x)
        (if (is.finite x) #t #f)
        #f)))

  (define real?
    (lambda (x)
      "Return #t if x is a real number."
      ;; R's is.numeric includes integers and doubles
      (if (is.numeric x)
        (if (is.complex x) #f #t)
        #f)))

  (define complex?
    (lambda (x)
      "Return #t if x is a complex number."
      (is.complex x)))

  ;; Symbol conversions
  (define symbol->string
    (lambda (sym)
      "Convert symbol to string."
      (if (symbol? sym)
        (as.character sym)
        (stop "symbol->string: argument must be a symbol"))))

  (define string->symbol
    (lambda (str)
      "Convert string to symbol."
      (if (string? str)
        (as.symbol str)
        (stop "string->symbol: argument must be a string"))))

  ;; General type conversions
  (define ->symbol
    (lambda (x)
      "Convert value to symbol."
      (if (symbol? x)
        x
        (as.symbol (as.character x)))))

  (define ->number
    (lambda (x)
      "Convert value to number."
      (if (number? x)
        x
        (if (string? x)
          (begin
            (define result (suppressWarnings (as.numeric x)))
            (if (is.na result)
              (stop (sprintf "Cannot convert '%s' to number" x))
              result))
          (stop "->number: cannot convert to number")))))

  (define ->list
    (lambda (x)
      "Convert value to list."
      (if (list? x)
        x
        (as.list x))))

  (define ->vector
    (lambda (x)
      "Convert value to vector."
      (if (vector? x)
        x
        (if (list? x)
          (unlist x)
          (if (is.atomic x)
            x
            (stop "->vector: cannot convert to vector"))))))

  ;; Type introspection
  (define type-of
    (lambda (x)
      "Return type name of value as string."
      (if (null? x)
        "null"
        (if (is.symbol x)
          "symbol"
          (if (is.character x)
            "character"
            (if (is.numeric x)
              (if (is.integer x)
                "integer"
                (if (is.double x)
                  "numeric"
                  (if (is.complex x)
                    "complex"
                    "numeric")))
              (if (is.logical x)
                "logical"
                (if (is.list x)
                  "list"
                  (if (is.call x)
                    "call"
                    (if (is.function x)
                      "closure"
                      (r/call "typeof" (list x))))))))))))
)
