;;; Rye Standard Library - Predicates

(module predicates
  (export list? pair? null? nil?
          symbol? keyword? number? string? vector?
          true? false? boolean? fn? callable? not xor
          empty?
          length= length> length<
          eq? eqv? equal?
          equal?.default equal?.environment equal?.list
          set-method!
          atom? procedure? rational? real? complex?
          symbol->string string->symbol
          ->symbol ->number ->list ->vector
          type-of)

  (import list)
  (import core)  ; for doc!
  (import _aliases)

  ;; DESIGN NOTE: Simple one-argument pass-through functions use direct assignment
  ;; to avoid unnecessary stack frames. Docstrings attached using doc!.

  (define list?
    (lambda (x)
      "Return #t if x is a list or call."
      (if (is.list x) #t (if (is.call x) #t #f))))

  (define pair?
    (lambda (x)
      "Return #t if x is a non-empty list."
      (if (list? x) (if (__r> (__rlength x) 0) #t #f) #f)))

  (define null?
    (lambda (x)
      "Return #t for empty list or #nil."
      (if (is.null x)
        #t
        (if (is.list x)
          (if (__r== (__rlength x) 0) #t #f)
          (if (is.call x)
            (if (__r== (__rlength x) 0) #t #f)
            #f)))))

  (define nil?
    (lambda (x)
      "Alias for null?."
      (null? x)))

  (define symbol? is.symbol)
  (doc! symbol? "Return #t if x is a symbol.")

  (define keyword?
    (lambda (x)
      "Return #t if x is a Rye keyword."
      (isTRUE (inherits x "rye_keyword"))))

  (define number? is.numeric)
  (doc! number? "Return #t if x is numeric.")

  (define string? is.character)
  (doc! string? "Return #t if x is character.")

  (define vector?
    (lambda (x)
      "Return #t if x is a non-list atomic vector."
      (if (is.atomic x)
        (if (is.character x) #f (if (is.list x) #f #t))
        #f)))

  (define true?
    (lambda (x)
      "Return #t if x is TRUE."
      (isTRUE x)))

  (define false?
    (lambda (x)
      "Return #t if x is #f."
      (identical x #f)))

  (define boolean?
    (lambda (x)
      "Return #t if x is a single logical value."
      (if (is.logical x)
        (isTRUE (== (length x) 1))
        #f)))

  (define fn? is.function)
  (doc! fn? "Return #t if x is a function.")

  (define callable? fn?)
  (doc! callable? "Alias for fn?.")

  (define not
    (lambda (x)
      "Logical negation with Rye truthiness."
      (if x #f #t)))

  (define xor
    (lambda (a b)
      "Logical exclusive OR with Rye truthiness."
      (if a
        (if b #f #t)
        (if b #t #f))))


  (define empty?
    (lambda (x)
      "Return #t if x is an empty list, call, string, or vector."
      (if (null? x)
        #t
        (if (is.list x)
          (isTRUE (== (length x) 0))
          (if (is.call x)
            (isTRUE (== (length x) 0))
            (if (is.character x)
              (isTRUE (== (length x) 0))
              (if (is.atomic x)
                (isTRUE (== (length x) 0))
                #f)))))))

  (define length=
    (lambda (x n)
      "Return #t if length of x equals n."
      (isTRUE (== (length x) n))))

  (define length>
    (lambda (x n)
      "Return #t if length of x is greater than n."
      (isTRUE (> (length x) n))))

  (define length<
    (lambda (x n)
      "Return #t if length of x is less than n."
      (isTRUE (< (length x) n))))

  ;; ============================================================================
  ;; Phase 4: Enhanced Equality & Type Predicates
  ;; ============================================================================

  ;; Equality predicates
  ;;
  ;; NOTE: True Scheme eq? and eqv? semantics cannot be properly implemented in R
  ;; because R does not provide reliable pointer equality for all object types.
  ;; R's identical() does structural comparison for some types (lists, vectors)
  ;; but pointer comparison for others (environments, reference classes).

  (define eq?
    (lambda (a b)
      "eq? cannot be properly implemented in R. Use identical? for R's native equality, or equal? for deep structural equality."
      (error "eq? cannot be properly implemented in R. Use identical? for R's native equality, or equal? for deep structural equality.")))

  (define eqv?
    (lambda (a b)
      "eqv? cannot be properly implemented in R. Use identical? for R's native equality, or equal? for deep structural equality."
      (error "eqv? cannot be properly implemented in R. Use identical? for R's native equality, or equal? for deep structural equality.")))

  ;; identical? is implemented natively in R (see R/rye-engine.R)
  ;; We don't redefine it, it's already in the environment

  ;; Helper predicates for equal?
  (define environment?
    (lambda (x)
      "Test if x is an environment (including R6 objects)."
      (r/call "is.environment" (list x))))

  (define is-refclass?
    (lambda (x)
      "Test if x is a Reference Class object."
      (and (r/call "isS4" (list x))
           (r/call "is" (list x "refClass")))))

  ;; Helper: compare environment contents
  (define env-equal?
    (lambda (env1 env2)
      "Compare two environments by their bindings and values."
      (define names1 (sort (r/call "ls" (list env1 :all.names #t)) string<?))
      (define names2 (sort (r/call "ls" (list env2 :all.names #t)) string<?))
      (if (equal? names1 names2)
        ;; Same names - recursively compare values
        (begin
          (define result #t)
          (define remaining names1)
          (while* (and (not (null? remaining)) result)
            (begin
              (when (not (equal? (r/call "get" (list (car remaining) :envir env1))
                                 (r/call "get" (list (car remaining) :envir env2))))
                (set! result #f))
              (set! remaining (cdr remaining))))
          result)
        #f)))

  ;; Helper: recursively compare lists
  (define list-equal?
    (lambda (lst1 lst2)
      "Recursively compare list elements."
      (if (== (length lst1) (length lst2))
        (begin
          (define result #t)
          (define remaining1 lst1)
          (define remaining2 lst2)
          (while* (and (not (null? remaining1)) result)
            (begin
              (when (not (equal? (car remaining1) (car remaining2)))
                (set! result #f))
              (set! remaining1 (cdr remaining1))
              (set! remaining2 (cdr remaining2))))
          result)
        #f)))

  ;; equal? - S3-style generic: dispatch on class of first argument.
  ;; Methods: equal?.default, equal?.environment, equal?.list (and user-defined).
  ;; Use (set-method! 'equal? 'my-class fn) to add methods for new types.
  (define equal?.default
    (lambda (a b (strict #f))
      "Default equality: atomic/vector comparison. :strict #t => #f; else use == with type coercion."
      (if strict
        #f
        (begin
          (define comp-result (== a b))
          (if (is.logical comp-result)
            (if (> (length comp-result) 1)
              (isTRUE (all comp-result))
              (isTRUE comp-result))
            #f)))))

  (define equal?.environment
    (lambda (a b (strict #f))
      "Compare environments by bindings and values (dict, set, R6, refclass are env-based)."
      (if (not (environment? b))
        #f
        (env-equal? a b))))

  (define equal?.list
    (lambda (a b (strict #f))
      "Compare lists recursively by structure and elements."
      (if (not (list? b))
        #f
        (list-equal? a b))))

  (define equal?
    (lambda (a b (strict #f))
      "Deep structural equality. Dispatches on class of first argument. Optional :strict #t uses identical? for atomics.
       Add methods with (set-method! 'equal? 'my-class (lambda (a b strict) ...))."
      (if (identical? a b)
        #t
        (begin
          (define env (stdlib-env))
          (define class-name (r/call "[[" (list (r/call "class" (list a)) 1)))
          (define method-name (string-append "equal?." class-name))
          (define method (r/call "get0" (list method-name :envir env :inherits #f)))
          (if (nil? method)
            (set! method (r/call "get" (list "equal?.default" :envir env))))
          (method a b strict)))))

  (define set-method!
    (lambda (generic-name class-name method-fun)
      "Register an S3-style method. Example: (set-method! 'equal? 'my-class (lambda (a b strict) ...))."
      (define env (stdlib-env))
      (define method-name (string-append (->string generic-name) "." (->string class-name)))
      (r/call "assign" (list method-name method-fun :envir env))))

  ;; Additional type predicates
  (define atom?
    (lambda (x)
      "Return #t if x is not a pair (i.e., not a non-empty list)."
      (not (pair? x))))

  (define procedure?
    (lambda (x)
      "Alias for fn? - return #t if x is a function."
      (fn? x)))

  (define rational?
    (lambda (x)
      "Return #t if x is a rational number (all R numerics are rational or special)."
      ;; In R, all finite numerics can be considered rational
      (if (number? x)
        (if (is.finite x) #t #f)
        #f)))

  (define real?
    (lambda (x)
      "Return #t if x is a real number."
      ;; R's is.numeric includes integers and doubles
      (if (is.numeric x)
        (if (is.complex x) #f #t)
        #f)))

  (define complex?
    (lambda (x)
      "Return #t if x is a complex number."
      (is.complex x)))

  ;; Symbol conversions
  (define symbol->string
    (lambda (sym)
      "Convert symbol to string."
      (if (symbol? sym)
        (as.character sym)
        (stop "symbol->string: argument must be a symbol"))))

  (define string->symbol
    (lambda (str)
      "Convert string to symbol."
      (if (string? str)
        (as.symbol str)
        (stop "string->symbol: argument must be a string"))))

  ;; General type conversions
  (define ->symbol
    (lambda (x)
      "Convert value to symbol."
      (if (symbol? x)
        x
        (as.symbol (as.character x)))))

  (define ->number
    (lambda (x)
      "Convert value to number."
      (if (number? x)
        x
        (if (string? x)
          (begin
            (define result (suppressWarnings (as.numeric x)))
            (if (is.na result)
              (stop (sprintf "Cannot convert '%s' to number" x))
              result))
          (stop "->number: cannot convert to number")))))

  (define ->list
    (lambda (x)
      "Convert value to list."
      (if (list? x)
        x
        (as.list x))))

  (define ->vector
    (lambda (x)
      "Convert value to vector."
      (if (vector? x)
        x
        (if (list? x)
          (unlist x)
          (if (is.atomic x)
            x
            (stop "->vector: cannot convert to vector"))))))

  ;; Type introspection
  (define type-of typeof)
  (doc! type-of "Return the type of value (alias for R's typeof).")
)
