;;; Rye Standard Library - Looping Macros

(module looping
  (export until for* loop recur)

  (import higher-order)
  (import list)
  (import predicates)
  (import sequences)

  ;;
  ;; for loops (defined in terms of while*, which is a built-in special form)
  ;;

  (defmacro for* (binding . body)
    "Loop over seq binding var each iteration. Expands to while*."
    (begin
      (define var (car binding))
      (define seq (car (cdr binding)))
      (define remaining (gensym "for_remaining"))
      `(begin
         (define ,remaining (__as-list ,seq))
         (while* (not (null? ,remaining))
           (define ,var (car ,remaining))
           ,@body
           (set! ,remaining (cdr ,remaining))))))

  ;;
  ;; loop/recur, clojure-style
  ;;

  (defmacro recur (. args)
    "Rebind loop locals and repeat. Only valid inside loop."
    (stop "recur can only be used inside loop"))

  ;; Helper: Check if a form should skip recur rewriting
  (define skip-rewrite-form?
    (lambda (head)
      (if (symbol? head)
        (begin
          (define name (as.character head))
          (or (= name "quote")
              (= name "quasiquote")
              (= name "lambda")
              (= name "defmacro")
              (= name "loop")))
        #f)))

  ;; Helper: Validate binding pairs
  (define valid-binding-pair?
    (lambda (pair)
      (if (pair? pair)
        (isTRUE (= (length pair) 2))
        #f)))

  (define valid-bindings?
    (lambda (bindings)
      (if (list? bindings)
        (every? valid-binding-pair? bindings)
        #f)))

  ;; Helper: Transform recur calls in an expression
  (define rewrite-recur
    (lambda (expr vars recur-flag recur-vals)
      (if (list? expr)
        (begin
          (define head (car expr))
          (cond
            ;; Handle recur call
            ((and (symbol? head) (= (as.character head) "recur"))
             (begin
               (define args (cdr expr))
               (if (not (= (length args) (length vars)))
                 (stop (sprintf "recur expects %d argument(s)" (length vars))))
               `(begin
                  (set! ,recur-flag #t)
                  (set! ,recur-vals (list ,@args))
                  (return #nil))))

            ;; Skip forms that create new scopes or shouldn't be transformed
            ((skip-rewrite-form? head) expr)

            ;; Recursively rewrite other list forms
            (else
             (call (cons head (map (lambda (e) (rewrite-recur e vars recur-flag recur-vals))
                                   (cdr expr)))))))
        expr)))

  ;; Helper: Generate variable rebinding code (set! so LHS is not evaluated)
  (define generate-rebindings
    (lambda (vars recur-vals)
      (define index-op (as.symbol "[["))
      (define rebinds
        (map (lambda (pair)
               (define var (car pair))
               (define idx (car (cdr pair)))
               (define nth-expr (call (list index-op recur-vals idx)))
               `(set! ,var ,nth-expr))
             (zip vars (seq_len (length vars)))))
      (if (null? rebinds)
        (quote (begin))
        (if (= (length rebinds) 1)
          (car rebinds)
          `(begin ,@rebinds)))))

  (defmacro loop (bindings . body)
    "Clojure-style loop/recur that expands to an R while loop."
    (begin
      ;; Validate bindings or fall back to runtime loop function
      (if (not (valid-bindings? bindings))
        `((lambda (loop-fn) (loop-fn ,bindings ,@body)) loop)
        (begin
          ;; Extract variables and generate gensyms
          (define vars (map car bindings))
          (define recur-flag (gensym "recur_flag"))
          (define recur-vals (gensym "recur_vals"))
          (define loop-result (gensym "loop_result"))
          (define loop-step (gensym "loop_step"))
          (define loop-done (gensym "loop_done"))

          ;; Rewrite body to transform recur calls
          (define rewritten-body
            (map (lambda (expr) (rewrite-recur expr vars recur-flag recur-vals))
                 body))

          ;; Generate the rebinding block
          (define rebind-block (generate-rebindings vars recur-vals))

          ;; Emit the loop structure (use done flag instead of break so we stay inside R's while)
          `(begin
             ;; Initialize loop variables
             ,@(map (lambda (pair) `(define ,(car pair) ,(car (cdr pair)))) bindings)
             (define ,recur-flag #f)
             (define ,recur-vals (list))
             (define ,loop-result #f)
             (define ,loop-done #f)
             (define ,loop-step (lambda () (begin ,@rewritten-body)))

             (while* (not ,loop-done)
               (set! ,recur-flag #f)
               (set! ,loop-result (,loop-step))
               (if ,recur-flag
                 (r/eval ,rebind-block (current-env))
                 (set! ,loop-done #t)))

             ,loop-result)))))

  ;;
  ;; misc loops
  ;;

  (defmacro until (test . body)
    "Repeat body until test is truthy."
    `(while* (not ,test) ,@body))
)
