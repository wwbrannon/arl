;;; Rye Standard Library - Looping Macros

(module looping
  (export until for loop recur)

  (import functional)
  (import list)
  (import types)
  (import sequences)

  ;;' @section Looping Macros

  ;;
  ;; for loops (defined in terms of while, which is a built-in special form)
  ;;

  ;;' @examples
  ;;' (define total 0)
  ;;' (for (x '(1 2 3))
  ;;'   (set! total (+ total x)))
  ;;' total                       ; => 6
  ;;'
  ;;' (define result (list))
  ;;' (for (ch '("a" "b" "c"))
  ;;'   (set! result (append result (list ch))))
  ;;' result                      ; => ("a" "b" "c")
  ;;' @note Expands to a `while` loop over the sequence converted to a list.
  ;;' @seealso while, map, loop
  (defmacro for (binding . body)
    "Loop over seq binding var each iteration. Expands to while."
    (begin
      (define var (car binding))
      (define seq (car (cdr binding)))
      (define remaining (gensym "for_remaining"))
      `(begin
         (define ,remaining (__as-list ,seq))
         (while (not (null? ,remaining))
           (define ,var (car ,remaining))
           ,@body
           (set! ,remaining (cdr ,remaining))))))

  ;;
  ;; loop/recur, clojure-style
  ;;

  ;;' @description Signal a recur back to the enclosing `loop`. Only valid inside a `loop` body.
  ;;' @seealso loop
  (defmacro recur (. args)
    "Rebind loop locals and repeat. Only valid inside loop."
    (stop "recur can only be used inside loop"))

  ;; Helper: Check if a form should skip recur rewriting
  (define skip-rewrite-form?
    (lambda (head)
      "Check if a form should skip recur rewriting (quote, lambda, defmacro, loop)."
      (if (symbol? head)
        (begin
          (define name (as.character head))
          (or (= name "quote")
              (= name "quasiquote")
              (= name "lambda")
              (= name "defmacro")
              (= name "loop")))
        #f)))

  ;; Helper: Validate binding pairs
  (define valid-binding-pair?
    (lambda (pair)
      "Validate that a binding pair is a list of length 2."
      (if (list-or-pair? pair)
        (isTRUE (= (length pair) 2))
        #f)))

  (define valid-bindings?
    (lambda (bindings)
      "Validate that bindings is a list of valid binding pairs."
      (if (list? bindings)
        (every? valid-binding-pair? bindings)
        #f)))

  ;; Helper: Transform recur calls in an expression
  (define rewrite-recur
    (lambda (expr vars recur-flag recur-vals)
      "Transform recur calls in an expression tree."
      (if (list? expr)
        (begin
          (define head (car expr))
          (cond
            ;; Handle recur call
            ((and (symbol? head) (= (as.character head) "recur"))
             (begin
               (define args (cdr expr))
               (if (not (= (length args) (length vars)))
                 (stop (sprintf "recur expects %d argument(s)" (length vars))))
               `(begin
                  (set! ,recur-flag #t)
                  (set! ,recur-vals (list ,@args))
                  (return #nil))))

            ;; Skip forms that create new scopes or shouldn't be transformed
            ((skip-rewrite-form? head) expr)

            ;; Recursively rewrite other list forms
            (else
             (call (cons head (map (lambda (e) (rewrite-recur e vars recur-flag recur-vals))
                                   (cdr expr)))))))
        expr)))

  ;; Helper: Generate variable rebinding code (set! so LHS is not evaluated)
  (define generate-rebindings
    (lambda (vars recur-vals)
      "Generate code to rebind loop variables from recur-vals list."
      (define index-op (as.symbol "[["))
      (define rebinds
        (map (lambda (pair)
               (define var (car pair))
               (define idx (car (cdr pair)))
               (define nth-expr (call (list index-op recur-vals idx)))
               `(set! ,var ,nth-expr))
             (zip vars (seq_len (length vars)))))
      (if (null? rebinds)
        (quote (begin))
        (if (= (length rebinds) 1)
          (car rebinds)
          `(begin ,@rebinds)))))

  ;;' @examples
  ;;' ;; Factorial via loop/recur
  ;;' (loop ((n 5) (acc 1))
  ;;'   (if (= n 0)
  ;;'     acc
  ;;'     (recur (- n 1) (* acc n))))  ; => 120
  ;;'
  ;;' ;; Sum of a list via loop/recur
  ;;' (loop ((xs '(1 2 3 4)) (total 0))
  ;;'   (if (null? xs)
  ;;'     total
  ;;'     (recur (cdr xs) (+ total (car xs)))))  ; => 10
  ;;' @note The compiler auto-optimizes self-tail-calls in `(define name (lambda ...))` patterns, so `loop`/`recur` is primarily useful for anonymous iteration and mutual recursion patterns. Expands to an R `while` loop internally.
  ;;' @seealso recur, while, for
  (defmacro loop (bindings . body)
    "Clojure-style loop/recur that expands to an R while loop."
    (begin
      ;; Validate bindings or fall back to runtime loop function
      (if (not (valid-bindings? bindings))
        `((lambda (loop-fn) (loop-fn ,bindings ,@body)) loop)
        (begin
          ;; Extract variables and generate gensyms
          (define vars (map car bindings))
          (define recur-flag (gensym "recur_flag"))
          (define recur-vals (gensym "recur_vals"))
          (define loop-result (gensym "loop_result"))
          (define loop-step (gensym "loop_step"))
          (define loop-done (gensym "loop_done"))

          ;; Rewrite body to transform recur calls
          (define rewritten-body
            (map (lambda (expr) (rewrite-recur expr vars recur-flag recur-vals))
                 body))

          ;; Generate the rebinding block
          (define rebind-block (generate-rebindings vars recur-vals))

          ;; Emit the loop structure (use done flag instead of break so we stay inside R's while)
          `(begin
             ;; Initialize loop variables
             ,@(map (lambda (pair) `(define ,(car pair) ,(car (cdr pair)))) bindings)
             (define ,recur-flag #f)
             (define ,recur-vals (list))
             (define ,loop-result #f)
             (define ,loop-done #f)
             (define ,loop-step (lambda () (begin ,@rewritten-body)))

             (while (not ,loop-done)
               (set! ,recur-flag #f)
               (set! ,loop-result (,loop-step))
               (if ,recur-flag
                 (r/eval ,rebind-block (current-env))
                 (set! ,loop-done #t)))

             ,loop-result)))))

  ;;
  ;; misc loops
  ;;

  ;;' @examples
  ;;' (define i 0)
  ;;' (until (= i 5)
  ;;'   (set! i (+ i 1)))
  ;;' i                          ; => 5
  ;;' @seealso while
  (defmacro until (test . body)
    "Repeat body until test is truthy."
    `(while (not ,test) ,@body))
)
