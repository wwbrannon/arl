;;; Rye Standard Library - Error Handling Macros

(module error
  (export try)

  (import types)
  (import list)
  (import control)

;;' @section Error Handling

  ;;' @description Macro wrapper around try* with catch/finally.
  ;;' @examples
  ;;' ;; Basic try with catch
  ;;' (try (/ 1 0)
  ;;'   (catch e (string "caught: " ($ e "message"))))
  ;;'
  ;;' ;; try with finally (always runs)
  ;;' (try (+ 1 2)
  ;;'   (finally (display "cleanup")))    ; => 3
  ;;'
  ;;' ;; try with both catch and finally
  ;;' (try (stop "oops")
  ;;'   (catch e (string "error: " ($ e "message")))
  ;;'   (finally (display "done")))       ; => "error: oops"
  ;;'
  ;;' ;; try with no handlers (just evaluates body)
  ;;' (try (+ 1 2))                       ; => 3
  ;;' @note Macro wrapper around `try*` that provides familiar catch/finally syntax. The catch clause binds the error condition to the given variable. The finally clause runs regardless of success or failure.
  ;;' @seealso try* (in `control` module)
  (defmacro try (body . clauses)
    (begin
      (define catch-clause #nil)
      (define finally-clause #nil)
      (define first (car clauses))
      (define second (car (cdr clauses)))
      (if (and (list? first) (symbol? (car first)) (= (as.character (car first)) "catch"))
        (begin
          (define catch-clause first)
          (if (and (list? second) (symbol? (car second)) (= (as.character (car second)) "finally"))
            (define finally-clause second)))
        (if (and (list? first) (symbol? (car first)) (= (as.character (car first)) "finally"))
          (define finally-clause first)))
      (if (null? catch-clause)
        (if (null? finally-clause)
          `(try* (lambda () ,body))
          `(try* (lambda () ,body)
             :finally_handler (lambda () ,@(cdr finally-clause))))
        (if (null? finally-clause)
          `(try* (lambda () ,body)
             :error_handler (lambda (,(car (cdr catch-clause))) ,@(cdr (cdr catch-clause))))
          `(try* (lambda () ,body)
             :error_handler (lambda (,(car (cdr catch-clause))) ,@(cdr (cdr catch-clause)))
             :finally_handler (lambda () ,@(cdr finally-clause)))))))
)
