;;; Rye Standard Library - Math Helpers

(module math
  (export % + * - / min max
          < > <= >= == =
          inc dec clamp within?
          even? odd? zero?
          positive? negative? non-negative? non-positive?
          integer? natural?
          real? complex? rational? exact? inexact?
          finite? infinite? nan?
          abs floor ceiling truncate round signum
          sqrt expt
          log logb exp log10 log2
          sin cos tan asin acos atan atan2
          quotient remainder modulo
          gcd lcm
          make-rectangular make-polar real-part imag-part magnitude angle)

  (import _r)
  (import core)
  (import types)  ; for number? predicate

  (define %
    (lambda (x y)
      "Modulo helper using R %%."
      (%% x y)))

  (define <
    (lambda (. args)
      "Variadic less-than comparison. Checks all adjacent pairs."
      (if (__r< (__rlength args) 2)
        #t
        (if (__r== (__rlength args) 2)
          (__r< (__r[[ args 1) (__r[[ args 2))
          (begin
            (define result #t)
            (define remaining args)
            (while (and (__r> (__rlength remaining) 1) result)
              (begin
                (if (not (__r< (car remaining) (car (cdr remaining))))
                  (set! result #f)
                  #nil)
                (set! remaining (cdr remaining))))
            result)))))

  (define >
    (lambda (. args)
      "Variadic greater-than comparison. Checks all adjacent pairs."
      (if (__r< (__rlength args) 2)
        #t
        (if (__r== (__rlength args) 2)
          (__r> (__r[[ args 1) (__r[[ args 2))
          (begin
            (define result #t)
            (define remaining args)
            (while (and (__r> (__rlength remaining) 1) result)
              (begin
                (if (not (__r> (car remaining) (car (cdr remaining))))
                  (set! result #f)
                  #nil)
                (set! remaining (cdr remaining))))
            result)))))

  (define <=
    (lambda (. args)
      "Variadic less-than-or-equal comparison. Checks all adjacent pairs."
      (if (__r< (__rlength args) 2)
        #t
        (if (__r== (__rlength args) 2)
          (__r<= (__r[[ args 1) (__r[[ args 2))
          (begin
            (define result #t)
            (define remaining args)
            (while (and (__r> (__rlength remaining) 1) result)
              (begin
                (if (not (__r<= (car remaining) (car (cdr remaining))))
                  (set! result #f)
                  #nil)
                (set! remaining (cdr remaining))))
            result)))))

  (define >=
    (lambda (. args)
      "Variadic greater-than-or-equal comparison. Checks all adjacent pairs."
      (if (__r< (__rlength args) 2)
        #t
        (if (__r== (__rlength args) 2)
          (__r>= (__r[[ args 1) (__r[[ args 2))
          (begin
            (define result #t)
            (define remaining args)
            (while (and (__r> (__rlength remaining) 1) result)
              (begin
                (if (not (__r>= (car remaining) (car (cdr remaining))))
                  (set! result #f)
                  #nil)
                (set! remaining (cdr remaining))))
            result)))))

  (define ==
    (lambda (. args)
      "Variadic equality comparison. Checks all adjacent pairs."
      (if (__r< (__rlength args) 2)
        #t
        (if (__r== (__rlength args) 2)
          (__r== (__r[[ args 1) (__r[[ args 2))
          (begin
            (define result #t)
            (define remaining args)
            (while (and (__r> (__rlength remaining) 1) result)
              (begin
                (if (not (__r== (car remaining) (car (cdr remaining))))
                  (set! result #f)
                  #nil)
                (set! remaining (cdr remaining))))
            result)))))

  ;; Alias = to == for convenience
  (define = ==)

  (define +
    (lambda (. args)
      "Variadic addition."
      (if (__r== (__rlength args) 0)
        0
        (if (__r== (__rlength args) 1)
          (__r[[ args 1)
          (Reduce __r+ args)))))

  (define *
    (lambda (. args)
      "Variadic multiplication."
      (if (__r== (__rlength args) 0)
        1
        (if (__r== (__rlength args) 1)
          (__r[[ args 1)
          (Reduce __r* args)))))

  (define -
    (lambda (. args)
      "Variadic subtraction."
      (if (__r== (__rlength args) 0)
        (stop "- requires at least one argument")
        (if (__r== (__rlength args) 1)
          (__r- 0 (__r[[ args 1))
          (Reduce __r- args)))))

  (define /
    (lambda (. args)
      "Variadic division."
      (if (__r== (__rlength args) 0)
        (stop "/ requires at least one argument")
        (if (__r== (__rlength args) 1)
          (__r/ 1 (__r[[ args 1))
          (Reduce __r/ args)))))

  (define min
    (lambda (. args)
      "Variadic min."
      (if (= (__rlength args) 0)
        (stop "min requires at least one argument")
        (do.call __rmin args))))

  (define max
    (lambda (. args)
      "Variadic max."
      (if (= (__rlength args) 0)
        (stop "max requires at least one argument")
        (do.call __rmax args))))

  (define inc
    (lambda (x (n 1))
      "Increment numeric value by n (default 1)."
      (+ x n)))

  (define dec
    (lambda (x (n 1))
      "Decrement numeric value by n (default 1)."
      (- x n)))

  (define clamp
    (lambda (x lo hi)
      "Clamp numeric value x to the inclusive range [lo, hi]."
      (if (< x lo)
        lo
        (if (> x hi) hi x))))

  (define within?
    (lambda (x lo hi)
      "Return #t if x is within the inclusive range [lo, hi]."
      (if (< x lo)
        #f
        (if (> x hi) #f #t))))

  (define even?
    (lambda (x)
      "Return #t if x is an even number."
      (isTRUE (== (%% x 2) 0))))

  (define odd?
    (lambda (x)
      "Return #t if x is an odd number."
      (isTRUE (== (%% x 2) 1))))

  (define zero?
    (lambda (x)
      "Return #t if x is zero."
      (isTRUE (== x 0))))

  (define positive?
    (lambda (x)
      "Return #t if x is greater than zero."
      (isTRUE (> x 0))))

  (define negative?
    (lambda (x)
      "Return #t if x is less than zero."
      (isTRUE (< x 0))))

  (define non-negative?
    (lambda (x)
      "Return #t if x is greater than or equal to zero."
      (isTRUE (>= x 0))))

  (define non-positive?
    (lambda (x)
      "Return #t if x is less than or equal to zero."
      (isTRUE (<= x 0))))

  (define integer?
    (lambda (x)
      "Return #t if x is an integer-valued number."
      (if (is.numeric x)
        (if (is.finite x)
          (isTRUE (== x (as.integer x)))
          #f)
        #f)))

  (define natural?
    (lambda (x)
      "Return #t if x is a natural number (integer >= 0)."
      (if (integer? x)
        (isTRUE (>= x 0))
        #f)))

  ;; Numeric type predicates
  (define real?
    (lambda (x)
      "Return #t if x is a real number (includes Â±Inf, excludes complex)."
      (if (is.numeric x)
        (if (is.complex x) #f #t)
        #f)))

  (define complex?
    (lambda (x)
      "Return #t if x is a complex number."
      (is.complex x)))

  (define rational?
    (lambda (x)
      "Return #t if x is a finite real number (rational in R are finite floats)."
      (if (real? x)
        (if (is.finite x) #t #f)
        #f)))

  (define exact?
    (lambda (x)
      "Return #t if x is an exact number (integer storage type in R)."
      (is.integer x)))

  (define inexact?
    (lambda (x)
      "Return #t if x is an inexact number (double or complex in R)."
      (if (number? x)
        (not (is.integer x))
        #f)))

  (define finite?
    (lambda (x)
      "Return #t if x is finite."
      (isTRUE (is.finite x))))

  (define infinite?
    (lambda (x)
      "Return #t if x is infinite."
      (isTRUE (is.infinite x))))

  (define nan?
    (lambda (x)
      "Return #t if x is NaN."
      (isTRUE (is.nan x))))

  ;; ============================================================================
  ;; Complex Number Utilities
  ;; ============================================================================

  (define make-rectangular
    (lambda (real imag)
      "Construct a complex number from real and imaginary parts."
      (complex :real real :imaginary imag)))

  (define make-polar
    (lambda (magnitude angle)
      "Construct a complex number from polar coordinates (magnitude and angle)."
      (complex :modulus magnitude :argument angle)))

  (define real-part
    (lambda (z)
      "Extract the real part of a complex number."
      (Re z)))

  (define imag-part
    (lambda (z)
      "Extract the imaginary part of a complex number."
      (Im z)))

  (define magnitude
    (lambda (z)
      "Compute the magnitude (modulus) of a complex number."
      (Mod z)))

  (define angle
    (lambda (z)
      "Compute the angle (argument) of a complex number."
      (Arg z)))

  ;; ============================================================================
  ;; Phase 1: Extended Numeric Operations
  ;; ============================================================================

  ;; DESIGN NOTE: Simple one-argument pass-through functions use direct assignment
  ;; (define func __rfunc) rather than lambda wrappers to avoid unnecessary stack frames.
  ;; Docstrings are attached using (doc! func "...") after definition.
  ;; Functions with multiple arguments, optional parameters, or custom logic remain as lambdas.

  (import core)  ; for doc!

  ;; Rounding and truncation
  (define abs __rabs)
  (doc! abs "Return absolute value of x.")

  (define floor __rfloor)
  (doc! floor "Return floor (round down) of x.")

  (define ceiling __rceiling)
  (doc! ceiling "Return ceiling (round up) of x.")

  (define truncate __rtrunc)
  (doc! truncate "Return truncated (towards zero) value of x.")

  (define round
    (lambda (x (digits 0))
      "Round x to given number of decimal places (default 0)."
      (__rround x digits)))

  (define signum __rsign)
  (doc! signum "Return sign of x: -1, 0, or 1.")

  ;; Power and roots
  (define sqrt __rsqrt)
  (doc! sqrt "Return square root of x.")

  (define expt
    (lambda (base power)
      "Return base raised to power."
      (__r^ base power)))

  ;; Logarithmic and exponential
  ;; FIXME: Cannot override R's primitive 'log' with optional parameters due to
  ;; module system issue - optional params don't survive module export when
  ;; overriding existing functions. Using separate 'logb' function as workaround.
  (define log __rlog)
  (doc! log "Return natural logarithm of x.")

  (define logb
    (lambda (x base)
      "Return logarithm of x with given base."
      (__rlog x base)))

  (define exp __rexp)
  (doc! exp "Return e raised to power x.")

  (define log10 __rlog10)
  (doc! log10 "Return base-10 logarithm of x.")

  (define log2 __rlog2)
  (doc! log2 "Return base-2 logarithm of x.")

  ;; Trigonometric functions
  (define sin __rsin)
  (doc! sin "Return sine of x (in radians).")

  (define cos __rcos)
  (doc! cos "Return cosine of x (in radians).")

  (define tan __rtan)
  (doc! tan "Return tangent of x (in radians).")

  (define asin __rasin)
  (doc! asin "Return arcsine of x (in radians).")

  (define acos __racos)
  (doc! acos "Return arccosine of x (in radians).")

  (define atan __ratan)
  (doc! atan "Return arctangent of x (in radians).")

  (define atan2
    (lambda (y x)
      "Return arctangent of y/x (in radians), respecting quadrant."
      (__ratan2 y x)))

  ;; Integer division
  (define quotient
    (lambda (x y)
      "Return integer quotient of x divided by y."
      (__ras.integer (__rtrunc (__r/ x y)))))

  (define remainder
    (lambda (x y)
      "Return remainder of x divided by y (same sign as x)."
      (__r- x (__r* y (quotient x y)))))

  (define modulo
    (lambda (x y)
      "Return modulo of x and y (same sign as y)."
      (%% x y)))

  ;; Number theory
  (define gcd
    (lambda (. args)
      "Return greatest common divisor of arguments."
      (if (__r== (__rlength args) 0)
        0
        (if (__r== (__rlength args) 1)
          (__rabs (__r[[ args 1))
          (begin
            (define gcd-two
              (lambda (a b)
                "GCD of two numbers using Euclidean algorithm."
                (if (__r== b 0)
                  (__rabs a)
                  (gcd-two b (modulo a b)))))
            (Reduce gcd-two args))))))

  (define lcm
    (lambda (. args)
      "Return least common multiple of arguments."
      (if (__r== (__rlength args) 0)
        1
        (if (__r== (__rlength args) 1)
          (__rabs (__r[[ args 1))
          (begin
            (define lcm-two
              (lambda (a b)
                "LCM of two numbers using a*b/gcd(a,b)."
                (if (if (__r== a 0) #t (__r== b 0))
                  0
                  (__r/ (__rabs (__r* a b)) (gcd a b)))))
            (Reduce lcm-two args))))))
)
