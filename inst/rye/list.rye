;;; Rye Standard Library - List Helpers

(module list
  (export __as-list __list-last __list-head
          call
          car cdr
          caar cadr cdar cddr
          caaar caadr cadar caddr
          cdaar cdadr cddar cdddr
          cadddr cddddr
          cons list* append reverse
          first second third fourth rest last nth
          assoc assoc-by-equal? assoc-by-identical? assoc-by-==
          assq assv rassoc rassoc-by-equal?
          range iota make-list
          list-ref list-tail)

  (import _r)

  ;;' @section List Operations
  ;;' Core list constructors and accessors, following Scheme conventions.
  ;;' Lists in Rye are backed by R lists; `car`/`cdr` provide the fundamental
  ;;' decomposition and `cons` the fundamental construction.

  (define __as-list
    (lambda (x)
      "Coerce calls and vectors to list; dotted pair to proper prefix."
      (if (pair? x)
        (__cons-as-list x)
        (if (is.call x)
          (as.list x)
          (if (is.list x)
            x
            (if (__r== (__rlength x) 0)
              (list)
              (as.list x)))))))

  (define __list-last
    (lambda (lst)
      "Return last element of list."
      (__r[[ lst (__rlength lst))))

  (define __list-head
    (lambda (lst)
      "Return list without last element."
      (if (__r<= (__rlength lst) 1)
        (list)
        (r/call "[" (list lst (seq 1 (__r- (__rlength lst) 1)))))))

  ;;' @examples
  ;;' (call (list '+ 1 2))  ; => language: (+ 1 2)
  ;;' @seealso eval, apply
  (define call
    (lambda (lst)
      "Convert a list to a callable form."
      (if (is.call lst)
        lst
        (as.call (__as-list lst)))))

  ;;' @examples
  ;;' (car (list 1 2 3))    ; => 1
  ;;' (car (list))           ; => #nil
  ;;' (car (cons 'a 'b))    ; => a
  ;;' @seealso cdr, cons, first
  (define car
    (lambda (lst)
      "Return first element or #nil."
      (if (pair? lst)
        (r/call "[[" (list lst "car"))
        (if (is.call lst)
          (if (__r> (__rlength lst) 0) (__r[[ lst 1) #nil)
          (if (is.list lst)
            (if (__r> (__rlength lst) 0) (__r[[ lst 1) #nil)
            #nil)))))

  ;;' @examples
  ;;' (cdr (list 1 2 3))    ; => (2 3)
  ;;' (cdr (list 1))        ; => ()
  ;;' (cdr (cons 'a 'b))    ; => b
  ;;' @seealso car, cons, rest
  (define cdr
    (lambda (lst)
      "Return list without first element (or cdr of dotted pair)."
      (if (pair? lst)
        (r/call "[[" (list lst "cdr"))
        (if (is.call lst)
          (if (__r> (__rlength lst) 1)
            (r/call "[" (list (as.list lst) (seq 2 (__rlength lst))))
            (list))
          (if (is.list lst)
            (if (__r> (__rlength lst) 1)
              (r/call "[" (list lst (seq 2 (__rlength lst))))
              (list))
            (list))))))

  ;; Common composed list accessors
  ;; These intentionally compose the semantics of car/cdr (including #nil / empty list handling).
  (define caar (lambda (x) "car of car." (car (car x))))
  (define cadr (lambda (x) "car of cdr." (car (cdr x))))
  (define cdar (lambda (x) "cdr of car." (cdr (car x))))
  (define cddr (lambda (x) "cdr of cdr." (cdr (cdr x))))

  (define caaar (lambda (x) "car of car of car." (car (car (car x)))))
  (define caadr (lambda (x) "car of car of cdr." (car (car (cdr x)))))
  (define cadar (lambda (x) "car of cdr of car." (car (cdr (car x)))))
  (define caddr (lambda (x) "car of cdr of cdr." (car (cdr (cdr x)))))

  (define cdaar (lambda (x) "cdr of car of car." (cdr (car (car x)))))
  (define cdadr (lambda (x) "cdr of car of cdr." (cdr (car (cdr x)))))
  (define cddar (lambda (x) "cdr of cdr of car." (cdr (cdr (car x)))))
  (define cdddr (lambda (x) "cdr of cdr of cdr." (cdr (cdr (cdr x)))))

  (define cadddr (lambda (x) "car of cdr of cdr of cdr." (car (cdr (cdr (cdr x))))))
  (define cddddr (lambda (x) "cdr of cdr of cdr of cdr." (cdr (cdr (cdr (cdr x))))))

  ;;' @examples
  ;;' (cons 1 (list 2 3))   ; => (1 2 3)
  ;;' (cons 'a (list 'b))   ; => (a b)
  ;;' (cons 'a 'b)          ; => dotted pair (a . b)
  ;;' @seealso car, cdr, append
  (define cons
    (lambda (item lst)
      "Prepend item to list or call; dotted pair when cdr is not a list."
      (if (is.call lst)
        (as.call (c (list item) (as.list lst)))
        (if (is.list lst)
          (c (list item) lst)
          (__cons item lst)))))

  ;;' @examples
  ;;' (list* 1 2 (list 3 4))  ; => (1 2 3 4)
  ;;' (list* 1 2 3)           ; => (1 2 3)
  ;;' (list*)                  ; => ()
  ;;' @seealso list, cons, append
  (define list*
    (lambda (. args)
      "Build list ending with last arg."
      (if (= (__rlength args) 0)
        (list)
        (if (= (__rlength args) 1)
          (car args)
          (begin
            (define last (__list-last args))
            (define head (__list-head args))
            (if (is.list last)
              (c head (__as-list last))
              (if (is.call last)
                (c head (__as-list last))
                (c head (list last)))))))))

  ;;' @examples
  ;;' (append (list 1 2) (list 3 4))    ; => (1 2 3 4)
  ;;' (append (list 1) (list 2) (list 3)); => (1 2 3)
  ;;' (append (list 1 2) (list))         ; => (1 2)
  ;;' @seealso cons, list*
  (define append
    (lambda (. lists)
      "Concatenate multiple lists into one."
      (define result (list))
      (define remaining (__as-list lists))
      (while (__r> (__rlength remaining) 0)
        (set! result (c result (__as-list (car remaining))))
        (set! remaining (cdr remaining)))
      result))

  ;;' @examples
  ;;' (reverse (list 1 2 3))  ; => (3 2 1)
  ;;' (reverse (list))        ; => ()
  (define reverse
    (lambda (x)
      "Reverse list."
      (rev (__as-list x))))

  ;;' @seealso car, rest, last
  (define first
    (lambda (lst)
      "Alias for car."
      (car lst)))

  (define second
    (lambda (lst)
      "Return second element or #nil."
      (cadr lst)))

  (define third
    (lambda (lst)
      "Return third element or #nil."
      (caddr lst)))

  (define fourth
    (lambda (lst)
      "Return fourth element or #nil."
      (cadddr lst)))

  ;;' @seealso cdr, first
  (define rest
    (lambda (lst)
      "Alias for cdr."
      (cdr lst)))

  ;;' @examples
  ;;' (last (list 1 2 3))   ; => 3
  ;;' (last (list 42))      ; => 42
  ;;' (last (list))         ; => #nil
  ;;' @seealso first, nth
  (define last
    (lambda (lst)
      "Return last item or #nil."
      (define items (__as-list lst))
      (if (= (__rlength items) 0) #nil (__list-last items))))

  ;;' @examples
  ;;' (nth (list 'a 'b 'c) 0)  ; => a
  ;;' (nth (list 'a 'b 'c) 2)  ; => c
  ;;' @seealso first, last
  (define nth
    (lambda (lst n)
      "Return nth item (0-based)."
      (define items (__as-list lst))
      (if (< n 0)
        (stop (sprintf "Index %d out of bounds for list of length %d" n (__rlength items)))
        (if (>= n (__rlength items))
          (stop (sprintf "Index %d out of bounds for list of length %d" n (__rlength items)))
          (r/call "[[" (list items (+ n 1)))))))

  ;; ============================================================================
  ;; Phase 2: Extended List Operations
  ;; ============================================================================

  ;;' @section Association Lists
  ;;' Association lists (alists) map keys to values. Each entry is a list
  ;;' whose `car` is the key and whose `cadr` is the value. `assoc` and
  ;;' friends search by key; `rassoc` searches by value.

  ;; Internal: predicate (key-in-entry target-key) -> boolean; entry = alist element (list or dotted pair).
  ;; __r== can return a vector; treat as match only when scalar #t or all true.
  (define __r==-pred
    (lambda (a b)
      "Wrap R's == to handle vector results; returns #t only if all elements match."
      (define comp-result (__r== a b))
      (if (r/call "is.logical" (list comp-result))
        (if (__r> (r/call "length" (list comp-result)) 1)
          (isTRUE (r/call "all" (list comp-result)))
          (isTRUE comp-result))
        #f)))

  (define __assoc-by-pred
    (lambda (key alist pred)
      "Find first alist entry with matching key using given predicate."
      (define result #nil)
      (define remaining (__as-list alist))
      (while (and (not (null? remaining)) (not result))
        (begin
          (define pair (car remaining))
          (if (and (list? pair) (>= (__rlength pair) 1))
            (if (pred (car pair) key)
              (set! result pair)
              #nil)
            #nil)
          (set! remaining (cdr remaining))))
      result))

  ;;' @examples
  ;;' (assoc 'b (list (list 'a 1) (list 'b 2) (list 'c 3)))  ; => (b 2)
  ;;' (assoc 'z (list (list 'a 1) (list 'b 2)))               ; => #nil
  ;;' @seealso rassoc, assoc-by-identical?, assoc-by-==
  (define assoc
    (lambda (key alist)
      "Find first alist entry (list or dotted pair) with matching key (uses equal?)."
      (__assoc-by-pred key alist equal?)))

  ;;' @seealso assoc
  (define assoc-by-equal?
    (lambda (key alist)
      "Alias for assoc: find first alist entry with key matching under equal?."
      (assoc key alist)))

  ;;' @seealso assoc, assoc-by-==
  (define assoc-by-identical?
    (lambda (key alist)
      "Find first alist entry with matching key (uses R's identical?)."
      (__assoc-by-pred key alist identical?)))

  ;;' @seealso assoc, assoc-by-identical?
  (define assoc-by-==
    (lambda (key alist)
      "Find first alist entry with matching key (uses R's ==)."
      (__assoc-by-pred key alist __r==-pred)))

  ;;' @note assq cannot be properly implemented in R (no eq?). Use assoc, assoc-by-identical?, or assoc-by-== instead.
  (define assq
    (lambda (key alist)
      "assq cannot be properly implemented in R (no eq?). Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead."
      (error "assq cannot be properly implemented in R. Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead.")))

  ;;' @note assv cannot be properly implemented in R (no eqv?). Use assoc, assoc-by-identical?, or assoc-by-== instead.
  (define assv
    (lambda (key alist)
      "assv cannot be properly implemented in R (no eqv?). Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead."
      (error "assv cannot be properly implemented in R. Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead.")))

  ;;' @examples
  ;;' (rassoc 2 (list (list 'a 1) (list 'b 2) (list 'c 3)))  ; => (b 2)
  ;;' (rassoc 9 (list (list 'a 1) (list 'b 2)))               ; => #nil
  ;;' @seealso assoc, rassoc-by-equal?
  (define rassoc
    (lambda (value alist)
      "Find first alist entry with matching value (searches cdr of entries; uses equal?)."
      (define result #nil)
      (define remaining (__as-list alist))
      (while (and (not (null? remaining)) (not result))
        (begin
          (define pair (car remaining))
          (if (and (list? pair) (>= (__rlength pair) 2))
            (if (equal? (cadr pair) value)
              (set! result pair)
              #nil)
            #nil)
          (set! remaining (cdr remaining))))
      result))

  ;;' @seealso rassoc
  (define rassoc-by-equal?
    (lambda (value alist)
      "Alias for rassoc: find first alist entry with value matching under equal?."
      (rassoc value alist)))

  ;;' @section List Generation
  ;;' Utilities for creating lists of numbers or repeated values.

  ;;' @examples
  ;;' (range 0 5)       ; => (0 1 2 3 4)
  ;;' (range 0 10 2)    ; => (0 2 4 6 8)
  ;;' (range 5 0 -1)    ; => (5 4 3 2 1)
  ;;' @seealso iota, make-list
  (define range
    (lambda (start end . step-args)
      "Generate numeric range from start to end (exclusive) with optional step."
      (define step (if (> (__rlength step-args) 0) (car step-args) 1))
      (if (= step 0)
        (stop "range: step cannot be zero")
        (if (> step 0)
          ;; Positive step: start < end
          (if (>= start end)
            (list)
            (as.list (seq start (- end 1) step)))
          ;; Negative step: start > end
          (if (<= start end)
            (list)
            (as.list (seq start (+ end 1) step)))))))

  ;;' @examples
  ;;' (iota 5)          ; => (0 1 2 3 4)
  ;;' (iota 5 1)        ; => (1 2 3 4 5)
  ;;' (iota 5 0 2)      ; => (0 2 4 6 8)
  ;;' @seealso range, make-list
  (define iota
    (lambda (count . args)
      "Generate sequence of count numbers starting from start (default 0) with step (default 1)."
      (define start (if (> (__rlength args) 0) (car args) 0))
      (define step (if (> (__rlength args) 1) (cadr args) 1))
      (if (<= count 0)
        (list)
        (as.list (seq start (+ start (* (- count 1) step)) step)))))

  ;;' @examples
  ;;' (make-list 3 'x)    ; => (x x x)
  ;;' (make-list 0 'x)    ; => ()
  ;;' @seealso iota, range
  (define make-list
    (lambda (n value)
      "Create list of n copies of value."
      (if (<= n 0)
        (list)
        ;; Use explicit loop to avoid stack overflow and handle symbols
        (begin
          (define result (list))
          (define i 0)
          (while (< i n)
            (begin
              (set! result (cons value result))
              (set! i (+ i 1))))
          result))))

  ;;' @section Additional List Accessors

  ;;' @examples
  ;;' (list-ref (list 'a 'b 'c) 1)  ; => b
  ;;' @seealso nth
  (define list-ref
    (lambda (lst index)
      "Scheme-style list accessor (alias for nth)."
      (nth lst index)))

  ;;' @examples
  ;;' (list-tail (list 'a 'b 'c 'd) 2)  ; => (c d)
  ;;' (list-tail (list 1 2 3) 0)         ; => (1 2 3)
  ;;' @seealso drop
  (define list-tail
    (lambda (lst k)
      "Return list without first k elements."
      (define items (__as-list lst))
      (if (<= k 0)
        items
        (if (>= k (__rlength items))
          (list)
          (as.list (r/call "[" (list items (seq (+ k 1) (__rlength items)))))))))
)
