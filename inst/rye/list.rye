;;; Rye Standard Library - List Helpers

(module list
  (export __as-list __list-last __list-head
          call
          car cdr
          caar cadr cdar cddr
          caaar caadr cadar caddr
          cdaar cdadr cddar cdddr
          cadddr cddddr
          cons list* append reverse
          first second third fourth rest last nth
          assoc assoc-by-equal? assoc-by-identical? assoc-by-==
          assq assv rassoc rassoc-by-equal?
          sort sort-by merge stable-sort
          range iota make-list
          list-ref list-tail)

  (import _aliases)

  (define __as-list
    (lambda (x)
      "Coerce calls and vectors to list; rye_cons chain to proper prefix."
      (if (r/call "rye_cons_p" (list x))
        (r/call "rye_cons_as_list" (list x))
        (if (is.call x)
          (as.list x)
          (if (is.list x)
            x
            (if (__r== (__rlength x) 0)
              (list)
              (as.list x)))))))

  (define __list-last
    (lambda (lst)
      "Return last element of list."
      (__r[[ lst (__rlength lst))))

  (define __list-head
    (lambda (lst)
      "Return list without last element."
      (if (__r<= (__rlength lst) 1)
        (list)
        (r/call "[" (list lst (seq 1 (__r- (__rlength lst) 1)))))))

  (define call
    (lambda (lst)
      "Convert a list to a callable form."
      (if (is.call lst)
        lst
        (as.call (__as-list lst)))))

  (define car
    (lambda (lst)
      "Return first element or #nil."
      (if (r/call "rye_cons_p" (list lst))
        (r/call "[[" (list lst "car"))
        (if (is.call lst)
          (if (__r> (__rlength lst) 0) (__r[[ lst 1) #nil)
          (if (is.list lst)
            (if (__r> (__rlength lst) 0) (__r[[ lst 1) #nil)
            #nil)))))

  (define cdr
    (lambda (lst)
      "Return list without first element (or cdr of dotted pair)."
      (if (r/call "rye_cons_p" (list lst))
        (r/call "[[" (list lst "cdr"))
        (if (is.call lst)
          (if (__r> (__rlength lst) 1)
            (r/call "[" (list (as.list lst) (seq 2 (__rlength lst))))
            (list))
          (if (is.list lst)
            (if (__r> (__rlength lst) 1)
              (r/call "[" (list lst (seq 2 (__rlength lst))))
              (list))
            (list))))))

  ;; Common composed list accessors
  ;; These intentionally compose the semantics of car/cdr (including #nil / empty list handling).
  (define caar (lambda (x) "car of car." (car (car x))))
  (define cadr (lambda (x) "car of cdr." (car (cdr x))))
  (define cdar (lambda (x) "cdr of car." (cdr (car x))))
  (define cddr (lambda (x) "cdr of cdr." (cdr (cdr x))))

  (define caaar (lambda (x) "car of car of car." (car (car (car x)))))
  (define caadr (lambda (x) "car of car of cdr." (car (car (cdr x)))))
  (define cadar (lambda (x) "car of cdr of car." (car (cdr (car x)))))
  (define caddr (lambda (x) "car of cdr of cdr." (car (cdr (cdr x)))))

  (define cdaar (lambda (x) "cdr of car of car." (cdr (car (car x)))))
  (define cdadr (lambda (x) "cdr of car of cdr." (cdr (car (cdr x)))))
  (define cddar (lambda (x) "cdr of cdr of car." (cdr (cdr (car x)))))
  (define cdddr (lambda (x) "cdr of cdr of cdr." (cdr (cdr (cdr x)))))

  (define cadddr (lambda (x) "car of cdr of cdr of cdr." (car (cdr (cdr (cdr x))))))
  (define cddddr (lambda (x) "cdr of cdr of cdr of cdr." (cdr (cdr (cdr (cdr x))))))

  (define cons
    (lambda (item lst)
      "Prepend item to list or call; dotted pair when cdr is not a list."
      (if (is.call lst)
        (as.call (c (list item) (as.list lst)))
        (if (is.list lst)
          (c (list item) lst)
          (r/call "rye_cons" (list item lst))))))

  (define list*
    (lambda (. args)
      "Build list ending with last arg."
      (if (= (__rlength args) 0)
        (list)
        (if (= (__rlength args) 1)
          (car args)
          (begin
            (define last (__list-last args))
            (define head (__list-head args))
            (if (is.list last)
              (c head (__as-list last))
              (if (is.call last)
                (c head (__as-list last))
                (c head (list last)))))))))

  (define append
    (lambda (. lists)
      (define result (list))
      (for (lst lists)
        (set! result (c result (__as-list lst))))
      result))

  (define reverse
    (lambda (x)
      "Reverse list."
      (rev (__as-list x))))

  (define first
    (lambda (lst)
      "Alias for car."
      (car lst)))

  (define second
    (lambda (lst)
      "Return second element or #nil."
      (cadr lst)))

  (define third
    (lambda (lst)
      "Return third element or #nil."
      (caddr lst)))

  (define fourth
    (lambda (lst)
      "Return fourth element or #nil."
      (cadddr lst)))

  (define rest
    (lambda (lst)
      "Alias for cdr."
      (cdr lst)))

  (define last
    (lambda (lst)
      "Return last item or #nil."
      (define items (__as-list lst))
      (if (= (__rlength items) 0) #nil (__list-last items))))

  (define nth
    (lambda (lst n)
      "Return nth item (0-based)."
      (define items (__as-list lst))
      (if (< n 0)
        (stop (sprintf "Index %d out of bounds for list of length %d" n (__rlength items)))
        (if (>= n (__rlength items))
          (stop (sprintf "Index %d out of bounds for list of length %d" n (__rlength items)))
          (r/call "[[" (list items (+ n 1)))))))

  ;; ============================================================================
  ;; Phase 2: Extended List Operations
  ;; ============================================================================

  ;; Association lists (alists)
  ;; Internal: predicate (key-in-pair target-key) -> boolean.
  ;; __r== can return a vector; treat as match only when scalar #t or all true.
  (define __r==-pred
    (lambda (a b)
      (define comp-result (__r== a b))
      (if (r/call "is.logical" (list comp-result))
        (if (__r> (r/call "length" (list comp-result)) 1)
          (isTRUE (r/call "all" (list comp-result)))
          (isTRUE comp-result))
        #f)))

  (define __assoc-by-pred
    (lambda (key alist pred)
      (define result #nil)
      (define remaining (__as-list alist))
      (while (and (not (null? remaining)) (not result))
        (begin
          (define pair (car remaining))
          (when (and (list? pair) (>= (__rlength pair) 1))
            (when (pred (car pair) key)
              (set! result pair)))
          (set! remaining (cdr remaining))))
      result))

  (define assoc
    (lambda (key alist)
      "Find first pair in alist with matching key (uses equal?)."
      (__assoc-by-pred key alist equal?)))

  (define assoc-by-equal?
    (lambda (key alist)
      "Alias for assoc: find first pair with key matching under equal?."
      (assoc key alist)))

  (define assoc-by-identical?
    (lambda (key alist)
      "Find first pair in alist with matching key (uses R's identical?)."
      (__assoc-by-pred key alist identical?)))

  (define assoc-by-==
    (lambda (key alist)
      "Find first pair in alist with matching key (uses R's ==)."
      (__assoc-by-pred key alist __r==-pred)))

  (define assq
    (lambda (key alist)
      "assq cannot be properly implemented in R (no eq?). Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead."
      (error "assq cannot be properly implemented in R. Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead.")))

  (define assv
    (lambda (key alist)
      "assv cannot be properly implemented in R (no eqv?). Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead."
      (error "assv cannot be properly implemented in R. Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead.")))

  (define rassoc
    (lambda (value alist)
      "Find first pair in alist with matching value (searches cdr of pairs; uses equal?)."
      (define result #nil)
      (define remaining (__as-list alist))
      (while (and (not (null? remaining)) (not result))
        (begin
          (define pair (car remaining))
          (when (and (list? pair) (>= (__rlength pair) 2))
            (when (equal? (cadr pair) value)
              (set! result pair)))
          (set! remaining (cdr remaining))))
      result))

  (define rassoc-by-equal?
    (lambda (value alist)
      "Alias for rassoc: find first pair with value matching under equal?."
      (rassoc value alist)))

  ;; Sorting
  (define sort
    (lambda (lst comparator)
      "Sort list using comparison function (simple quicksort implementation)."
      (define items (__as-list lst))
      (if (<= (__rlength items) 1)
        items
        (begin
          ;; Simple quicksort
          (define pivot (car items))
          (define rest-items (cdr items))
          ;; Partition into less and greater
          (define less (list))
          (define greater (list))
          (define remaining rest-items)
          (while (not (null? remaining))
            (if (comparator (car remaining) pivot)
              (set! less (append less (list (car remaining))))
              (set! greater (append greater (list (car remaining)))))
            (set! remaining (cdr remaining)))
          (append (sort less comparator)
                  (list pivot)
                  (sort greater comparator))))))

  (define sort-by
    (lambda (lst key-fn comparator)
      "Sort list by applying key-fn to each element, then comparing."
      (define items (__as-list lst))
      (if (<= (__rlength items) 1)
        items
        (begin
          ;; Create pairs of (key . value)
          (define pairs (lapply items (lambda (x) (list (key-fn x) x))))
          ;; Sort by first element of pair
          (define sorted-pairs (sort pairs (lambda (a b) (comparator (car a) (car b)))))
          ;; Extract values
          (lapply sorted-pairs cadr)))))

  (define merge
    (lambda (list1 list2 comparator)
      "Merge two sorted lists into one sorted list."
      (define l1 (__as-list list1))
      (define l2 (__as-list list2))
      (define acc (list))
      (while (and (not (null? l1)) (not (null? l2)))
        (if (comparator (car l1) (car l2))
          (begin
            (set! acc (cons (car l1) acc))
            (set! l1 (cdr l1)))
          (begin
            (set! acc (cons (car l2) acc))
            (set! l2 (cdr l2)))))
      (if (null? l1)
        (append (reverse acc) l2)
        (append (reverse acc) l1))))

  (define stable-sort
    (lambda (lst comparator)
      "Stable sort - preserves order of equal elements."
      ;; R's sort is already stable, so this is an alias
      (sort lst comparator)))

  ;; List generation
  (define range
    (lambda (start end . step-args)
      "Generate numeric range from start to end (exclusive) with optional step."
      (define step (if (> (__rlength step-args) 0) (car step-args) 1))
      (if (= step 0)
        (stop "range: step cannot be zero")
        (if (> step 0)
          ;; Positive step: start < end
          (if (>= start end)
            (list)
            (as.list (seq start (- end 1) step)))
          ;; Negative step: start > end
          (if (<= start end)
            (list)
            (as.list (seq start (+ end 1) step)))))))

  (define iota
    (lambda (count . args)
      "Generate sequence of count numbers starting from start (default 0) with step (default 1)."
      (define start (if (> (__rlength args) 0) (car args) 0))
      (define step (if (> (__rlength args) 1) (cadr args) 1))
      (if (<= count 0)
        (list)
        (as.list (seq start (+ start (* (- count 1) step)) step)))))

  (define make-list
    (lambda (n value)
      "Create list of n copies of value."
      (if (<= n 0)
        (list)
        ;; Use explicit loop to avoid stack overflow and handle symbols
        (begin
          (define result (list))
          (define i 0)
          (while (< i n)
            (begin
              (set! result (cons value result))
              (set! i (+ i 1))))
          result))))

  ;; Additional list accessors
  (define list-ref
    (lambda (lst index)
      "Scheme-style list accessor (alias for nth)."
      (nth lst index)))

  (define list-tail
    (lambda (lst k)
      "Return list without first k elements."
      (define items (__as-list lst))
      (if (<= k 0)
        items
        (if (>= k (__rlength items))
          (list)
          (as.list (r/call "[" (list items (seq (+ k 1) (__rlength items)))))))))
)
