;;; Rye Standard Library - Control Flow Macros

(module control
  (export when unless cond case try*)
  ;; Note: 'and' and 'or' removed from exports - now handled as compiler special forms

  (import predicates)
  (import list)

;;; Control flow macros

(defmacro when (test body)
  "Evaluate body when test is truthy."
  `(if ,test ,body #nil))

(defmacro unless (test body)
  "Evaluate body when test is falsy."
  `(if ,test #nil ,body))

;;; Boolean operators - now handled as compiler special forms
;;; (Phase 2 optimization: eliminate temps for simple values, flatten nested chains)
;;;
;;; OLD macro implementations (commented out):
;;;
;;; (defmacro and (first . rest)
;;;   "Short-circuit boolean AND."
;;;   (if (null? rest)
;;;     first
;;;     `((lambda (tmp)
;;;         (if tmp (and ,@rest) tmp))
;;;       ,first)))
;;;
;;; (defmacro or (first . rest)
;;;   "Short-circuit boolean OR."
;;;   (if (null? rest)
;;;     first
;;;     `((lambda (tmp)
;;;         (if tmp tmp (or ,@rest)))
;;;       ,first)))

;;; Conditional macros

(defmacro cond (clause . rest)
  "Multi-branch conditional."
  (if (null? clause)
    #nil
    (begin
      (define test (car clause))
      (define body (cdr clause))
      (if (and (symbol? test) (= (as.character test) "else"))
        `(begin ,@body)
        `(if ,test (begin ,@body) (cond ,@rest))))))

(defmacro case (key clause . rest)
  "Branch on key equality."
  (if (null? clause)
    #nil
    (begin
      (define datum (car clause))
      (define body (cdr clause))
      (if (and (symbol? datum) (= (as.character datum) "else"))
        `(begin ,@body)
        `(if (= ,key ,datum) (begin ,@body) (case ,key ,@rest))))))

;;; Error handling helper

(define try*
  (lambda (thunk (error_handler #f) (finally_handler #f))
    "Evaluate thunk with error/finally handlers."
    (if (not (is.function thunk))
      (stop "try* expects a function as first argument"))
    (if (and error_handler (not (is.function error_handler)))
      (stop "try* error handler must be a function"))
    (if (and finally_handler (not (is.function finally_handler)))
      (stop "try* finally handler must be a function"))
    (define thunk-expr (call (list thunk)))
    (if (not error_handler)
      (if (not finally_handler)
        (thunk)
        (r/eval (call (list 'tryCatch thunk-expr
                            :finally (call (list finally_handler))))
                (current-env)))
      (if (not finally_handler)
        (r/eval (call (list 'tryCatch thunk-expr
                            :error error_handler))
                (current-env))
        (r/eval (call (list 'tryCatch thunk-expr
                            :error error_handler
                            :finally (call (list finally_handler))))
                (current-env))))))
)
