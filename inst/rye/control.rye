;;; Rye Standard Library - Control Flow Macros

(module control
  (export when unless cond case try*)
  ;; Note: 'and' and 'or' removed from exports - now handled as compiler special forms

  (import types)
  (import list)

;;; Control flow macros

(defmacro when (test . body)
  "Evaluate body forms when test is truthy."
  `(if ,test (begin ,@body) #nil))

(defmacro unless (test . body)
  "Evaluate body forms when test is falsy."
  `(if ,test #nil (begin ,@body)))

;;; Conditional macros

(defmacro cond (clause . rest)
  "Multi-branch conditional."
  (if (null? clause)
    (error "cond: Missing required parameter (else clause)")
    (begin
      (define test (car clause))
      (define body (cdr clause))
      (if (and (symbol? test) (= (as.character test) "else"))
        `(begin ,@body)
        (if (null? rest)
          `(if ,test (begin ,@body) #nil)
          `(if ,test (begin ,@body) (cond ,@rest)))))))

(defmacro case (key clause . rest)
  "Branch on key equality. Each clause: ((datum ...) body ...) or (else body ...)."
  (if (null? clause)
    (error "case: Missing required parameter (else clause)")
    (begin
      (define datums (car clause))
      (define body (cdr clause))
      (if (and (symbol? datums) (= (as.character datums) "else"))
        `(begin ,@body)
        (begin
          ;; datums is a list of values to match against
          (define test-expr
            (if (= (length datums) 1)
              `(= ,key (quote ,(car datums)))
              `(or ,@(map (lambda (d) `(= ,key (quote ,d))) datums))))
          (if (null? rest)
            `(if ,test-expr (begin ,@body) #nil)
            `(if ,test-expr (begin ,@body) (case ,key ,@rest))))))))

;;; Error handling helper

(define try*
  (lambda (thunk (error_handler #f) (finally_handler #f))
    "Evaluate thunk with error/finally handlers."
    (if (not (is.function thunk))
      (stop "try* expects a function as first argument"))
    (if (and error_handler (not (is.function error_handler)))
      (stop "try* error handler must be a function"))
    (if (and finally_handler (not (is.function finally_handler)))
      (stop "try* finally handler must be a function"))
    (define thunk-expr (call (list thunk)))
    (if (not error_handler)
      (if (not finally_handler)
        (thunk)
        (r/eval (call (list 'tryCatch thunk-expr
                            :finally (call (list finally_handler))))
                (current-env)))
      (if (not finally_handler)
        (r/eval (call (list 'tryCatch thunk-expr
                            :error error_handler))
                (current-env))
        (r/eval (call (list 'tryCatch thunk-expr
                            :error error_handler
                            :finally (call (list finally_handler))))
                (current-env))))))
)
