;;; Rye Standard Library - Translator

(module translator
  (export __indent __at __slice __string-in? translate-expr translate-str translate-file translate-source)

  (import predicates)
  (import list)
  (import strings)
  (import io)
  (import control)
  (import looping)

(define __indent
  (lambda (indent)
    (paste (rep "  " indent) :collapse "")))

(define __at
  (lambda (lst idx)
    (r/call "[[" (list lst idx))))

(define __slice
  (lambda (lst start end)
    (if (> start end)
      (list)
      (r/call "[" (list lst (seq start end))))))

(define __string-in?
  (lambda (item items)
    (isTRUE (r/call "%in%" (list item items)))))

(define __r-name
  (lambda (name)
    (define made (as.character (r/call "make.names" (list name))))
    (if (isTRUE (r/call "identical" (list made name)))
      name
      (paste0 "`" name "`"))))

(define translate-expr
  (lambda (expr (indent 0))
    "Translate a Rye AST expression to R code."
    (define indent-str (__indent indent))
    (if (is.null expr)
      "NULL"
      (if (keyword? expr)
        (paste0 (__r-name (as.character expr)) " =")
        (if (is.numeric expr)
          (as.character expr)
          (if (and (is.character expr) (not (symbol? expr)))
            (begin
              (define escaped (string-replace-all expr "\"" "\\\\\"" :fixed #t))
              (paste0 "\"" escaped "\""))
            (if (is.logical expr)
              (as.character expr)
              (if (symbol? expr)
                (begin
                  (define sym-name (as.character expr))
                  (if (= sym-name "#inf")
                    "Inf"
                    (if (= sym-name "#-inf")
                      "-Inf"
                      (if (= sym-name "#nan")
                        "NaN"
                        (__r-name sym-name)))))
                (if (and (is.call expr) (= (length expr) 0))
                  "list()"
                  (if (is.call expr)
                    (begin
                      (define op (car expr))
                      (cond
                        ((and (symbol? op) (= (as.character op) "quote"))
                         (begin
                           (if (!= (length expr) 2)
                             (stop "quote requires exactly 1 argument")
                             #nil)
                           (paste0 "quote(" (translate-expr (__at expr 2) indent) ")")))

                        ((and (symbol? op) (= (as.character op) "quasiquote"))
                         (begin
                           (if (!= (length expr) 2)
                             (stop "quasiquote requires exactly 1 argument")
                             #nil)
                           (paste0 "bquote(" (translate-expr (__at expr 2) indent) ")")))

                        ((and (symbol? op) (= (as.character op) "unquote"))
                         (begin
                           (if (!= (length expr) 2)
                             (stop "unquote requires exactly 1 argument")
                             #nil)
                           (paste0 ".(" (translate-expr (__at expr 2) indent) ")")))

                        ((and (symbol? op) (= (as.character op) "unquote-splicing"))
                         (begin
                           (if (!= (length expr) 2)
                             (stop "unquote-splicing requires exactly 1 argument")
                             #nil)
                           (paste0 ".(" (translate-expr (__at expr 2) indent) ")")))

                        ((and (symbol? op) (= (as.character op) "lambda"))
                         (begin
                           (if (< (length expr) 2)
                             (stop "lambda requires an argument list")
                             #nil)

                           (define args-expr (__at expr 2))
                           (define arg-items (list))
                           (if (not (is.null args-expr))
                             (if (is.call args-expr)
                               (if (> (length args-expr) 0)
                                 (set! arg-items (as.list args-expr))
                                 #nil)
                               (if (is.list args-expr)
                                 (set! arg-items args-expr)
                                 (stop "lambda arguments must be a list")))
                             #nil)

                          (define rest-param (list))
                           (if (> (length arg-items) 0)
                             (begin
                               (define dot-idx
                                 (which
                                   (vapply arg-items
                                           (lambda (arg)
                                             (and (symbol? arg) (= (as.character arg) ".")))
                                           (logical 1))))
                               (if (> (length dot-idx) 1)
                                 (stop "Dotted parameter list can only contain one '.'")
                                 #nil)
                               (if (= (length dot-idx) 1)
                                 (begin
                                   (define dot-pos (__at dot-idx 1))
                                   (if (!= dot-pos (- (length arg-items) 1))
                                     (stop "Dotted parameter list must have exactly one parameter after '.'")
                                     #nil)
                                   (define rest-arg (__at arg-items (+ dot-pos 1)))
                                   (if (not (symbol? rest-arg))
                                     (stop "Rest parameter must be a symbol")
                                     #nil)
                                   (set! rest-param (__r-name (as.character rest-arg)))
                                   (if (> dot-pos 1)
                                     (set! arg-items (__slice arg-items 1 (- dot-pos 1)))
                                     (set! arg-items (list))))
                                 #nil))
                             #nil)

                           (define arg-parts (character 0))
                           (define param-names (character 0))
                           (define i 1)
                           (while (<= i (length arg-items))
                             (begin
                              (define arg (__at arg-items i))
                              (if (symbol? arg)
                                (begin
                                  (define name (__r-name (as.character arg)))
                                  (set! param-names (c param-names name))
                                  (set! arg-parts (c arg-parts name)))
                                 (if (or (is.call arg) (is.list arg))
                                   (begin
                                     (define arg-list (if (is.call arg) (as.list arg) arg))
                                     (if (!= (length arg-list) 2)
                                       (stop "lambda default argument must be a 2-element list")
                                       #nil)
                                     (if (not (symbol? (__at arg-list 1)))
                                       (stop "lambda default argument name must be a symbol")
                                       #nil)
                                     (define name (__r-name (as.character (__at arg-list 1))))
                                     (set! param-names (c param-names name))
                                     (define default-expr (translate-expr (__at arg-list 2) indent))
                                     (set! arg-parts (c arg-parts (paste0 name " = " default-expr))))
                                   (stop "lambda arguments must be symbols or (name default) pairs")))
                               (set! i (+ i 1))))

                           (define all-names param-names)
                          (if (not (null? rest-param))
                             (set! all-names (c all-names rest-param))
                             #nil)
                           (if (and (> (length all-names) 0)
                                    (isTRUE (any (duplicated all-names))))
                             (stop "lambda argument names must be unique")
                             #nil)
                          (if (not (null? rest-param))
                             (set! arg-parts (c arg-parts "..."))
                             #nil)

                           (define body-parts (character 0))
                           (define has-body (>= (length expr) 3))
                           (if has-body
                             (begin
                               (define j 3)
                               (while (<= j (length expr))
                                 (begin
                                   (set! body-parts (c body-parts (translate-expr (__at expr j) (+ indent 1))))
                                   (set! j (+ j 1)))))
                             #nil)

                          (if (not (null? rest-param))
                             (begin
                               (define rest-binding (paste0 rest-param " <- list(...)"))
                               (set! body-parts (c rest-binding body-parts))
                               (if (not has-body)
                                 (set! body-parts (c body-parts "NULL"))
                                 #nil))
                             #nil)

                           (define args-str (paste arg-parts :collapse ", "))
                           (define body-str (paste body-parts :collapse "\n"))
                           (if (= (length body-parts) 0)
                             (paste0 "function(" args-str ") NULL")
                            (if (or (> (length body-parts) 1) (not (null? rest-param)))
                               (begin
                                 (define indent-prefix (__indent (+ indent 1)))
                                 (define indented-body
                                   (paste0 indent-prefix
                                           (string-replace-all body-str "\n"
                                                               (paste0 "\n" indent-prefix)
                                                               :fixed #t)))
                                 (paste0 "function(" args-str ") {\n"
                                         indented-body "\n" indent-str "}"))
                               (paste0 "function(" args-str ") " body-str)))))

                        ((and (symbol? op) (= (as.character op) "define"))
                         (begin
                           (if (!= (length expr) 3)
                             (stop "define requires exactly 2 arguments")
                             #nil)
                           (define name (__r-name (as.character (__at expr 2))))
                           (define value (translate-expr (__at expr 3) indent))
                           (paste0 name " <- " value)))

                        ((and (symbol? op) (= (as.character op) "if"))
                         (begin
                           (if (or (< (length expr) 3) (> (length expr) 4))
                             (stop "if requires 2 or 3 arguments")
                             #nil)
                           (define test (translate-expr (__at expr 2) indent))
                           (define then-expr (translate-expr (__at expr 3) indent))
                           (if (= (length expr) 4)
                             (begin
                               (define else-expr (translate-expr (__at expr 4) indent))
                               (paste0 "if (" test ") " then-expr " else " else-expr))
                             (paste0 "if (" test ") " then-expr))))

                        ((and (symbol? op) (= (as.character op) "begin"))
                         (begin
                           (define parts (character 0))
                           (define j 2)
                           (while (<= j (length expr))
                             (begin
                               (set! parts (c parts (translate-expr (__at expr j) indent)))
                               (set! j (+ j 1))))
                           (paste0 "{\n"
                                   (paste (paste0 indent-str "  " parts) :collapse "\n")
                                   "\n" indent-str "}")))

                        ((and (symbol? op) (= (as.character op) "defmacro"))
                         (begin
                           (if (< (length expr) 4)
                             (stop "defmacro requires at least 3 arguments")
                             #nil)
                           (define name (as.character (__at expr 2)))
                           (paste0 "# Macro: " name " (not translated)")))

                        ((and (symbol? op)
                              (__string-in? (as.character op) (c "::" ":::")))
                         (begin
                           (if (!= (length expr) 3)
                             (stop (paste0 (as.character op) " requires exactly 2 arguments"))
                             #nil)
                           (define pkg (translate-expr (__at expr 2) indent))
                           (define name (translate-expr (__at expr 3) indent))
                           (paste0 pkg (as.character op) name)))

                        ((and (symbol? op) (= (as.character op) "~"))
                         (begin
                           (define parts (character 0))
                           (define j 2)
                           (while (<= j (length expr))
                             (begin
                               (set! parts (c parts (translate-expr (__at expr j) indent)))
                               (set! j (+ j 1))))
                           (paste (c "~" parts) :collapse " ")))

                        ((and (symbol? op)
                              (__string-in? (as.character op)
                                            (c "+" "-" "*" "/" "%%" "%/%" "^"
                                               "<" ">" "<=" ">=" "==" "!="
                                               "&&" "||" "&" "|" "!")))
                         (begin
                           (define op-name (as.character op))
                           (define args (character 0))
                           (define j 2)
                           (while (<= j (length expr))
                             (begin
                               (define arg-expr (__at expr j))
                               (define arg-text (translate-expr arg-expr indent))
                               (if (is.call arg-expr)
                                 (set! arg-text (paste0 "(" arg-text ")"))
                                 #nil)
                               (set! args (c args arg-text))
                               (set! j (+ j 1))))
                           (if (= (length args) 0)
                             op-name
                             (if (and (= (length args) 1)
                                      (__string-in? op-name (c "+" "-" "!")))
                               (paste0 op-name (__at args 1))
                               (paste args :collapse (paste0 " " op-name " "))))))

                        (else
                         (begin
                           (define fn-name (translate-expr op indent))
                           (define args (character 0))
                           (define j 2)
                           (while (<= j (length expr))
                             (begin
                               (define arg-expr (__at expr j))
                               (if (keyword? arg-expr)
                                 (begin
                                   (if (> (+ j 1) (length expr))
                                     (stop (format "Keyword :%s requires a value" arg-expr))
                                     #nil)
                                   (define keyword-name (as.character arg-expr))
                                   (define value (translate-expr (__at expr (+ j 1)) indent))
                                   (set! args (c args (paste0 (__r-name keyword-name) " = " value)))
                                   (set! j (+ j 2)))
                                 (begin
                                   (define value (translate-expr arg-expr indent))
                                   (set! args (c args value))
                                   (set! j (+ j 1))))))
                           (define args-str (paste args :collapse ", "))
                           (paste0 fn-name "(" args-str ")")))))
                    (as.character expr)))))))))
))

(define translate-str
  (lambda (source)
    "Translate Rye source string into R code."
    (define exprs (rye_read source))
    (define r-code-parts (character 0))
    (define i 1)
    (while (<= i (length exprs))
      (begin
        (set! r-code-parts (c r-code-parts (translate-expr (__at exprs i) 0)))
        (set! i (+ i 1))))
    (paste r-code-parts :collapse "\n\n")))

(define translate-file
  (lambda (path)
    "Translate Rye source file into R code."
    (define text (read-file path))
    (translate-str text)))

(define translate-source
  (lambda (source (is-file (list)))
    "Translate Rye source from a file path or string."
    (define missing?
      (or (is.null is-file)
          (and (list? is-file) (= (length is-file) 0))))
    (define file?
      (if missing?
        (and (string-match? source "\\.rye$")
             (isTRUE (r/call "file.exists" (list source))))
        is-file))
    (if file?
      (begin
        (if (not (isTRUE (r/call "file.exists" (list source))))
          (stop (format "cannot open file '%s'" source))
          #nil)
        (translate-file source))
      (translate-str source))))
)
