;;; Rye Standard Library - Sequence Helpers

(module sequences
  (export take drop take-while drop-while
          partition flatten repeatedly repeat zip
          member contains?
          length= length> length<)

  (import list)
  (import types)

  (define take
    (lambda (n lst)
      "Take first n items."
      (define items (__as-list lst))
      (if (<= n 0)
        (list)
        (r/call "[" (list items (seq_len (min n (length items))))))))

  (define drop
    (lambda (n lst)
      "Drop first n items."
      (define items (__as-list lst))
      (if (<= n 0)
        items
        (if (>= n (length items))
          (list)
          (r/call "[" (list items (seq (+ n 1) (length items))))))))

  (define take-while
    (lambda (pred lst)
      "Take items while predicate is true."
      (define items (__as-list lst))
      (define acc (list))
      (define remaining items)
      (while (and (> (length remaining) 0) (isTRUE (pred (car remaining))))
        (begin
          (set! acc (c acc (list (car remaining))))
          (set! remaining (cdr remaining))))
      acc))

  (define drop-while
    (lambda (pred lst)
      "Drop items while predicate is true."
      (define items (__as-list lst))
      (define remaining items)
      (while (and (> (length remaining) 0) (isTRUE (pred (car remaining))))
        (set! remaining (cdr remaining)))
      remaining))

  (define partition
    (lambda (n lst (step n))
      "Split list into chunks of size n."
      (define items (__as-list lst))
      (if (<= n 0)
        (stop "partition requires positive n and step")
        (if (<= step 0)
          (stop "partition requires positive n and step")
          (if (= (length items) 0)
            (list)
            (begin
              (define acc (list))
              (define idx 1)
              (define n-items (length items))
              (while (<= idx n-items)
                (define end (+ idx (- n 1)))
                (if (<= end n-items)
                  (set! acc (c acc (list (r/call "[" (list items (seq idx end)))))))
                (set! idx (+ idx step)))
              acc))))))

  (define flatten
    (lambda (lst)
      "Flatten nested lists."
      (define items (__as-list lst))
      (define acc (list))
      (define remaining items)
      (while (> (length remaining) 0)
        (define item (car remaining))
        (if (list? item)
          (set! acc (c acc (flatten item)))
          (set! acc (c acc (list item))))
        (set! remaining (cdr remaining)))
      acc))

  (define repeatedly
    (lambda (n fn)
      "Call fn n times collecting results."
      (lapply (seq_len n) (lambda (i) (fn)))))

  (define repeat
    (lambda (n value)
      "Repeat value n times."
      (replicate n value :simplify #f)))

  (define zip
    (lambda (. lists)
      "Zip lists into list of tuples."
      (if (= (length lists) 0)
        (list)
        (begin
          (define items (lapply lists __as-list))
          (define min-len (min (vapply items length (integer 1))))
          (if (= min-len 0)
            (list)
            (begin
              (define zip-at
                (lambda (i)
                  "Collect ith elements from lists."
                  (lapply items (lambda (lst) (r/call "[[" (list lst i))))))
              (lapply (seq_len min-len) zip-at)))))))

  (define member
    (lambda (x lst)
      "Return sublist of lst starting at first element equal to x, or #f if not found."
      (define items (__as-list lst))
      (define result #f)
      (define remaining items)
      (while (and (> (length remaining) 0) (not result))
        (begin
          (when (identical (car remaining) x)
            (set! result remaining))
          (set! remaining (cdr remaining))))
      result))

  (define contains?
    (lambda (x lst)
      "Return #t if lst contains element equal to x."
      (if (member x lst) #t #f)))

  ;; Length predicates
  (define length=
    (lambda (x n)
      "Return #t if length of x equals n."
      (isTRUE (== (length x) n))))

  (define length>
    (lambda (x n)
      "Return #t if length of x is greater than n."
      (isTRUE (> (length x) n))))

  (define length<
    (lambda (x n)
      "Return #t if length of x is less than n."
      (isTRUE (< (length x) n))))
)
