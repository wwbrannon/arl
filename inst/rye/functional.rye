;;; Rye Standard Library - Functional Helpers

(module functional
  (export map mapcat filter remove reduce foldl foldr every? any? complement compose partial
          curry juxt constantly iterate iterate-until memoize)

  (import list)
  (import logic)

  ;;' @section Core Higher-Order Functions
  ;;' The fundamental building blocks for functional programming in Rye.
  ;;' These functions operate on lists and follow the convention of taking
  ;;' the function argument first, then the data argument.

  ;;' @examples
  ;;' (map (lambda (x) (* x 2)) (list 1 2 3))  ; => (2 4 6)
  ;;' (map (lambda (x) (* x x)) (list 1 2 3 4)) ; => (1 4 9 16)
  ;;' (map string-length (list "hi" "hello"))     ; => (2 5)
  ;;' @seealso filter, mapcat, reduce
  (define map
    (lambda (fn lst)
      "Apply function to each element."
      (lapply (__as-list lst) fn)))

  ;;' @examples
  ;;' (mapcat (lambda (x) (list x (* x 10))) (list 1 2 3))  ; => (1 10 2 20 3 30)
  ;;' (mapcat (lambda (x) (list x x)) (list 1 2 3))          ; => (1 1 2 2 3 3)
  ;;' @seealso map, flatten
  (define mapcat
    (lambda (fn lst)
      "Map then concatenate results. Uses do.call(c, ...) for O(n) concatenation."
      (define results (map fn lst))
      (if (null? results)
        (list)
        (do.call c (lapply results (lambda (x) (__as-list x)))))))

  ;;' @examples
  ;;' (filter (lambda (x) (> x 2)) (list 1 2 3 4 5))  ; => (3 4 5)
  ;;' (filter even? (list 1 2 3 4 5 6))                 ; => (2 4 6)
  ;;' (filter string? (list 1 "a" 2 "b"))               ; => ("a" "b")
  ;;' @seealso remove, take-while, drop-while
  (define filter
    (lambda (pred lst)
      "Filter items by predicate."
      (Filter pred (__as-list lst))))

  ;;' @examples
  ;;' (remove even? (list 1 2 3 4 5 6))                 ; => (1 3 5)
  ;;' (remove (lambda (x) (> x 3)) (list 1 2 3 4 5))   ; => (1 2 3)
  ;;' @seealso filter
  (define remove
    (lambda (pred lst)
      "Remove items where predicate is true."
      (Filter (lambda (x) (not (isTRUE (pred x)))) (__as-list lst))))

  ;;' @examples
  ;;' (reduce + (list 1 2 3 4))       ; => 10
  ;;' (reduce * (list 1 2 3 4))       ; => 24
  ;;' (reduce + (list 1 2 3) 100)     ; => 106 (with initial value)
  ;;' (reduce string-append (list "a" "b" "c"))  ; => "abc"
  ;;' @seealso foldl, foldr, map
  (define reduce
    (lambda (fn lst . rest)
      "Reduce list with function."
      (if (= (length rest) 0)
        (Reduce fn (__as-list lst))
        (Reduce fn (__as-list lst) :init (car rest)))))

  ;;' @examples
  ;;' (foldl + (list 1 2 3 4))        ; => 10
  ;;' (foldl - (list 1 2 3) 10)       ; => 4 (10 - 1 - 2 - 3)
  ;;' (foldl cons (list 1 2 3) (list)) ; => (3 2 1) (reverses)
  ;;' @seealso foldr, reduce
  (define foldl
    (lambda (fn lst . rest)
      "Left fold alias for reduce."
      (if (= (length rest) 0)
        (Reduce fn (__as-list lst))
        (Reduce fn (__as-list lst) :init (car rest)))))

  ;;' @examples
  ;;' (foldr + (list 1 2 3 4))        ; => 10
  ;;' (foldr - (list 1 2 3) 10)       ; => -8 (1 - (2 - (3 - 10)))
  ;;' (foldr cons (list 1 2 3) (list)) ; => (1 2 3) (preserves order)
  ;;' @seealso foldl, reduce
  (define foldr
    (lambda (fn lst . rest)
      "Right fold."
      (if (= (length rest) 0)
        (Reduce fn (__as-list lst) :right #t)
        (Reduce fn (__as-list lst) :init (car rest) :right #t))))

  ;;' @examples
  ;;' (every? positive? (list 1 2 3))       ; => #t
  ;;' (every? even? (list 2 4 6))           ; => #t
  ;;' (every? even? (list 2 3 6))           ; => #f
  ;;' (every? string? (list "a" "b" "c"))   ; => #t
  ;;' @seealso any?, filter
  (define every?
    (lambda (pred lst)
      "Return #t if predicate true for all items."
      (all (vapply (__as-list lst) (lambda (x) (isTRUE (pred x))) (logical 1)))))

  ;;' @examples
  ;;' (any? even? (list 1 3 4 5))           ; => #t
  ;;' (any? negative? (list 1 2 3))         ; => #f
  ;;' (any? string? (list 1 "a" 2))         ; => #t
  ;;' @seealso every?, filter
  (define any?
    (lambda (pred lst)
      "Return #t if predicate true for any item."
      (any (vapply (__as-list lst) (lambda (x) (isTRUE (pred x))) (logical 1)))))

  ;;' @examples
  ;;' (define not-even? (complement even?))
  ;;' (not-even? 3)                          ; => #t
  ;;' (not-even? 4)                          ; => #f
  ;;' (filter (complement null?) (list 1 #nil 2 #nil 3))  ; => (1 2 3)
  ;;' @seealso not, filter
  (define complement
    (lambda (pred)
      "Negate predicate."
      (lambda (. args)
        (not (do.call pred args)))))

  ;;' @examples
  ;;' (define add1-then-double (compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))))
  ;;' (add1-then-double 3)                   ; => 8  ((3+1)*2)
  ;;' (define abs-sum (compose abs +))
  ;;' (abs-sum -3 -4)                        ; => 7
  ;;' @seealso partial
  (define compose
    (lambda (f g)
      "Compose two functions."
      (lambda (. args)
        (f (do.call g args)))))

  ;;' @examples
  ;;' (define add5 (partial + 5))
  ;;' (add5 3)                               ; => 8
  ;;' (define greet (partial string-append "Hello, "))
  ;;' (greet "world")                        ; => "Hello, world"
  ;;' @seealso compose
  (define partial
    (lambda (fn . captured)
      "Partially apply function."
      (lambda (. more)
        (do.call fn (append captured more)))))

  ;; ============================================================================
  ;; Advanced Functional Programming
  ;; ============================================================================

  ;;' @section Advanced Functional Programming
  ;;' Higher-order combinators for advanced functional patterns including
  ;;' currying, juxtaposition, memoization, and iteration.

  ;;' @examples
  ;;' (define add (curry (lambda (a b) (+ a b))))
  ;;' (define add5 (add 5))
  ;;' (add5 3)                               ; => 8
  ;;' (define multiply (curry (lambda (a b) (* a b))))
  ;;' ((multiply 3) 4)                       ; => 12
  ;;' @seealso partial
  (define curry
    (lambda (fn . initial-args)
      "Curry a function - enables partial application with optional initial arguments."
      (define arity (length (formals fn)))
      (define curry-helper
        (lambda (collected-args)
          (lambda (. new-args)
            (define all-args (append collected-args new-args))
            (if (>= (length all-args) arity)
              (do.call fn all-args)
              (curry-helper all-args)))))
      (curry-helper initial-args)))

  ;;' @examples
  ;;' (define stats (juxt min max mean))
  ;;' (stats (c 1 2 3 4 5))                  ; => (1 5 3)
  ;;' (define first-and-last (juxt car last))
  ;;' (first-and-last (list 1 2 3))          ; => (1 3)
  ;;' @seealso map, compose
  (define juxt
    (lambda (. fns)
      "Juxtaposition - apply multiple functions to same args, return list of results."
      (lambda (. args)
        (map (lambda (f) (do.call f args)) fns))))

  ;;' @examples
  ;;' (define always-42 (constantly 42))
  ;;' (always-42)                             ; => 42
  ;;' (always-42 "ignored" "args")            ; => 42
  ;;' (map (constantly 0) (list 1 2 3))       ; => (0 0 0)
  (define constantly
    (lambda (value)
      "Return a function that always returns the given value."
      (lambda (. args)
        value)))

  ;;' @examples
  ;;' (iterate (lambda (x) (* x 2)) 5 1)     ; => 32  (1 -> 2 -> 4 -> 8 -> 16 -> 32)
  ;;' (iterate inc 3 0)                       ; => 3   (0 -> 1 -> 2 -> 3)
  ;;' (iterate (lambda (x) (* x x)) 2 2)     ; => 65536  (2 -> 4 -> 16 -> 65536... wait: 2^2=4, 4^2=16)
  ;;' @seealso iterate-until, reduce
  (define iterate
    (lambda (fn n init)
      "Apply function n times to initial value."
      (if (<= n 0)
        init
        (iterate fn (- n 1) (fn init)))))

  ;;' @examples
  ;;' (iterate-until (lambda (x) (* x 2)) 1 (lambda (x) (> x 100)))
  ;;'   ; => (1 2 4 8 16 32 64)  (stops before 128 which exceeds 100)
  ;;' (iterate-until inc 0 (lambda (x) (>= x 5)))
  ;;'   ; => (0 1 2 3 4)
  ;;' @seealso iterate, take-while
  (define iterate-until
    (lambda (fn init pred)
      "Apply function starting from init, collecting values until predicate becomes true. Includes all values where predicate is false, stops when next value would satisfy predicate."
      (define current init)
      (define acc (list))
      (define done #f)
      (while (not done)
        (begin
          (set! acc (c acc current))
          (define next (fn current))
          (if (pred next)
            (set! done #t)
            (set! current next))))
      acc))

  ;;' @examples
  ;;' (define slow-fib (lambda (n) (if (< n 2) n (+ (slow-fib (- n 1)) (slow-fib (- n 2))))))
  ;;' (define fast-fib (memoize slow-fib))
  ;;' (fast-fib 10)                          ; => 55
  ;;' (fast-fib 10)                          ; => 55 (cached, instant)
  (define memoize
    (lambda (fn)
      "Memoize function - cache results for previously seen arguments."
      (define cache (r/call "new.env" (list)))
      (lambda (. args)
        (define key (r/call "paste" (list args :collapse "|")))
        (if (r/call "exists" (list key :envir cache))
          (r/call "get" (list key :envir cache))
          (begin
            (define result (do.call fn args))
            (r/call "assign" (list key result :envir cache))
            result)))))

)
