;;; Rye Standard Library - Functional Helpers

(module functional
  (export map mapcat filter remove reduce foldl foldr every? any? complement compose partial
          curry juxt constantly iterate iterate-until memoize repeatedly)

  (import list)
  (import predicates)

  (define map
    (lambda (fn lst)
      "Apply function to each element."
      (lapply (__as-list lst) fn)))

  (define mapcat
    (lambda (fn lst)
      "Map then concatenate results. Uses do.call(c, ...) for O(n) concatenation."
      (define results (map fn lst))
      (if (null? results)
        (list)
        (do.call c (lapply results (lambda (x) (__as-list x)))))))

  (define filter
    (lambda (pred lst)
      "Filter items by predicate."
      (Filter pred (__as-list lst))))

  (define remove
    (lambda (pred lst)
      "Remove items where predicate is true."
      (Filter (lambda (x) (not (isTRUE (pred x)))) (__as-list lst))))

  (define reduce
    (lambda (fn lst . rest)
      "Reduce list with function."
      (if (= (length rest) 0)
        (Reduce fn (__as-list lst))
        (Reduce fn (__as-list lst) :init (car rest)))))

  (define foldl
    (lambda (fn lst . rest)
      "Left fold alias for reduce."
      (if (= (length rest) 0)
        (Reduce fn (__as-list lst))
        (Reduce fn (__as-list lst) :init (car rest)))))

  (define foldr
    (lambda (fn lst . rest)
      "Right fold."
      (if (= (length rest) 0)
        (Reduce fn (__as-list lst) :right #t)
        (Reduce fn (__as-list lst) :init (car rest) :right #t))))

  (define every?
    (lambda (pred lst)
      "Return #t if predicate true for all items."
      (all (vapply (__as-list lst) (lambda (x) (isTRUE (pred x))) (logical 1)))))

  (define any?
    (lambda (pred lst)
      "Return #t if predicate true for any item."
      (any (vapply (__as-list lst) (lambda (x) (isTRUE (pred x))) (logical 1)))))

  (define complement
    (lambda (pred)
      "Negate predicate."
      (lambda (. args)
        (not (do.call pred args)))))

  (define compose
    (lambda (f g)
      "Compose two functions."
      (lambda (. args)
        (f (do.call g args)))))

  (define partial
    (lambda (fn . captured)
      "Partially apply function."
      (lambda (. more)
        (do.call fn (append captured more)))))

  ;; ============================================================================
  ;; Advanced Functional Programming
  ;; ============================================================================

  (define curry
    (lambda (fn . initial-args)
      "Curry a function - enables partial application with optional initial arguments."
      (define arity (length (formals fn)))
      (define curry-helper
        (lambda (collected-args)
          (lambda (. new-args)
            (define all-args (append collected-args new-args))
            (if (>= (length all-args) arity)
              (do.call fn all-args)
              (curry-helper all-args)))))
      (curry-helper initial-args)))

  (define juxt
    (lambda (. fns)
      "Juxtaposition - apply multiple functions to same args, return list of results."
      (lambda (. args)
        (map (lambda (f) (do.call f args)) fns))))

  (define constantly
    (lambda (value)
      "Return a function that always returns the given value."
      (lambda (. args)
        value)))

  (define iterate
    (lambda (fn n init)
      "Apply function n times to initial value."
      (if (<= n 0)
        init
        (iterate fn (- n 1) (fn init)))))

  (define iterate-until
    (lambda (fn init pred)
      "Apply function starting from init, collecting values until predicate becomes true.
       Includes all values where predicate is false, stops when next value would satisfy predicate."
      (define current init)
      (define acc (list))
      (define done #f)
      (while (not done)
        (begin
          (set! acc (c acc current))
          (define next (fn current))
          (if (pred next)
            (set! done #t)
            (set! current next))))
      acc))

  (define memoize
    (lambda (fn)
      "Memoize function - cache results for previously seen arguments."
      (define cache (r/call "new.env" (list)))
      (lambda (. args)
        (define key (r/call "paste" (list args :collapse "|")))
        (if (r/call "exists" (list key :envir cache))
          (r/call "get" (list key :envir cache))
          (begin
            (define result (do.call fn args))
            (r/call "assign" (list key result :envir cache))
            result)))))

  (define repeatedly
    (lambda (fn n)
      "Call function n times, return list of results."
      (define acc (list))
      (define count n)
      (while (> count 0)
        (begin
          (set! acc (append acc (list (fn))))
          (set! count (- count 1))))
      acc)))
