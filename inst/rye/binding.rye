;;; Rye Standard Library - Binding Macros

(module binding
  (export pattern-symbols destructuring-bind let let* letrec)

  (import predicates)
  (import list-core)
  (import higher-order)
  (import sequences)

(define pattern-symbols
  (lambda (pattern)
    "Collect symbols from a destructuring pattern."
    (if (symbol? pattern)
      (if (= (as.character pattern) ".")
        (list)
        (list pattern))
      (if (pair? pattern)
        (begin
          (define head (car pattern))
          (define tail (cdr pattern))
          (if (and (symbol? head) (= (as.character head) "."))
            (if (null? tail) (list) (pattern-symbols (car tail)))
            (append (pattern-symbols head) (pattern-symbols tail))))
        (list)))))

(defmacro destructuring-bind (pattern value . body)
  "Bind pattern to value, then evaluate body."
  (define tmp (gensym "tmp"))
  `((lambda (,tmp)
      (define ,pattern ,tmp)
      (begin ,@body))
    ,value))

(defmacro let (bindings . body)
  "Bind names to values within body."
  (if (null? bindings)
    `(begin ,@body)
    (begin
      (define temps (map (lambda (b) (gensym "tmp")) bindings))
      (define patterns (map car bindings))
      (define values (map (lambda (b) (car (cdr b))) bindings))
      `((lambda ,temps
          ,@(map (lambda (pair)
                   `(define ,(car pair) ,(car (cdr pair))))
                 (zip patterns temps))
          (begin ,@body))
        ,@values))))

(defmacro let* (bindings . body)
  "Sequential let bindings."
  (if (null? bindings)
    `(begin ,@body)
    (begin
      (define binding (car bindings))
      (define pattern (car binding))
      (define value (car (cdr binding)))
      `(destructuring-bind ,pattern ,value
         (let* ,(cdr bindings) ,@body)))))

(defmacro letrec (bindings . body)
  "Recursive bindings."
  (define names (mapcat (lambda (b) (pattern-symbols (car b))) bindings))
  `(let ,(map (lambda (n) `(,n (list))) names)
     ,@(map (lambda (b) `(set! ,(car b) ,(car (cdr b)))) bindings)
     (begin ,@body)))
)
