;;; Rye Standard Library - IO Helpers

(module io
  (export __normalize-line-vector __normalize-lines
          read-line read-file read-lines
          write-file write-lines append-file file-exists?
          read print newline
          read-from-string write-string
          file-size file-modified-time file-delete
          directory-exists? directory-list directory-delete
          getenv setenv
          system system-output exit)

  (define __normalize-line-vector
    (lambda (lines)
      "Normalize content to character vector."
      (if (is.null lines)
        (character 0)
        (if (is.call lines)
          (vapply (as.list lines) as.character (character 1))
          (if (is.list lines)
            (vapply lines as.character (character 1))
            (as.character lines))))))

  (define __normalize-lines
    (lambda (content (sep "\n"))
      "Collapse content to string."
      (define lines (__normalize-line-vector content))
      (if (<= (length lines) 1)
        (as.character lines)
        (paste lines :collapse sep))))

  (define read-line
    (lambda ((prompt ""))
      "Read single line from stdin."
      (define con (getOption "rye.stdin"))
      (if (is.null con) (define con (stdin)) #nil)
      (if (nzchar prompt) (cat prompt) #nil)
      (r/call "readLines" (list :con con :n 1 :warn #f))))

  (define read-file
    (lambda (path (encoding "UTF-8"))
      "Read entire file as string."
      (define con (file path :open "r" :encoding encoding))
      (define lines (readLines :con con :warn #f))
      (close con)
      (paste lines :collapse "\n")))

  (define read-lines
    (lambda (path (encoding "UTF-8"))
      "Read file into list of lines."
      (define con (file path :open "r" :encoding encoding))
      (define lines (readLines :con con :warn #f))
      (close con)
      (as.list lines)))

  (define write-file
    (lambda (path content (sep "\n") (encoding "UTF-8"))
      "Write string or lines to file."
      (define text (__normalize-lines content sep))
      (define con (file path :open "w" :encoding encoding))
      (writeLines text :con con :useBytes #f)
      (close con)
      #t))

  (define write-lines
    (lambda (path lines (encoding "UTF-8"))
      "Write list of lines to file."
      (define out (__normalize-line-vector lines))
      (define con (file path :open "w" :encoding encoding))
      (writeLines out :con con :useBytes #f)
      (close con)
      #t))

  (define append-file
    (lambda (path content (sep "\n") (encoding "UTF-8"))
      "Append content to file."
      (define text (__normalize-lines content sep))
      (define con (file path :open "a" :encoding encoding))
      (writeLines text :con con :useBytes #f :sep "")
      (close con)
      #t))

  (define file-exists?
    (lambda (path)
      "Return #t if file exists."
      (isTRUE (file.exists path))))

  ;; ==========================================================================
  ;; Phase 5: I/O and System Operations
  ;; ==========================================================================

  ;; Get R base functions to avoid infinite recursion
  (define __rprint (get "print" :envir (baseenv)))
  (define __rsystem (get "system" :envir (baseenv)))

  ;; Parsing operations
  (define read
    (lambda (source)
      "Parse Rye expression from string."
      (define exprs (rye_read source))
      (if (> (length exprs) 0)
        (r/call "[[" (list exprs 1))
        #nil)))

  (define read-from-string read)  ;; Alias for read

  ;; Output operations
  (define print
    (lambda (x)
      "Print value in Rye representation."
      (__rprint x)
      x))

  (define write-string
    (lambda (x)
      "Write string to output (alias for cat)."
      (cat x)
      #nil))

  (define newline
    (lambda ()
      "Output a newline."
      (cat "\n")
      #nil))

  ;; File operations
  (define file-size
    (lambda (path)
      "Return size of file in bytes."
      (if (file.exists path)
        (r/call "[[" (list (r/call "file.info" (list path)) "size"))
        (stop (sprintf "file-size: file does not exist: %s" path)))))

  (define file-modified-time
    (lambda (path)
      "Return file modification time as numeric timestamp."
      (if (file.exists path)
        (begin
          (define mtime (r/call "[[" (list (r/call "file.info" (list path)) "mtime")))
          (as.numeric mtime))
        (stop (sprintf "file-modified-time: file does not exist: %s" path)))))

  (define file-delete
    (lambda (path)
      "Delete file. Return #t on success."
      (if (file.exists path)
        (begin
          (file.remove path)
          #t)
        (stop (sprintf "file-delete: file does not exist: %s" path)))))

  ;; Directory operations
  (define directory-exists?
    (lambda (path)
      "Return #t if directory exists."
      (isTRUE (dir.exists path))))

  (define directory-list
    (lambda (path (full.names #f))
      "List directory contents as list of filenames."
      (if (dir.exists path)
        (as.list (list.files path :full.names full.names))
        (stop (sprintf "directory-list: directory does not exist: %s" path)))))

  (define directory-delete
    (lambda (path (recursive #t))
      "Delete directory. Return #t on success."
      (if (dir.exists path)
        (begin
          (unlink path :recursive recursive)
          #t)
        (stop (sprintf "directory-delete: directory does not exist: %s" path)))))

  ;; Environment variables
  (define getenv
    (lambda (name)
      "Get environment variable value. Return #nil if not set."
      (define value (Sys.getenv name))
      (if (== value "")
        #nil
        value)))

  (define setenv
    (lambda (name value)
      "Set environment variable."
      ;; Create a named list and use do.call
      ;; First create a list with the value
      (define args-list (r/call "list" (list value)))
      ;; Set the name on the first element
      (define named-list (r/call "names<-" (list args-list (r/call "c" (list name)))))
      ;; Call Sys.setenv with the named list - pass as string "Sys.setenv"
      (r/call "do.call" (list "Sys.setenv" named-list))
      #t))

  ;; System operations
  (define system
    (lambda (command)
      "Execute shell command. Return exit status."
      (__rsystem command)))

  (define system-output
    (lambda (command)
      "Execute shell command and capture output as string."
      (paste (__rsystem command #t) :collapse "\n")))

  (define exit
    (lambda ((status 0))
      "Exit program with status code."
      (q :save "no" :status status))))
