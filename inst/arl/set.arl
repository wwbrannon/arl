;;; Arl Standard Library - Set (Hash Table)

(module set
  (export set set? set-add set-remove set-contains? set-union set-intersection
          set-difference)

  (import core :only (r/call error))

;;' @section Set (Hash-Backed)
;;' Sets are mutable collections of unique items backed by R environments.
;;' Any value can be a set element; uniqueness is determined by serialization.

;;; Internal helpers (defined early for use in constructors)

;;' @description Create a new empty set environment.
(define set-new
  (lambda ()
    (define set-obj (r/call "new.env" (list :hash #t :parent (r/call "emptyenv" (list)))))
    (r/call "class<-" (list set-obj (c (list "arl_set") (r/call "class" (list set-obj)))))
    set-obj))

;;' @description Convert value to string key for set storage via serialization.
(define set-key
  (lambda (value)
    (define raw (r/call "serialize" (list value #nil :ascii #t)))
    (r/call "paste" (list (r/call "as.integer" (list raw)) :collapse ","))))

;;; Set constructor

;;' @description Create a hash-backed set of unique items.
;;' @examples
;;' (set 1 2 3)                ; => set of {1, 2, 3}
;;' (set 1 1 2)                ; => set of {1, 2} (duplicates removed)
;;' (set)                      ; => empty set
;;' (set '(a b c))             ; => set from list
;;' @assert
;;' (assert-true (set? (set 1 2 3)))
;;' (assert-true (set-contains? (set 1 2 3) 2))
;;' (assert-false (set-contains? (set 1 2 3) 99))
;;' (assert-true (set? (set)))
(define set
  (lambda (. args)
    (define set-obj (set-new))
    (define items
      (if (and (= (length args) 1) (or (is.list (car args)) (is.call (car args))))
        (as.list (car args))
        (as.list args)))
    (define add-item
      (lambda (item)
        (begin
          (define key (set-key item))
          (if (not (r/call "exists" (list key :envir set-obj :inherits #f)))
            (r/call "assign" (list key item :envir set-obj))))))
    (r/call "lapply" (list items add-item))
    set-obj))

;;; Type predicate

;;' @description Return #t if x is a set.
;;' @examples
;;' (set? (set 1 2))           ; => #t
;;' (set? (list 1 2))          ; => #f
;;' (set? 42)                  ; => #f
;;' @assert
;;' (assert-true (set? (set 1 2)))
;;' (assert-false (set? (list 1 2)))
;;' (assert-false (set? 42))
(define set?
  (lambda (x)
    (and (r/call "is.environment" (list x)) (r/call "inherits" (list x "arl_set")))))

;;; Set operations

;;' @description Add item to set and return set.
;;' @examples
;;' (define s (set 1 2))
;;' (set-add s 3)              ; => s (mutated, now {1, 2, 3})
;;' (set-contains? s 3)        ; => #t
;;' @assert
;;' (define __test-sa (set 1 2))
;;' (set-add __test-sa 3)
;;' (assert-true (set-contains? __test-sa 3))
;;' @seealso set-remove
(define set-add
  (lambda (set item)
    (if (not (set? set))
      (error "set-add requires a set")
      (begin
        (define key (set-key item))
        (if (not (r/call "exists" (list key :envir set :inherits #f)))
          (r/call "assign" (list key item :envir set)))
        set))))

;;' @description Remove item from set and return set.
;;' @examples
;;' (define s (set 1 2 3))
;;' (set-remove s 2)           ; => s (mutated, now {1, 3})
;;' (set-contains? s 2)        ; => #f
;;' @assert
;;' (define __test-sr (set 1 2 3))
;;' (set-remove __test-sr 2)
;;' (assert-false (set-contains? __test-sr 2))
;;' @seealso set-add
(define set-remove
  (lambda (set item)
    (if (not (set? set))
      set
      (begin
        (define key (set-key item))
        (if (r/call "exists" (list key :envir set :inherits #f))
          (r/call "rm" (list :list (c key) :envir set :inherits #f)))
        set))))

;;' @description Return #t if set contains item.
;;' @examples
;;' (define s (set 1 2 3))
;;' (set-contains? s 2)        ; => #t
;;' (set-contains? s 99)       ; => #f
;;' @assert
;;' (assert-true (set-contains? (set 1 2 3) 2))
;;' (assert-false (set-contains? (set 1 2 3) 99))
(define set-contains?
  (lambda (set item)
    (if (not (set? set))
      #f
      (begin
        (define key (set-key item))
        (r/call "exists" (list key :envir set :inherits #f))))))

;;' @description Return union of two sets.
;;' @examples
;;' (define a (set 1 2 3))
;;' (define b (set 3 4 5))
;;' (define u (set-union a b))
;;' (set-contains? u 1)        ; => #t
;;' (set-contains? u 5)        ; => #t
;;' @assert
;;' (define __test-su (set-union (set 1 2 3) (set 3 4 5)))
;;' (assert-true (set-contains? __test-su 1))
;;' (assert-true (set-contains? __test-su 5))
;;' @seealso set-intersection, set-difference
(define set-union
  (lambda (a b)
    (define result (set-new))
    (set-copy-into result a)
    (set-copy-into result b)
    result))

;;' @description Return intersection of two sets.
;;' @examples
;;' (define a (set 1 2 3))
;;' (define b (set 2 3 4))
;;' (define i (set-intersection a b))
;;' (set-contains? i 2)        ; => #t
;;' (set-contains? i 1)        ; => #f
;;' @assert
;;' (define __test-si (set-intersection (set 1 2 3) (set 2 3 4)))
;;' (assert-true (set-contains? __test-si 2))
;;' (assert-false (set-contains? __test-si 1))
;;' @seealso set-union, set-difference
(define set-intersection
  (lambda (a b)
    (define result (set-new))
    (if (and (set? a) (set? b))
      (begin
        (define keys (r/call "ls" (list :envir a :all.names #t :sorted #f)))
        (define add-if-in-b
          (lambda (key)
            (if (r/call "exists" (list key :envir b :inherits #f))
              (begin
                (define value (r/call "get" (list key :envir a :inherits #f)))
                (r/call "assign" (list key value :envir result))))))
        (r/call "lapply" (list (as.list keys) add-if-in-b))
        result))
    result))

;;' @description Return items in a that are not in b.
;;' @examples
;;' (define a (set 1 2 3))
;;' (define b (set 2 3 4))
;;' (define d (set-difference a b))
;;' (set-contains? d 1)        ; => #t
;;' (set-contains? d 2)        ; => #f
;;' @assert
;;' (define __test-sd (set-difference (set 1 2 3) (set 2 3 4)))
;;' (assert-true (set-contains? __test-sd 1))
;;' (assert-false (set-contains? __test-sd 2))
;;' @seealso set-union, set-intersection
(define set-difference
  (lambda (a b)
    (define result (set-new))
    (if (set? a)
      (begin
        (define keys (r/call "ls" (list :envir a :all.names #t :sorted #f)))
        (define add-if-not-in-b
          (lambda (key)
            (if (or (not (set? b)) (not (r/call "exists" (list key :envir b :inherits #f))))
              (begin
                (define value (r/call "get" (list key :envir a :inherits #f)))
                (r/call "assign" (list key value :envir result))))))
        (r/call "lapply" (list (as.list keys) add-if-not-in-b))
        result))
    result))

;;; Internal helper

;;' @description Copy items from source into target (internal helper).
(define set-copy-into
  (lambda (target source)
    (if (and (set? target) (set? source))
      (begin
        (define keys (r/call "ls" (list :envir source :all.names #t :sorted #f)))
        (define copy-key
          (lambda (key)
            (if (not (r/call "exists" (list key :envir target :inherits #f)))
              (begin
                (define value (r/call "get" (list key :envir source :inherits #f)))
                (r/call "assign" (list key value :envir target))))))
        (r/call "lapply" (list (as.list keys) copy-key)))
    target)))
)
