;;; Arl Standard Library - Control Flow Macros

(module control
  (export when unless cond case try*
          call/cc call-with-current-continuation)
  ;; Note: 'and' and 'or' removed from exports - now compiler special forms

  (import types)
  (import list)
  (import functional) ; map

;;' @section Control Flow Macros

;;' @description Evaluate body forms when test is truthy.
;;' @examples
;;' (when #t "yes")          ; => "yes"
;;' (when #f "yes")          ; => #nil
;;' (when (> 3 2) (+ 1 1))   ; => 2
;;' @assert
;;' (assert-equal "yes" (when #t "yes"))
;;' (assert-equal #nil (when #f "yes"))
;;' (assert-equal 2 (when (> 3 2) (+ 1 1)))
;;' @seealso unless, if, cond
(defmacro when (test . body)
  `(if ,test (begin ,@body) #nil))

;;' @description Evaluate body forms when test is falsy.
;;' @examples
;;' (unless #f "fallback")    ; => "fallback"
;;' (unless #t "fallback")    ; => #nil
;;' (unless (= 1 2) "nope")  ; => "nope"
;;' @assert
;;' (assert-equal "fallback" (unless #f "fallback"))
;;' (assert-equal #nil (unless #t "fallback"))
;;' (assert-equal "nope" (unless (= 1 2) "nope"))
;;' @seealso when, if
(defmacro unless (test . body)
  `(if ,test #nil (begin ,@body)))

;;' @section Conditional Macros

;;' @description Multi-branch conditional.
;;' @examples
;;' (cond
;;'   ((= 1 2) "a")
;;'   ((= 1 1) "b")
;;'   (else "c"))            ; => "b"
;;'
;;' (cond
;;'   ((> 10 20) "big")
;;'   (else "small"))        ; => "small"
;;' @assert
;;' (assert-equal "b" (cond ((= 1 2) "a") ((= 1 1) "b") (else "c")))
;;' (assert-equal "small" (cond ((> 10 20) "big") (else "small")))
;;' @seealso case, if, when
(defmacro cond (clause . rest)
  (if (null? clause)
    (error "cond: Missing required parameter (else clause)")
    (begin
      (define test (car clause))
      (define body (cdr clause))
      (if (and (symbol? test) (= (as.character test) "else"))
        `(begin ,@body)
        (if (null? rest)
          `(if ,test (begin ,@body) #nil)
          `(if ,test (begin ,@body) (cond ,@rest)))))))

;; Helper: generate case clause expansion using already-bound key symbol.
(define __case-clauses
  (lambda (key-sym clause rest)
    (if (null? clause)
      (error "case: Missing required parameter (else clause)")
      (begin
        (define datums (car clause))
        (define body (cdr clause))
        (if (and (symbol? datums) (= (as.character datums) "else"))
          `(begin ,@body)
          (begin
            ;; datums is a list of values to match against
            (define test-expr
              (if (= (length datums) 1)
                `(= ,key-sym (quote ,(car datums)))
                `(or ,@(map (lambda (d) `(= ,key-sym (quote ,d))) datums))))
            (if (null? rest)
              `(if ,test-expr (begin ,@body) #nil)
              `(if ,test-expr (begin ,@body)
                   ,(__case-clauses key-sym (car rest) (cdr rest))))))))))

;;' @description Branch on key equality. Each clause:
;;' ((datum ...) body ...) or (else body ...).
;;' Key expression is evaluated only once.
;;' @examples
;;' (case (+ 1 1)
;;'   ((1) "one")
;;'   ((2) "two")
;;'   ((3) "three")
;;'   (else "other"))        ; => "two"
;;'
;;' (case 'x
;;'   ((a b) "ab")
;;'   ((x y) "xy")
;;'   (else "?"))            ; => "xy"
;;' @assert
;;' (assert-equal "two" (case (+ 1 1) ((1) "one") ((2) "two") ((3) "three") (else "other")))
;;' (assert-equal "xy" (case 'x ((a b) "ab") ((x y) "xy") (else "?")))
;;' @note The key expression is evaluated only once. Each clause datum list can contain multiple values.
;;' @seealso cond, if
(defmacro case (key clause . rest)
  (define key-sym (gensym "case-key"))
  `((lambda (,key-sym) ,(__case-clauses key-sym clause rest)) ,key))

;;' @section Error Handling Helper

;;' @description Evaluate thunk with error/finally handlers.
;;' @signature (try* thunk [error_handler] [finally_handler])
;;' @examples
;;' (try* (lambda () 42))                           ; => 42
;;' (try* (lambda () (stop "oops"))
;;'       :error_handler (lambda (e) "caught"))      ; => "caught"
;;' (try* (lambda () 1)
;;'       :finally_handler (lambda () (display "done")))  ; => 1
;;' @assert
;;' (assert-equal 42 (try* (lambda () 42)))
;;' (assert-equal "caught" (try* (lambda () (stop "oops")) :error_handler (lambda (e) "caught")))
;;' @note Low-level functional interface to R's tryCatch. Prefer the `try` macro for cleaner syntax.
;;' @seealso try (in `error` module), catch, finally
(define try*
  (lambda (thunk (error_handler #f) (finally_handler #f))
    (if (not (is.function thunk))
      (stop "try* expects a function as first argument"))
    (if (and error_handler (not (is.function error_handler)))
      (stop "try* error handler must be a function"))
    (if (and finally_handler (not (is.function finally_handler)))
      (stop "try* finally handler must be a function"))
    (define thunk-expr (call (list thunk)))
    (if (not error_handler)
      (if (not finally_handler)
        (thunk)
        (r/eval (call (list 'tryCatch thunk-expr
                            :finally (call (list finally_handler))))
                (current-env)))
      (if (not finally_handler)
        (r/eval (call (list 'tryCatch thunk-expr
                            :error error_handler))
                (current-env))
        (r/eval (call (list 'tryCatch thunk-expr
                            :error error_handler
                            :finally (call (list finally_handler))))
                (current-env))))))

;;' @section Continuations

  ;;' @signature (call/cc receiver)
  ;;' @note Alias for R's `callCC`. The receiver is passed the current continuation.
  ;;' @seealso call-with-current-continuation
  (define call/cc callCC)

  ;;' @signature (call-with-current-continuation receiver)
  ;;' @note Full name alias for `call/cc`.
  ;;' @seealso call/cc
  (define call-with-current-continuation callCC)
)
