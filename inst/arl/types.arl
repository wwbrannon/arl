;;; Arl Standard Library - Type Predicates

(module types
  (export list? list-or-pair? null? nil?
          symbol? keyword? number? string? vector?
          true? false? boolean? fn? callable? procedure?
          environment? is-refclass?
          atom? empty?
          type-of)

  (import _r)

  ;;' @section List and Pair Predicates

  ;;' @description Return #t if x is a proper list (R list or call), not a dotted pair.
  ;;' @examples
  ;;' (list? (list 1 2 3))  ; => #t
  ;;' (list? ())  ; => #t
  ;;' (list? "hello")  ; => #f
  ;;' @seealso pair?, list-or-pair?, null?
  (define list?
    (lambda (x)
      (if (pair? x) #f
        (if (is.list x) #t (if (is.call x) #t #f)))))

  ;;' @description Return #t if x is a non-empty list or dotted pair (pairlist cell).
  ;;' @examples
  ;;' (list-or-pair? (list 1))  ; => #t
  ;;' @seealso list?, pair?, null?, atom?
  (define list-or-pair?
    (lambda (x)
      (if (pair? x) #t
        (if (list? x) (if (__r> (__rlength x) 0) #t #f) #f))))

  ;;' @description Return #t for empty list or #nil.
  ;;' @examples
  ;;' (null? #nil)  ; => #t
  ;;' (null? ())  ; => #t
  ;;' (null? (list 1))  ; => #f
  ;;' @seealso nil?, pair?, list-or-pair?
  (define null?
    (lambda (x)
      (if (is.null x)
        #t
        (if (is.list x)
          (if (__r== (__rlength x) 0) #t #f)
          (if (is.call x)
            (if (__r== (__rlength x) 0) #t #f)
            #f)))))

  ;;' @description Alias for null?.
  ;;' @seealso null?
  (define nil?
    (lambda (x)
      (null? x)))

  ;;' @description Return #t if x is not a non-empty list or
  ;;' dotted pair (i.e. not list-or-pair?).
  ;;' @examples
  ;;' (atom? 42)  ; => #t
  ;;' (atom? "hello")  ; => #t
  ;;' (atom? (list 1 2))  ; => #f
  ;;' (atom? ())  ; => #t  (empty list is atomic)
  ;;' @seealso list-or-pair?
  (define atom?
    (lambda (x)
      (not (list-or-pair? x))))

  ;;' @description Return #t if x is empty (0-length).
  ;;' (Note the empty string "" has length 1 and is not "empty"!)
  ;;' @examples
  ;;' (empty? ())  ; => #t
  ;;' (empty? (list))  ; => #t
  ;;' (empty? (list 1))  ; => #f
  ;;' @note The empty string `""` has length 1 in R and is NOT considered empty!
  ;;' @seealso null?, length= (in `sequences` module)
  (define empty?
    (lambda (x)
      (isTRUE (== (length x) 0))))

  ;;' @section Symbol Predicates

  ;;' @description Return #t if x is a symbol.
  ;;' @signature (symbol? x)
  ;;' @examples
  ;;' (symbol? 'foo)  ; => #t
  ;;' (symbol? "foo")  ; => #f
  ;;' (symbol? 42)  ; => #f
  (define symbol? is.symbol)

  ;;' @description Return #t if x is an Arl keyword.
  ;;' @examples
  ;;' (keyword? ':foo)  ; => #t
  ;;' (keyword? 'foo)   ; => #f
  (define keyword?
    (lambda (x)
      (isTRUE (inherits x "arl_keyword"))))

  ;;' @section Basic Type Predicates

  ;;' @description Return #t if x is a number (real or complex).
  ;;' @examples
  ;;' (number? 42)  ; => #t
  ;;' @note For numeric type hierarchy predicates (real?, complex?, etc.), see the `math` module documentation.
  ;;' @seealso stdlib-math vignette for real?, complex?, rational?, exact?, inexact?
  (define number?
    (lambda (x)
      (if (is.numeric x)
        #t
        (if (is.complex x) #t #f))))

  ;;' @description Return #t if x is character.
  ;;' @signature (string? x)
  ;;' @examples
  ;;' (string? "hello")  ; => #t
  (define string? is.character)

  ;;' @description Return #t if x is a non-list atomic vector.
  ;;' @examples
  ;;' (vector? (c 1 2 3))  ; => #t
  ;;' @note Tests whether x is a non-list atomic vector (numeric, character, logical, etc.). R lists are NOT vectors by this predicate.
  (define vector?
    (lambda (x)
      (if (is.atomic x)
        (if (is.list x) #f #t)
        #f)))

  ;;' @description Return #t if x is a single logical value.
  ;;' @examples
  ;;' (boolean? #t)  ; => #t
  ;;' (boolean? #f)  ; => #t
  ;;' (boolean? TRUE)  ; => #t
  ;;' (boolean? (c TRUE FALSE))  ; => #f
  (define boolean?
    (lambda (x)
      (if (is.logical x)
        (isTRUE (== (length x) 1))
        #f)))

  ;;' @description Return #t if x is TRUE.
  ;;' @examples
  ;;' (true? #t)  ; => #t
  (define true?
    (lambda (x)
      (isTRUE x)))

  ;;' @description Return #t if x is #f.
  ;;' @examples
  ;;' (false? #f)  ; => #t
  (define false?
    (lambda (x)
      (identical x #f)))

  ;;' @section Function Predicates

  ;;' @description Return #t if x is a function.
  ;;' @signature (fn? x)
  ;;' @examples
  ;;' (fn? car)  ; => #t
  ;;' @seealso callable?, procedure?
  (define fn? is.function)

  ;;' @description Alias for fn?.
  ;;' @signature (callable? x)
  ;;' @seealso fn?
  (define callable? fn?)

  ;;' @description Alias for fn? - return #t if x is a function.
  ;;' @seealso fn?, callable?
  (define procedure?
    (lambda (x)
      (fn? x)))

  ;;' @section Environment Predicates

  ;;' @description Test if x is an environment (including R6 objects).
  ;;' @examples
  ;;' (environment? (baseenv))  ; => #t
  ;;' @note R6 objects, dicts, and sets are all environments in R, so this predicate returns #t for them.
  (define environment?
    (lambda (x)
      (r/call "is.environment" (list x))))

  ;;' @description Test if x is a Reference Class object.
  ;;' @examples
  ;;' (is-refclass? (baseenv))  ; => #f
  (define is-refclass?
    (lambda (x)
      (and (r/call "isS4" (list x))
           (r/call "is" (list x "refClass")))))

  ;;' @section Type Introspection

  ;;' @description Return the type of value (alias for R's typeof).
  ;;' @signature (type-of x)
  ;;' @examples
  ;;' (type-of 42)  ; => "double"
  ;;' @seealso class, mode (R functions)
  (define type-of typeof)
)
