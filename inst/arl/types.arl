;;; Arl Standard Library - Type Predicates

(module types
  (export list? list-or-pair? null? nil?
          symbol? keyword? number? string? vector?
          true? false? boolean? fn? callable? procedure?
          environment? is-refclass?
          atom? empty?
          type-of
          real? complex? rational? exact? inexact?
          integer? natural?
          finite? infinite? nan?
          even? odd? zero?
          positive? negative? non-negative? non-positive?)

  (import _r)

  ;;' @section List and Pair Predicates

  ;;' @description Return #t if x is a proper list (R list or call), not a dotted pair.
  ;;' @examples
  ;;' (list? (list 1 2 3))  ; => #t
  ;;' (list? ())  ; => #t
  ;;' (list? "hello")  ; => #f
  ;;' @seealso pair?, list-or-pair?, null?
  (define list?
    (lambda (x)
      (if (pair? x) #f
        (if (is.list x) #t (if (is.call x) #t #f)))))

  ;;' @description Return #t if x is a non-empty list or dotted pair (pairlist cell).
  ;;' @examples
  ;;' (list-or-pair? (list 1))  ; => #t
  ;;' @seealso list?, pair?, null?, atom?
  (define list-or-pair?
    (lambda (x)
      (if (pair? x) #t
        (if (list? x) (if (__r> (__rlength x) 0) #t #f) #f))))

  ;;' @description Return #t for empty list or #nil.
  ;;' @examples
  ;;' (null? #nil)  ; => #t
  ;;' (null? ())  ; => #t
  ;;' (null? (list 1))  ; => #f
  ;;' @seealso nil?, pair?, list-or-pair?
  (define null?
    (lambda (x)
      (if (is.null x)
        #t
        (if (is.list x)
          (if (__r== (__rlength x) 0) #t #f)
          (if (is.call x)
            (if (__r== (__rlength x) 0) #t #f)
            #f)))))

  ;;' @description Alias for null?.
  ;;' @seealso null?
  (define nil?
    (lambda (x)
      (null? x)))

  ;;' @description Return #t if x is not a non-empty list or
  ;;' dotted pair (i.e. not list-or-pair?).
  ;;' @examples
  ;;' (atom? 42)  ; => #t
  ;;' (atom? "hello")  ; => #t
  ;;' (atom? (list 1 2))  ; => #f
  ;;' (atom? ())  ; => #t  (empty list is atomic)
  ;;' @seealso list-or-pair?
  (define atom?
    (lambda (x)
      (not (list-or-pair? x))))

  ;;' @description Return #t if x is empty (0-length).
  ;;' (Note the empty string "" has length 1 and is not "empty"!)
  ;;' @examples
  ;;' (empty? ())  ; => #t
  ;;' (empty? (list))  ; => #t
  ;;' (empty? (list 1))  ; => #f
  ;;' @note The empty string `""` has length 1 in R and is NOT considered empty!
  ;;' @seealso null?, length= (in `sequences` module)
  (define empty?
    (lambda (x)
      (isTRUE (== (length x) 0))))

  ;;' @section Symbol Predicates

  ;;' @description Return #t if x is a symbol.
  ;;' @signature (symbol? x)
  ;;' @examples
  ;;' (symbol? 'foo)  ; => #t
  ;;' (symbol? "foo")  ; => #f
  ;;' (symbol? 42)  ; => #f
  (define symbol? is.symbol)

  ;;' @description Return #t if x is an Arl keyword.
  ;;' @examples
  ;;' (keyword? ':foo)  ; => #t
  ;;' (keyword? 'foo)   ; => #f
  (define keyword?
    (lambda (x)
      (isTRUE (inherits x "arl_keyword"))))

  ;;' @section Basic Type Predicates

  ;;' @description Return #t if x is a number (real or complex).
  ;;' @examples
  ;;' (number? 42)  ; => #t
  ;;' @seealso real?, complex?, rational?, exact?, inexact?
  (define number?
    (lambda (x)
      (if (is.numeric x)
        #t
        (if (is.complex x) #t #f))))

  ;;' @description Return #t if x is character.
  ;;' @signature (string? x)
  ;;' @examples
  ;;' (string? "hello")  ; => #t
  (define string? is.character)

  ;;' @description Return #t if x is a non-list atomic vector.
  ;;' @examples
  ;;' (vector? (c 1 2 3))  ; => #t
  ;;' @note Tests whether x is a non-list atomic vector (numeric, character, logical, etc.). R lists are NOT vectors by this predicate.
  (define vector?
    (lambda (x)
      (if (is.atomic x)
        (if (is.list x) #f #t)
        #f)))

  ;;' @description Return #t if x is a single logical value.
  ;;' @examples
  ;;' (boolean? #t)  ; => #t
  ;;' (boolean? #f)  ; => #t
  ;;' (boolean? TRUE)  ; => #t
  ;;' (boolean? (c TRUE FALSE))  ; => #f
  (define boolean?
    (lambda (x)
      (if (is.logical x)
        (isTRUE (== (length x) 1))
        #f)))

  ;;' @description Return #t if x is TRUE.
  ;;' @examples
  ;;' (true? #t)  ; => #t
  (define true?
    (lambda (x)
      (isTRUE x)))

  ;;' @description Return #t if x is #f.
  ;;' @examples
  ;;' (false? #f)  ; => #t
  (define false?
    (lambda (x)
      (identical x #f)))

  ;;' @section Function Predicates

  ;;' @description Return #t if x is a function.
  ;;' @signature (fn? x)
  ;;' @examples
  ;;' (fn? car)  ; => #t
  ;;' @seealso callable?, procedure?
  (define fn? is.function)

  ;;' @description Alias for fn?.
  ;;' @signature (callable? x)
  ;;' @seealso fn?
  (define callable? fn?)

  ;;' @description Alias for fn? - return #t if x is a function.
  ;;' @seealso fn?, callable?
  (define procedure?
    (lambda (x)
      (fn? x)))

  ;;' @section Environment Predicates

  ;;' @description Test if x is an environment (including R6 objects).
  ;;' @examples
  ;;' (environment? (baseenv))  ; => #t
  ;;' @note R6 objects, dicts, and sets are all environments in R, so this predicate returns #t for them.
  (define environment?
    (lambda (x)
      (r/call "is.environment" (list x))))

  ;;' @description Test if x is a Reference Class object.
  ;;' @examples
  ;;' (is-refclass? (baseenv))  ; => #f
  (define is-refclass?
    (lambda (x)
      (and (r/call "isS4" (list x))
           (r/call "is" (list x "refClass")))))

  ;;' @section Type Introspection

  ;;' @description Return the type of value (alias for R's typeof).
  ;;' @signature (type-of x)
  ;;' @examples
  ;;' (type-of 42)  ; => "double"
  ;;' @seealso class, mode (R functions)
  (define type-of typeof)

  ;;' @section Numeric Type Predicates
  ;;' Arl implements a numeric tower adapted for R's type system:
  ;;'
  ;;' ```
  ;;' number?    (is.numeric OR is.complex)
  ;;' ├─ complex?  (is.complex)
  ;;' └─ real?     (is.numeric AND NOT is.complex)
  ;;'    ├─ ±Inf   (real but not rational)
  ;;'    └─ rational? (real? AND is.finite)
  ;;'       └─ integer? (is.finite AND is.numeric AND x == as.integer(x))
  ;;'          └─ natural? (integer? AND x >= 0)
  ;;'
  ;;' Orthogonal predicates:
  ;;' exact?   (is.integer - storage type)
  ;;' inexact? (number? AND NOT is.integer)
  ;;' ```

  ;;' @description Return #t if x is a real number (includes ±Inf, excludes complex).
  ;;' @examples
  ;;' (real? 42)            ; => #t
  ;;' (real? 3.14)          ; => #t
  ;;' (real? Inf)           ; => #t
  ;;' (real? (make-rectangular 3 4))  ; => #f
  ;;' @seealso rational?, complex?, number?
  (define real?
    (lambda (x)
      (if (is.numeric x)
        (if (is.complex x) #f #t)
        #f)))

  ;;' @description Return #t if x is a complex number.
  ;;' @examples
  ;;' (complex? (make-rectangular 3 4))  ; => #t
  ;;' (complex? 42)         ; => #f
  ;;' @seealso real?, number?, make-rectangular (in `math` module)
  (define complex?
    (lambda (x)
      (is.complex x)))

  ;;' @description Return #t if x is a finite real number (rational in R are finite floats).
  ;;' @examples
  ;;' (rational? 42)        ; => #t
  ;;' (rational? 3.14)      ; => #t
  ;;' (rational? Inf)       ; => #f (infinities are real but not rational)
  ;;' (rational? NaN)       ; => #f
  ;;' @note In R, all finite floating-point numbers can be represented as rationals (IEEE 754). R does not have a built-in rational or decimal type like some Schemes.
  ;;' @seealso real?, integer?, number?
  (define rational?
    (lambda (x)
      (if (real? x)
        (if (is.finite x) #t #f)
        #f)))

  ;;' @description Return #t if x is an exact number (integer storage type in R).
  ;;' @examples
  ;;' (exact? 5L)           ; => #t (integer type)
  ;;' (exact? 5.0)          ; => #f (double type)
  ;;' (exact? (->integer 5)); => #t
  ;;' @note In Scheme, exactness is a property of the number. In R (and Arl), exactness corresponds to integer storage type. All integers are exact; all doubles and complex numbers are inexact.
  ;;' @seealso inexact?, exact->inexact (in `conversions` module)
  (define exact?
    (lambda (x)
      (is.integer x)))

  ;;' @description Return #t if x is an inexact number (double or complex in R).
  ;;' @examples
  ;;' (inexact? 5.0)        ; => #t
  ;;' (inexact? (make-rectangular 3 4))  ; => #t
  ;;' (inexact? 5L)         ; => #f
  ;;' @seealso exact?, inexact->exact (in `conversions` module)
  (define inexact?
    (lambda (x)
      (if (number? x)
        (not (is.integer x))
        #f)))

  ;;' @description Return #t if x is an integer-valued number.
  ;;' @examples
  ;;' (integer? 42)         ; => #t
  ;;' (integer? 42.0)       ; => #t (value is integer even if storage is double)
  ;;' (integer? 3.14)       ; => #f
  ;;' (integer? Inf)        ; => #f
  ;;' @note Tests for integer VALUE, not storage type. Use `exact?` to test storage type.
  ;;' @seealso natural?, exact?, rational?
  (define integer?
    (lambda (x)
      (if (is.numeric x)
        (if (is.finite x)
          (isTRUE (__r== x (__ras.integer x)))
          #f)
        #f)))

  ;;' @description Return #t if x is a natural number (integer >= 0).
  ;;' @examples
  ;;' (natural? 0)          ; => #t
  ;;' (natural? 42)         ; => #t
  ;;' (natural? -5)         ; => #f
  ;;' (natural? 3.14)       ; => #f
  ;;' @seealso integer?, positive?, non-negative?
  (define natural?
    (lambda (x)
      (if (integer? x)
        (isTRUE (__r>= x 0))
        #f)))

  ;;' @description Return #t if x is finite.
  ;;' @examples
  ;;' (finite? 42)          ; => #t
  ;;' (finite? Inf)         ; => #f
  ;;' (finite? NaN)         ; => #f
  ;;' (finite? -Inf)        ; => #f
  ;;' @seealso infinite?, nan?, rational?
  (define finite?
    (lambda (x)
      (isTRUE (is.finite x))))

  ;;' @description Return #t if x is infinite.
  ;;' @examples
  ;;' (infinite? Inf)       ; => #t
  ;;' (infinite? -Inf)      ; => #t
  ;;' (infinite? 42)        ; => #f
  ;;' (infinite? NaN)       ; => #f
  ;;' @seealso finite?, nan?
  (define infinite?
    (lambda (x)
      (isTRUE (is.infinite x))))

  ;;' @description Return #t if x is NaN.
  ;;' @examples
  ;;' (nan? NaN)            ; => #t
  ;;' (nan? (/ 0 0))        ; => #t (0/0 = NaN)
  ;;' (nan? 42)             ; => #f
  ;;' (nan? Inf)            ; => #f
  ;;' @seealso finite?, infinite?
  (define nan?
    (lambda (x)
      (isTRUE (is.nan x))))

  ;;' @section Value Predicates

  ;;' @description Return #t if x is an even number.
  ;;' @examples
  ;;' (even? 4)             ; => #t
  ;;' (even? 3)             ; => #f
  ;;' (even? 0)             ; => #t
  ;;' @seealso odd?
  (define even?
    (lambda (x)
      (isTRUE (__r== (%% x 2) 0))))

  ;;' @description Return #t if x is an odd number.
  ;;' @examples
  ;;' (odd? 3)              ; => #t
  ;;' (odd? 4)              ; => #f
  ;;' @seealso even?
  (define odd?
    (lambda (x)
      (isTRUE (__r== (%% x 2) 1))))

  ;;' @description Return #t if x is zero.
  ;;' @examples
  ;;' (zero? 0)             ; => #t
  ;;' (zero? 0.0)           ; => #t
  ;;' (zero? 1)             ; => #f
  ;;' @seealso positive?, negative?
  (define zero?
    (lambda (x)
      (isTRUE (__r== x 0))))

  ;;' @description Return #t if x is greater than zero.
  ;;' @examples
  ;;' (positive? 5)         ; => #t
  ;;' (positive? 0)         ; => #f
  ;;' (positive? -5)        ; => #f
  ;;' @seealso negative?, non-negative?, zero?
  (define positive?
    (lambda (x)
      (isTRUE (__r> x 0))))

  ;;' @description Return #t if x is less than zero.
  ;;' @examples
  ;;' (negative? -5)        ; => #t
  ;;' (negative? 0)         ; => #f
  ;;' (negative? 5)         ; => #f
  ;;' @seealso positive?, non-positive?, zero?
  (define negative?
    (lambda (x)
      (isTRUE (__r< x 0))))

  ;;' @description Return #t if x is greater than or equal to zero.
  ;;' @examples
  ;;' (non-negative? 5)     ; => #t
  ;;' (non-negative? 0)     ; => #t
  ;;' (non-negative? -5)    ; => #f
  ;;' @seealso positive?, natural?
  (define non-negative?
    (lambda (x)
      (isTRUE (__r>= x 0))))

  ;;' @description Return #t if x is less than or equal to zero.
  ;;' @examples
  ;;' (non-positive? -5)    ; => #t
  ;;' (non-positive? 0)     ; => #t
  ;;' (non-positive? 5)     ; => #f
  ;;' @seealso negative?
  (define non-positive?
    (lambda (x)
      (isTRUE (__r<= x 0))))
)
