;;; Arl Standard Library - Math Helpers

(module math
  (export % + * - / min max
          < > <= >= == =
          inc dec clamp within?
          abs floor ceiling truncate round signum
          sqrt expt
          log exp log10 log2
          sin cos tan asin acos atan atan2
          quotient remainder modulo
          gcd lcm
          make-rectangular make-polar real-part imag-part magnitude angle)

  (import _r)

  ;;' @section Complex Number Utilities

  ;;' @description Construct a complex number from real and imaginary parts.
  ;;' @examples
  ;;' (make-rectangular 3 4)  ; => 3+4i
  ;;' @seealso make-polar, real-part, imag-part
  (define make-rectangular
    (lambda (real imag)
      (complex :real real :imaginary imag)))

  ;;' @description Construct a complex number from polar coordinates (magnitude and angle).
  ;;' @examples
  ;;' (make-polar 5 0)      ; => 5+0i
  ;;' @seealso make-rectangular, magnitude, angle
  (define make-polar
    (lambda (magnitude angle)
      (complex :modulus magnitude :argument angle)))

  ;;' @description Extract the real part of a complex number.
  ;;' @examples
  ;;' (real-part (make-rectangular 3 4))  ; => 3.0
  ;;' @seealso imag-part, make-rectangular
  (define real-part
    (lambda (z)
      (Re z)))

  ;;' @description Extract the imaginary part of a complex number.
  ;;' @examples
  ;;' (imag-part (make-rectangular 3 4))  ; => 4.0
  ;;' @seealso real-part, make-rectangular
  (define imag-part
    (lambda (z)
      (Im z)))

  ;;' @description Compute the magnitude (modulus) of a complex number.
  ;;' @examples
  ;;' (magnitude (make-rectangular 3 4))  ; => 5.0
  ;;' @seealso angle, make-polar
  (define magnitude
    (lambda (z)
      (Mod z)))

  ;;' @description Compute the angle (argument) of a complex number.
  ;;' @examples
  ;;' (angle (make-rectangular 1 1))  ; => 0.7853981633974483 (Ï€/4)
  ;;' @seealso magnitude, make-polar
  (define angle
    (lambda (z)
      (Arg z)))

  ;;' @section Arithmetic Helpers

  ;;' @description Modulo helper using R %%.
  ;;' @examples
  ;;' (% 10 3)   ; => 1
  ;;' (% 17 5)   ; => 2
  (define %
    (lambda (x y)
      (%% x y)))

  ;;' @description Variadic less-than comparison. Checks all adjacent pairs.
  ;;' @signature (< a b ...)
  ;;' @examples
  ;;' (< 1 2)     ; => #t
  ;;' (< 1 2 3)   ; => #t
  ;;' (< 1 3 2)   ; => #f
  (define <
    (lambda (. args)
      (if (__r< (__rlength args) 2)
        #t
        (if (__r== (__rlength args) 2)
          (__r< (__r[[ args 1) (__r[[ args 2))
          (begin
            (define result #t)
            (define remaining args)
            (while (and (__r> (__rlength remaining) 1) result)
              (begin
                (if (not (__r< (car remaining) (car (cdr remaining))))
                  (set! result #f)
                  #nil)
                (set! remaining (cdr remaining))))
            result)))))

  ;;' @description Variadic greater-than comparison. Checks all adjacent pairs.
  ;;' @signature (> a b ...)
  ;;' @examples
  ;;' (> 3 2)     ; => #t
  ;;' (> 3 2 1)   ; => #t
  ;;' (> 3 1 2)   ; => #f
  (define >
    (lambda (. args)
      (if (__r< (__rlength args) 2)
        #t
        (if (__r== (__rlength args) 2)
          (__r> (__r[[ args 1) (__r[[ args 2))
          (begin
            (define result #t)
            (define remaining args)
            (while (and (__r> (__rlength remaining) 1) result)
              (begin
                (if (not (__r> (car remaining) (car (cdr remaining))))
                  (set! result #f)
                  #nil)
                (set! remaining (cdr remaining))))
            result)))))

  ;;' @description Variadic less-than-or-equal comparison. Checks all adjacent pairs.
  ;;' @signature (<= a b ...)
  ;;' @examples
  ;;' (<= 1 2)    ; => #t
  ;;' (<= 1 1 2)  ; => #t
  ;;' (<= 2 1)    ; => #f
  (define <=
    (lambda (. args)
      (if (__r< (__rlength args) 2)
        #t
        (if (__r== (__rlength args) 2)
          (__r<= (__r[[ args 1) (__r[[ args 2))
          (begin
            (define result #t)
            (define remaining args)
            (while (and (__r> (__rlength remaining) 1) result)
              (begin
                (if (not (__r<= (car remaining) (car (cdr remaining))))
                  (set! result #f)
                  #nil)
                (set! remaining (cdr remaining))))
            result)))))

  ;;' @description Variadic greater-than-or-equal comparison. Checks all adjacent pairs.
  ;;' @signature (>= a b ...)
  ;;' @examples
  ;;' (>= 3 2)    ; => #t
  ;;' (>= 2 2 1)  ; => #t
  ;;' (>= 1 2)    ; => #f
  (define >=
    (lambda (. args)
      (if (__r< (__rlength args) 2)
        #t
        (if (__r== (__rlength args) 2)
          (__r>= (__r[[ args 1) (__r[[ args 2))
          (begin
            (define result #t)
            (define remaining args)
            (while (and (__r> (__rlength remaining) 1) result)
              (begin
                (if (not (__r>= (car remaining) (car (cdr remaining))))
                  (set! result #f)
                  #nil)
                (set! remaining (cdr remaining))))
            result)))))

  ;; NULL-safe equality: R's == returns logical(0) for NULL arguments,
  ;; which is not usable in a boolean context. We follow Scheme semantics
  ;; instead: (= NULL NULL) => #t, (= NULL x) => #f.
  ;;' @internal
  ;;' @description NULL-safe equality comparison following Scheme semantics.
  (define __null_safe_eq
    (lambda (a b)
      (if (is.null a)
        (is.null b)
        (if (is.null b)
          #f
          (__r== a b)))))

  ;;' @description Variadic equality comparison. Checks all adjacent pairs.
  ;;' @signature (== a b ...)
  ;;' @examples
  ;;' (== 1 1)     ; => #t
  ;;' (== 1 1 1)   ; => #t
  ;;' (== 1 2)     ; => #f
  (define ==
    (lambda (. args)
      (if (__r< (__rlength args) 2)
        #t
        (if (__r== (__rlength args) 2)
          (__null_safe_eq (__r[[ args 1) (__r[[ args 2))
          (begin
            (define result #t)
            (define remaining args)
            (while (and (__r> (__rlength remaining) 1) result)
              (begin
                (if (not (__null_safe_eq (car remaining) (car (cdr remaining))))
                  (set! result #f)
                  #nil)
                (set! remaining (cdr remaining))))
            result)))))

  ;;' @signature (= a b ...)
  ;;' @examples
  ;;' (= 1 1)           ; => #t
  ;;' (= "a" "a")       ; => #t
  ;;' (= 1 2)           ; => #f
  ;; Alias = to == for convenience
  (define = ==)

  ;;' @description Variadic addition.
  ;;' @signature (+ a ...)
  ;;' @examples
  ;;' (+ 1 2 3)    ; => 6
  ;;' (+)           ; => 0
  ;;' (+ 5)         ; => 5
  (define +
    (lambda (. args)
      (if (__r== (__rlength args) 0)
        0
        (if (__r== (__rlength args) 1)
          (__r[[ args 1)
          (Reduce __r+ args)))))

  ;;' @description Variadic multiplication.
  ;;' @signature (* a ...)
  ;;' @examples
  ;;' (* 2 3 4)    ; => 24
  ;;' (*)           ; => 1
  ;;' (* 5)         ; => 5
  (define *
    (lambda (. args)
      (if (__r== (__rlength args) 0)
        1
        (if (__r== (__rlength args) 1)
          (__r[[ args 1)
          (Reduce __r* args)))))

  ;;' @description Variadic subtraction.
  ;;' @signature (- a ...)
  ;;' @examples
  ;;' (- 10 3)     ; => 7
  ;;' (- 5)        ; => -5
  ;;' (- 10 3 2)   ; => 5
  (define -
    (lambda (. args)
      (if (__r== (__rlength args) 0)
        (stop "- requires at least one argument")
        (if (__r== (__rlength args) 1)
          (__r- 0 (__r[[ args 1))
          (Reduce __r- args)))))

  ;;' @description Variadic division.
  ;;' @signature (/ a ...)
  ;;' @examples
  ;;' (/ 10 2)     ; => 5
  ;;' (/ 5)        ; => 0.2
  ;;' (/ 100 5 2)  ; => 10
  (define /
    (lambda (. args)
      (if (__r== (__rlength args) 0)
        (stop "/ requires at least one argument")
        (if (__r== (__rlength args) 1)
          (__r/ 1 (__r[[ args 1))
          (Reduce __r/ args)))))

  ;;' @description Variadic min.
  ;;' @signature (min a ...)
  ;;' @examples
  ;;' (min 3 1 2)  ; => 1
  (define min
    (lambda (. args)
      (if (= (__rlength args) 0)
        (stop "min requires at least one argument")
        (do.call __rmin args))))

  ;;' @description Variadic max.
  ;;' @signature (max a ...)
  ;;' @examples
  ;;' (max 3 1 2)  ; => 3
  (define max
    (lambda (. args)
      (if (= (__rlength args) 0)
        (stop "max requires at least one argument")
        (do.call __rmax args))))

  ;;' @description Increment numeric value by n (default 1).
  ;;' @examples
  ;;' (inc 5)       ; => 6
  ;;' (inc 5 3)     ; => 8
  ;;' @seealso dec
  (define inc
    (lambda (x (n 1))
      (+ x n)))

  ;;' @description Decrement numeric value by n (default 1).
  ;;' @examples
  ;;' (dec 5)       ; => 4
  ;;' (dec 5 3)     ; => 2
  ;;' @seealso inc
  (define dec
    (lambda (x (n 1))
      (- x n)))

  ;;' @description Clamp numeric value x to the inclusive range [lo, hi].
  ;;' @examples
  ;;' (clamp 5 0 10)   ; => 5
  ;;' (clamp -3 0 10)  ; => 0
  ;;' (clamp 15 0 10)  ; => 10
  ;;' @seealso within?
  (define clamp
    (lambda (x lo hi)
      (if (< x lo)
        lo
        (if (> x hi) hi x))))

  ;;' @description Return #t if x is within the inclusive range [lo, hi].
  ;;' @examples
  ;;' (within? 5 0 10)   ; => #t
  ;;' (within? -3 0 10)  ; => #f
  ;;' (within? 10 0 10)  ; => #t
  ;;' @seealso clamp
  (define within?
    (lambda (x lo hi)
      (if (< x lo)
        #f
        (if (> x hi) #f #t))))

  ;;' @section Rounding and Truncation

  ;; DESIGN NOTE: Simple one-argument pass-through functions use direct assignment
  ;; (define func __rfunc) rather than lambda wrappers to avoid unnecessary stack frames.
  ;; Functions with multiple arguments, optional parameters, or custom logic remain as lambdas.

  ;;' @description Return absolute value of x.
  ;;' @examples
  ;;' (abs -5)      ; => 5
  ;;' (abs 5)       ; => 5
  ;;' @signature (abs x)
  (define abs __rabs)

  ;;' @description Return floor (round down) of x.
  ;;' @examples
  ;;' (floor 3.7)   ; => 3
  ;;' (floor -3.2)  ; => -4
  ;;' @seealso ceiling, truncate, round
  ;;' @signature (floor x)
  (define floor __rfloor)

  ;;' @description Return ceiling (round up) of x.
  ;;' @examples
  ;;' (ceiling 3.2)  ; => 4
  ;;' (ceiling -3.7) ; => -3
  ;;' @seealso floor, truncate, round
  ;;' @signature (ceiling x)
  (define ceiling __rceiling)

  ;;' @description Return truncated (towards zero) value of x.
  ;;' @examples
  ;;' (truncate 3.7)  ; => 3
  ;;' (truncate -3.7) ; => -3
  ;;' @seealso floor, ceiling, round
  ;;' @signature (truncate x)
  (define truncate __rtrunc)

  ;;' @description Round x to given number of decimal places (default 0).
  ;;' @examples
  ;;' (round 3.567)    ; => 4
  ;;' (round 3.567 2)  ; => 3.57
  ;;' @seealso floor, ceiling, truncate
  (define round
    (lambda (x (digits 0))
      (__rround x digits)))

  ;;' @description Return sign of x: -1, 0, or 1.
  ;;' @examples
  ;;' (signum 42)    ; => 1
  ;;' (signum -5)    ; => -1
  ;;' (signum 0)     ; => 0
  ;;' @signature (signum x)
  (define signum __rsign)

  ;;' @section Power, Roots, and Logarithms

  ;;' @description Return square root of x.
  ;;' @examples
  ;;' (sqrt 16)     ; => 4
  ;;' (sqrt 2)      ; => 1.414...
  ;;' @seealso expt
  ;;' @signature (sqrt x)
  (define sqrt __rsqrt)

  ;;' @description Return base raised to power.
  ;;' @examples
  ;;' (expt 2 10)   ; => 1024
  ;;' (expt 3 3)    ; => 27
  ;;' @seealso sqrt
  (define expt
    (lambda (base power)
      (__r^ base power)))

  ;;' @description Return logarithm of x. With one argument,
  ;;' returns natural log. With two, returns log to the given base.
  ;;' @examples
  ;;' (log 1)           ; => 0
  ;;' (log (exp 1))     ; => 1.0
  ;;' (log 100 10)      ; => 2.0
  ;;' @seealso exp, log10, log2
  (define log
    (lambda (x (base #nil))
      (if (is.null base)
        (__rlog x)
        (__rlog x base))))

  ;;' @description Return e raised to power x.
  ;;' @examples
  ;;' (exp 0)       ; => 1
  ;;' (exp 1)       ; => 2.718...
  ;;' @seealso log
  ;;' @signature (exp x)
  (define exp __rexp)

  ;;' @description Return base-10 logarithm of x.
  ;;' @examples
  ;;' (log10 100)   ; => 2
  ;;' (log10 1000)  ; => 3
  ;;' @seealso log, log2
  ;;' @signature (log10 x)
  (define log10 __rlog10)

  ;;' @description Return base-2 logarithm of x.
  ;;' @examples
  ;;' (log2 8)      ; => 3
  ;;' (log2 1024)   ; => 10
  ;;' @seealso log, log10
  ;;' @signature (log2 x)
  (define log2 __rlog2)

  ;;' @section Trigonometric Functions

  ;;' @description Return sine of x (in radians).
  ;;' @signature (sin x)
  ;;' @examples
  ;;' (sin 0)       ; => 0
  ;;' (cos 0)       ; => 1
  ;;' (tan 0)       ; => 0
  (define sin __rsin)

  ;;' @description Return cosine of x (in radians).
  ;;' @signature (cos x)
  (define cos __rcos)

  ;;' @description Return tangent of x (in radians).
  ;;' @signature (tan x)
  (define tan __rtan)

  ;;' @description Return arcsine of x (in radians).
  ;;' @signature (asin x)
  ;;' @examples
  ;;' (asin 1)      ; => 1.5707... (pi/2)
  ;;' (acos 1)      ; => 0
  ;;' (atan 1)      ; => 0.7853... (pi/4)
  (define asin __rasin)

  ;;' @description Return arccosine of x (in radians).
  ;;' @signature (acos x)
  (define acos __racos)

  ;;' @description Return arctangent of x (in radians).
  ;;' @signature (atan x)
  (define atan __ratan)

  ;;' @description Return arctangent of y/x (in radians), respecting quadrant.
  ;;' @examples
  ;;' (atan2 1 1)   ; => 0.7853... (pi/4)
  ;;' (atan2 -1 -1) ; => -2.356... (-3*pi/4)
  (define atan2
    (lambda (y x)
      (__ratan2 y x)))

  ;;' @section Integer Division

  ;;' @description Return integer quotient of x divided by y.
  ;;' @examples
  ;;' (quotient 10 3)   ; => 3
  ;;' (quotient -10 3)  ; => -3
  ;;' @seealso remainder, modulo
  (define quotient
    (lambda (x y)
      (__ras.integer (__rtrunc (__r/ x y)))))

  ;;' @description Return remainder of x divided by y (same sign as x).
  ;;' @examples
  ;;' (remainder 10 3)   ; => 1
  ;;' (remainder -10 3)  ; => -1
  ;;' @seealso quotient, modulo
  (define remainder
    (lambda (x y)
      (__r- x (__r* y (quotient x y)))))

  ;;' @description Return modulo of x and y (same sign as y).
  ;;' @examples
  ;;' (modulo 10 3)    ; => 1
  ;;' (modulo -10 3)   ; => 2
  ;;' @seealso quotient, remainder, %
  (define modulo
    (lambda (x y)
      (%% x y)))

  ;;' @section Number Theory

  ;;' @description Return greatest common divisor of arguments.
  ;;' @signature (gcd a b ...)
  ;;' @examples
  ;;' (gcd 12 8)      ; => 4
  ;;' (gcd 12 8 6)    ; => 2
  ;;' @seealso lcm
  (define gcd
    (lambda (. args)
      (if (__r== (__rlength args) 0)
        0
        (if (__r== (__rlength args) 1)
          (__rabs (__r[[ args 1))
          (begin
            ;; GCD of two numbers using Euclidean algorithm.
            (define gcd-two
              (lambda (a b)
                (if (__r== b 0)
                  (__rabs a)
                  (gcd-two b (modulo a b)))))
            (Reduce gcd-two args))))))

  ;;' @description Return least common multiple of arguments.
  ;;' @signature (lcm a b ...)
  ;;' @examples
  ;;' (lcm 4 6)       ; => 12
  ;;' (lcm 3 4 5)     ; => 60
  ;;' @seealso gcd
  (define lcm
    (lambda (. args)
      (if (__r== (__rlength args) 0)
        1
        (if (__r== (__rlength args) 1)
          (__rabs (__r[[ args 1))
          (begin
            ;; LCM of two numbers using a*b/gcd(a,b).
            (define lcm-two
              (lambda (a b)
                (if (if (__r== a 0) #t (__r== b 0))
                  0
                  (__r/ (__rabs (__r* a b)) (gcd a b)))))
            (Reduce lcm-two args))))))
)
