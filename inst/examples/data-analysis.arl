;; Data Analysis with R Interop
;; Demonstrates seamless integration between Arl and R

(import assert)
(import binding)
(import control)
(import looping)
(import threading)

;; Deterministic randomness for reproducible examples
(r/call "set.seed" (list 123))

;; ============================================================================
;; Working with R Vectors and Lists
;; ============================================================================

(println "=== R Interop Basics ===\n")

;; Create R vectors using r/call
(define nums (r/call "c" (list 1 2 3 4 5 6 7 8 9 10)))
(assert-equal (list 1 2 3 4 5 6 7 8 9 10) (r/call "as.list" (list nums)))
(println (str "R vector: " nums))

;; Use R statistical functions
(define mean-val (r/call "mean" (list nums)))
(define median-val ((:: stats median) nums))
(define sd-val ((:: stats sd) nums))
(assert-equal 5.5 mean-val)
(assert-equal 5.5 median-val)
(assert-true (> sd-val 3.0))
(assert-true (< sd-val 3.1))

(println (str "Mean: " mean-val))
(println (str "Median: " median-val))
(println (str "SD: " sd-val))

;; ============================================================================
;; Generating Data with R
;; ============================================================================

(println "\n=== Generating Data ===\n")

;; Generate random normal data
(define random-data ((:: stats rnorm) 100))
(println (str "Generated 100 random numbers"))
(println (str "First 10: " ((:: utils head) random-data 10)))

;; Summary statistics
(println "\nSummary:")
(println (r/call "summary" (list random-data)))

;; ============================================================================
;; Data Transformation Pipeline
;; ============================================================================

(println "\n=== Data Transformation Pipeline ===\n")

;; Create sample data
(define scores (r/call "c" (list 85 92 78 90 88 76 95 89 91 87)))
(println (str "Original scores: " scores))

;; Transform data using Arl's higher-order functions
(define score-list (r/call "as.list" (list scores)))

;; Add 5 points to each score
(define adjusted-scores (map (lambda (x) (+ x 5)) score-list))
(assert-equal (list 90 97 83 95 93 81 100 94 96 92) adjusted-scores)
(println (str "After adding 5 points: " adjusted-scores))

;; Filter passing scores (>= 80)
(define passing (filter (lambda (x) (>= x 80)) adjusted-scores))
(assert-equal 10 (length passing))
(println (str "Passing scores: " passing))

;; Calculate average of passing scores
(define passing-avg (/ (reduce + passing) (length passing)))
(assert-equal 92.1 passing-avg)
(println (str "Average of passing scores: " passing-avg))

;; ============================================================================
;; Working with Named Lists (Data Frames)
;; ============================================================================

(println "\n=== Working with Named Lists ===\n")

;; Create a named list (similar to R's named vector)
(define student-data
  (dict
   :names (list "Alice" "Bob" "Carol" "Dave" "Eve")
   :scores (list 85 92 78 90 88)
   :ages (list 20 21 19 22 20)))

(println "Student data:")
(println student-data)

;; Extract and process names
(define names (r/call "get" (list "names" student-data)))
(assert-equal (list "Alice" "Bob" "Carol" "Dave" "Eve") names)
(println (str "\nStudent names: " names))

;; Extract and analyze scores
(define scores-data (r/call "get" (list "scores" student-data)))
(assert-equal (list 85 92 78 90 88) scores-data)
(println (str "Scores: " scores-data))

;; ============================================================================
;; Statistical Analysis
;; ============================================================================

(println "\n=== Statistical Analysis ===\n")

;; Create two groups
(define group-a (r/call "c" (list 23 25 21 24 22 26 20)))
(define group-b (r/call "c" (list 30 32 28 31 29 33 27)))

(assert-equal 23 (r/call "mean" (list group-a)))
(println (str "Group A mean: " (r/call "mean" (list group-a))))
(assert-equal 30 (r/call "mean" (list group-b)))
(println (str "Group B mean: " (r/call "mean" (list group-b))))

;; Combine groups for comparison
(define all-values (r/call "c" (list group-a group-b)))
(println (str "\nCombined range: " (r/call "range" (list all-values))))
(println (str "Combined quantiles: " ((:: stats quantile) all-values)))

;; ============================================================================
;; Using R's seq and rep functions
;; ============================================================================

(println "\n=== Sequences and Repetition ===\n")

;; Create sequences
(define seq-1-10 (r/call "seq" (list 1 10)))
(assert-equal (list 1 2 3 4 5 6 7 8 9 10) (r/call "as.list" (list seq-1-10)))
(println (str "Sequence 1-10: " seq-1-10))

(define seq-by-2 (r/call "seq" (list 0 20 2)))
(assert-equal (list 0 2 4 6 8 10 12 14 16 18 20) (r/call "as.list" (list seq-by-2)))
(println (str "Even numbers 0-20: " seq-by-2))

;; Repeat values
(define repeated (r/call "rep" (list 5 10)))
(assert-equal (list 5 5 5 5 5 5 5 5 5 5) (r/call "as.list" (list repeated)))
(println (str "Repeat 5 ten times: " repeated))

;; ============================================================================
;; Combining Arl and R for Data Processing
;; ============================================================================

(println "\n=== Hybrid Processing ===\n")

;; Generate data in R
(define raw-data ((:: stats rnorm) 20 50 10))

;; Convert to list for Arl processing
(define data-list (r/call "as.list" (list raw-data)))

;; Process with Arl functions
(define filtered (filter (lambda (x) (> x 50)) data-list))
(define squared (map (lambda (x) (* x x)) filtered))

(println (str "Values > 50: " filtered))
(println (str "Squared: " squared))

;; Convert back to R vector for R functions
(define result-vec (r/call "unlist" (list squared)))
(println (str "Mean of squared values: " (r/call "mean" (list result-vec))))

;; ============================================================================
;; Using keyword arguments (R named arguments)
;; ============================================================================

(println "\n=== Keyword Arguments ===\n")

;; R functions can be called with named arguments using keywords
;; Note: This feature depends on keyword argument implementation

;; Example: creating a sequence with named arguments
(println "Creating sequences with named arguments:")
(define seq-named (r/call "seq" (dict :from 1 :to 10 :by 2)))
(assert-equal (list 1 3 5 7 9) (r/call "as.list" (list seq-named)))
(println (str "seq(from=1, to=10, by=2): " seq-named))

;; ============================================================================
;; Data Aggregation Example
;; ============================================================================

(println "\n=== Data Aggregation ===\n")

;; Sample transaction data
(define transactions
  (list
   (dict :id 1 :amount 100 :category "food")
   (dict :id 2 :amount 50 :category "transport")
   (dict :id 3 :amount 75 :category "food")
   (dict :id 4 :amount 200 :category "housing")
   (dict :id 5 :amount 30 :category "transport")))

(println "Sample transactions:")
(println transactions)

;; Extract all amounts
(define amounts (map (lambda (t) (r/call "get" (list "amount" t))) transactions))
(assert-equal (list 100 50 75 200 30) amounts)
(println (str "\nAll amounts: " amounts))

;; Calculate total
(define total (reduce + amounts))
(assert-equal 455 total)
(println (str "Total spent: $" total))

;; Filter food transactions
(define food-trans (filter (lambda (t)
                             (= (r/call "get" (list "category" t)) "food"))
                           transactions))
(assert-equal 2 (length food-trans))
(println (str "\nFood transactions: " (length food-trans) " items"))

(define food-total (reduce + (map (lambda (t) (r/call "get" (list "amount" t)))
                                  food-trans)))
(assert-equal 175 food-total)
(println (str "Food total: $" food-total))

(println "\nExample complete!")
