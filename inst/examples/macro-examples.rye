;; Macro System Examples
;; Demonstrates defmacro, quasiquote, unquote, and macro expansion

(import binding)
(import control)
(import looping)
(import threading)

;; Output directory for reports (set via RYE_OUTPUT_DIR env var)
(define *output-dir*
  (let ((dir (r/call "Sys.getenv" (list "RYE_OUTPUT_DIR" ""))))
    (if (= dir "")
        (r/call "tempdir" ())
        dir)))

;; ============================================================================
;; Simple Macros
;; ============================================================================

(println "=== Simple Macros ===\n")

;; A macro that doubles its argument
(defmacro double (x)
  "Multiply x by 2 at macro expansion time."
  `(* 2 ,x))

(println (str "(double 5) = " (double 5)))
(println (str "(double (+ 1 2)) = " (double (+ 1 2))))

;; A macro that creates a variable with a default value
(defmacro defvar (name value)
  "Define a variable with a value."
  `(define ,name ,value))

(defvar x 42)
(println (str "x = " x))

;; ============================================================================
;; Macros with Multiple Expressions
;; ============================================================================

(println "\n=== Macros with Multiple Expressions ===\n")

;; A macro that executes multiple forms and returns the last
(defmacro progn (first . rest)
  "Evaluate forms in order and return the last."
  `(begin ,first ,@rest))

(println "Using progn:")
(progn
  (println "First")
  (println "Second")
  (println "Third"))

;; ============================================================================
;; Control Flow Macros
;; ============================================================================

(println "\n=== Control Flow Macros ===\n")

;; Custom when-not macro
(defmacro when-not (test . body)
  "Evaluate body when test is falsy."
  `(if (not ,test)
       (begin ,@body)
       #nil))

(when-not #f
  (println "This should print"))

(when-not #t
  (println "This should not print"))

;; A do-times macro
(defmacro do-times (n . body)
  "Repeat body n times."
  (let ((counter (gensym "counter")))
    `(let ((,counter 0))
       (while* (< ,counter ,n)
         (begin ,@body)
         (set! ,counter (+ ,counter 1))))))

(println "do-times example:")
(define count 0)
(do-times 5
  (set! count (+ count 1))
  (println (str "Count: " count)))

;; ============================================================================
;; Macro Expansion Examples
;; ============================================================================

(println "\n=== Macro Expansion ===\n")

(println "Original: (when (> 5 3) (println \"yes\"))")
(println "Expanded:")
(println (macroexpand-1 '(when (> 5 3) (println "yes"))))

(println "\nOriginal: (let ((x 1)) (+ x 2))")
(println "Expanded:")
(println (macroexpand-1 '(let ((x 1)) (+ x 2))))

;; ============================================================================
;; Anaphoric Macros (macros that capture a name)
;; ============================================================================

(println "\n=== Anaphoric Macros ===\n")

;; An anaphoric if that binds result to 'it'
(defmacro aif (test then alt)
  "Bind test result to it and select then/alt."
  `(let ((it ,test))
     (if it ,(capture 'it then) ,(capture 'it alt))))

(println "Anaphoric if example:")
(aif (+ 2 3)
     (println (str "Result is: " it))
     (println "No result"))

;; ============================================================================
;; Building DSLs with Macros
;; ============================================================================

(println "\n=== Simple DSL Example ===\n")

;; A macro for defining test cases
(defmacro deftest (name . body)
  "Define and run a simple test case."
  `(begin
     (println (str "Running test: " (quote ,name)))
     ,@body
     (println "Test passed!\n")))

(deftest addition-works
  (assert (= (+ 1 2) 3) "1 + 2 should equal 3")
  (assert (= (+ 5 5) 10) "5 + 5 should equal 10"))

(deftest string-operations
  (assert (= (str "hello" " " "world") "hello world")
          "String concatenation works"))

;; ============================================================================
;; Hygiene and explicit capture
;; ============================================================================

(println "\n=== Hygiene and Capture ===\n")

;; Automatic hygiene (no gensym needed)
(defmacro swap (a b)
  "Swap two bindings using a temporary."
  `(let ((temp ,a))
     (set! ,a ,b)
     (set! ,b temp)))

(println "Demonstrating gensym:")
(println (str "Generated symbol 1: " (gensym)))
(println (str "Generated symbol 2: " (gensym)))
(println (str "Generated symbol with prefix: " (gensym "my-prefix")))

;; ============================================================================
;; Quasiquote Examples
;; ============================================================================

(println "\n=== Quasiquote Examples ===\n")

(define x 10)
(define y 20)

(println "Without quasiquote:")
(println (list '+ 1 2))

(println "\nWith quasiquote and unquote:")
(println `(+ ,x ,y))

(println "\nWith unquote-splicing:")
(define nums (list 1 2 3))
(println `(+ ,@nums))  ; Should expand to (+ 1 2 3)

;; ============================================================================
;; Recursive Macros
;; ============================================================================

(println "\n=== Recursive Macro Example ===\n")

;; A macro that chains function calls
(defmacro -> (value . forms)
  "Thread value through forms (first argument)."
  (if (null? forms)
      value
      (let ((first-form (car forms))
            (rest-forms (cdr forms)))
        (if (pair? first-form)
            `(-> (,(car first-form) ,value ,@(cdr first-form)) ,@rest-forms)
            `(-> (,first-form ,value) ,@rest-forms)))))

(println "Threading macro example:")
(println (str "Result: " (-> 5
                              (+ 3)
                              (* 2)
                              (- 1))))  ; ((5 + 3) * 2) - 1 = 15

;; ============================================================================
;; Compile-Time Computation
;; ============================================================================

(println "\n=== Compile-Time Computation ===\n")

;; A macro that computes at macro expansion time
(defmacro const-multiply (a b)
  "Compute the product of a and b at expand time."
  (let ((result (* a b)))
    `(quote ,result)))

(println (str "(const-multiply 6 7) = " (const-multiply 6 7)))
(println "This multiplication happened at macro expansion time!")

(define threading-result (-> 5 (+ 3) (* 2) (- 1)))
(define aif-result (aif (+ 2 3) it #nil))
(define expanded-when (macroexpand-1 '(when (> 5 3) (println "yes"))))

(define example-result
  (dict
   :threading_result threading-result
   :aif_result aif-result
   :expanded_when expanded-when))

(define report-path (r/call "file.path" (list *output-dir* "macro-report.txt")))
(r/call "writeLines"
        (list
         (r/call "c" (list (str "threading_result=" threading-result)
                           (str "aif_result=" aif-result)
                           (str "expanded_when=" expanded-when)))
         report-path))

(println "\nExample complete!")
