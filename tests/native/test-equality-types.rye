;; Tests for equality predicates and type conversions (Phase 4)
;; eq?, eqv?, equal?, type predicates, and conversions

;; ============================================================================
;; Equality Predicates
;; ============================================================================
;; NOTE: R does not support true Scheme eq?/eqv? semantics.
;; Tests use identical? (R's native equality) and equal? (deep structural equality).

(define test-identical-same-reference (lambda ()
  ;; Same variable reference
  (define x (list 1 2 3))
  (define y x)
  (assert-true (identical? x y))))

(define test-identical-equal-lists (lambda ()
  ;; In R, identical() does structural comparison for lists
  (define x (list 1 2 3))
  (define y (list 1 2 3))
  (assert-true (identical? x y))))  ;; R behavior: structural equality

(define test-identical-symbols (lambda ()
  ;; Symbols with same name
  (assert-true (identical? 'foo 'foo))))

(define test-identical-numbers (lambda ()
  ;; Numbers with same value
  (assert-true (identical? 5 5))
  (assert-false (identical? 5 6))))

(define test-identical-different-types (lambda ()
  ;; Different types
  (assert-false (identical? 5 "5"))))

(define test-equal-lists (lambda ()
  ;; Deep structural equality
  (define x (list 1 2 3))
  (define y (list 1 2 3))
  (assert-true (equal? x y))))

(define test-equal-nested-lists (lambda ()
  (define x (list 1 (list 2 3) 4))
  (define y (list 1 (list 2 3) 4))
  (assert-true (equal? x y))))

(define test-equal-different-structure (lambda ()
  (define x (list 1 2 3))
  (define y (list 1 2 4))
  (assert-false (equal? x y))))

(define test-equal-strings (lambda ()
  (assert-true (equal? "hello" "hello"))
  (assert-false (equal? "hello" "world"))))

(define test-equal-with-environments (lambda ()
  ;; equal? should handle reference-semantic types like environments
  (define env1 (r/call "new.env" (list)))
  (define env2 (r/call "new.env" (list)))
  (r/call "assign" (list "x" 1 :envir env1))
  (r/call "assign" (list "x" 1 :envir env2))
  (assert-false (identical? env1 env2))  ;; Different objects
  (assert-true (equal? env1 env2))))     ;; Same contents

;; ============================================================================
;; Type Predicates
;; ============================================================================

(define test-atom-numbers (lambda ()
  (assert-true (atom? 5))
  (assert-true (atom? 3.14))))

(define test-atom-strings (lambda ()
  (assert-true (atom? "hello"))))

(define test-atom-symbols (lambda ()
  (assert-true (atom? 'foo))))

(define test-atom-not-pair (lambda ()
  (assert-false (atom? (cons 1 2)))))

(define test-atom-not-pair (lambda ()
  (assert-false (atom? (list 1 2)))))

(define test-atom-empty-list (lambda ()
  ;; Empty list is atomic (not list-or-pair?)
  (assert-true (atom? (list)))))

(define test-procedure-predicate (lambda ()
  ;; procedure? is alias for fn?
  (assert-true (procedure? (lambda (x) x)))
  (assert-false (procedure? 42))))

(define test-rational-numbers (lambda ()
  (assert-true (rational? 5))
  (assert-true (rational? 3.5))))

(define test-real-numbers (lambda ()
  (assert-true (real? 5))
  (assert-true (real? 3.14))
  (assert-true (real? -2.5))))

(define test-complex-numbers (lambda ()
  ;; R supports complex numbers
  (assert-true (complex? (complex :real 3 :imaginary 4)))))

;; ============================================================================
;; Symbol Conversions
;; ============================================================================

(define test-symbol-to-string-basic (lambda ()
  (assert-equal (symbol->string 'foo) "foo")))

(define test-symbol-to-string-hyphenated (lambda ()
  (assert-equal (symbol->string 'hello-world) "hello-world")))

(define test-string-to-symbol-basic (lambda ()
  (assert-equal (string->symbol "foo") 'foo)))

(define test-string-to-symbol-roundtrip (lambda ()
  (define sym 'test-symbol)
  (assert-eq (string->symbol (symbol->string sym)) sym)))

;; ============================================================================
;; General Type Conversions
;; ============================================================================

(define test-to-symbol (lambda ()
  (assert-equal (->symbol "hello") 'hello)))

(define test-to-number (lambda ()
  (assert-equal (->number "42") 42)
  (assert-equal (->number "3.14") 3.14)))

(define test-to-list-from-vector (lambda ()
  (define vec (c 1 2 3))
  (define lst (->list vec))
  (assert-true (list? lst))
  (assert-equal (car lst) 1)))

(define test-to-vector-from-list (lambda ()
  (define lst (list 1 2 3))
  (define vec (->vector lst))
  (assert-true (vector? vec))))

;; ============================================================================
;; Type Introspection
;; ============================================================================

(define test-type-of-number (lambda ()
  (assert-equal (type-of 42) "double")))

(define test-type-of-string (lambda ()
  (assert-equal (type-of "hello") "character")))

(define test-type-of-symbol (lambda ()
  (assert-equal (type-of 'foo) "symbol")))

(define test-type-of-list (lambda ()
  (assert-equal (type-of (list 1 2 3)) "list")))

(define test-type-of-function (lambda ()
  (define f (lambda (x) x))
  (assert-equal (type-of f) "closure")))
