;; Native tests for functional programming - User-facing examples
;; For comprehensive edge case testing, see tests/testthat/test-stdlib-functional.R
;; These tests demonstrate idiomatic usage patterns with simple examples.

;; ============================================================================
;; Currying
;; ============================================================================

(define test-curry-basic (lambda ()
  ;; curry enables partial application
  (define add (lambda (a b c) (+ a b c)))
  (define add3 (curry add 3))
  (define result ((add3 5) 7))  ;; Should be (+ 3 5 7)
  (assert-equal result 15)))

;; ============================================================================
;; Juxtaposition
;; ============================================================================

(define test-juxt-basic (lambda ()
  ;; juxt applies multiple functions and collects results
  (define inc (lambda (x) (+ x 1)))
  (define dec (lambda (x) (- x 1)))
  (define both (juxt inc dec))
  (assert-equal (both 10) (list 11 9))))

;; ============================================================================
;; Constantly
;; ============================================================================

(define test-constantly-basic (lambda ()
  ;; constantly returns a function that always returns the same value
  (define always-42 (constantly 42))
  (assert-equal (always-42) 42)
  (assert-equal (always-42 1 2 3) 42)))

(define test-constantly-in-map (lambda ()
  ;; useful for replacing all values
  (define zeros (map (constantly 0) (list 1 2 3)))
  (assert-equal zeros (list 0 0 0))))

;; ============================================================================
;; Iterate
;; ============================================================================

(define test-iterate-basic (lambda ()
  ;; iterate applies function n times to initial value
  ;; Start at 0, apply +1 five times: 0 -> 1 -> 2 -> 3 -> 4 -> 5
  (define result (iterate (lambda (x) (+ x 1)) 5 0))
  (assert-equal result 5)))

(define test-iterate-until (lambda ()
  ;; iterate-until stops when predicate is true
  (define result (iterate-until
                   (lambda (x) (* x 2))
                   1
                   (lambda (x) (>= x 100))))
  (assert-equal result (list 1 2 4 8 16 32 64))))

;; ============================================================================
;; Memoization
;; ============================================================================

(define test-memoize-fibonacci (lambda ()
  ;; Classic use case: memoized fibonacci
  (define fib #nil)
  (set! fib (memoize
              (lambda (n)
                (if (<= n 1)
                  n
                  (+ (fib (- n 1)) (fib (- n 2)))))))

  ;; fib(10) = 55
  (assert-equal (fib 10) 55)
  ;; Should be very fast even for larger values due to memoization
  (assert-equal (fib 15) 610)))
