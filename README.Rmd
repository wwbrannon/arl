---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# Rye

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
[![R-CMD-check](https://github.com/wwbrannon/rye/workflows/R-CMD-check/badge.svg)](https://github.com/wwbrannon/rye/actions)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
<!-- badges: end -->

A Lisp dialect implemented in and with access to R, leveraging R's Scheme heritage.

## Overview

Rye is a Lisp dialect that seamlessly integrates with R. It provides:

- **Homoiconic syntax**: Code as data, data as code
- **Powerful macros**: Transform code at compile-time with `defmacro` and quasiquote
- **R interoperability**: Call any R function, use R data structures
- **Lexical scoping**: Clean, predictable variable binding
- **First-class functions**: Functions are values, closures work naturally

## Installation

```{r eval=FALSE}
# Install from source
devtools::install()

# Or install dependencies and load
devtools::install_deps()
devtools::load_all()
```

## Quick Start

```{r eval=FALSE}
library(rye)

# Start the REPL
rye_repl()
```

### Examples

```lisp
; Arithmetic
(+ 1 (* 2 3))  ; => 7

; Variables
(define x 10)
(+ x 5)  ; => 15

; Functions
(define factorial
  (lambda (n)
    (if (< n 2)
      1
      (* n (factorial (- n 1))))))

(factorial 5)  ; => 120

; R interop
(mean (c 1 2 3 4 5))  ; => 3

; Named arguments
(seq :from 1 :to 10 :by 2)  ; => 1 3 5 7 9

; Macros
(defmacro when (test body)
  `(if ,test ,body #nil))

(when (> 5 3) (print "yes"))  ; => "yes"

; Higher-order functions
(define double (lambda (x) (* x 2)))
(map double (list 1 2 3))  ; => (2 4 6)
```

## Features

### Special Forms

- `quote` / `'` - Return unevaluated expression
- `if` - Conditional evaluation
- `define` - Variable/function definition
- `lambda` - Anonymous functions
- `begin` - Sequence of expressions
- `defmacro` - Define macros
- `quasiquote` / `` ` `` - Template with selective evaluation
- `~` - Formula (for R modeling)

### Standard Library

The REPL automatically loads a standard library with:

- **List operations**: `car`, `cdr`, `cons`, `list`
- **Higher-order**: `map`, `filter`, `reduce`
- **Predicates**: `null?`, `list?`, `number?`, `string?`, `symbol?`
- **Arithmetic**: `+`, `-`, `*`, `/`, `%`
- **Comparison**: `<`, `>`, `<=`, `>=`, `=`
- **Logic**: `not`

### R Integration

All R functions are accessible directly:

```lisp
; Call R functions
(lm (~ y x) :data df)

; Use R operators
($ mylist field)
([ vector 1)

; Access R data structures
(define df (data.frame :x (c 1 2 3) :y (c 4 5 6)))
```

## Development

See the [Makefile](Makefile) for common development commands:

```bash
# Run tests
make test

# Check package
make build
make check

# Generate documentation
make document
```

## Architecture

Rye leverages R's existing eval/quote/environment system:

1. **Parser**: Converts S-expressions to R calls
2. **Macro expander**: Processes `defmacro` definitions
3. **Evaluator**: Handles special forms, delegates to R's `eval()`
4. **R bridge**: Seamless access to all R functions

## License

MIT
