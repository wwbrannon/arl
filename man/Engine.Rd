% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/engine.R
\name{Engine}
\alias{Engine}
\title{Core Arl engine}
\description{
Provides class-based organization for tokenization, parsing, macro expansion,
evaluation, and environment management.
}
\examples{
engine <- Engine$new()
engine$eval_text("(+ 1 2 3)")
engine$eval_string("(+ 4 5)")
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{use_env_cache}}{Logical. If TRUE, enables the env cache (full serialized
environment) which is faster but only safe when dependencies don't change.
If FALSE (default), only the expr cache (compiled expressions) is used, which
is always safe. Can be set via engine initialization parameter or global
option \code{arl.use_env_cache}.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Engine-new}{\code{Engine$new()}}
\item \href{#method-Engine-read}{\code{Engine$read()}}
\item \href{#method-Engine-write}{\code{Engine$write()}}
\item \href{#method-Engine-eval}{\code{Engine$eval()}}
\item \href{#method-Engine-eval_text}{\code{Engine$eval_text()}}
\item \href{#method-Engine-eval_string}{\code{Engine$eval_string()}}
\item \href{#method-Engine-import_stdlib}{\code{Engine$import_stdlib()}}
\item \href{#method-Engine-load_file_under_env}{\code{Engine$load_file_under_env()}}
\item \href{#method-Engine-load_file_in_env}{\code{Engine$load_file_in_env()}}
\item \href{#method-Engine-macroexpand}{\code{Engine$macroexpand()}}
\item \href{#method-Engine-inspect_compilation}{\code{Engine$inspect_compilation()}}
\item \href{#method-Engine-help}{\code{Engine$help()}}
\item \href{#method-Engine-repl}{\code{Engine$repl()}}
\item \href{#method-Engine-enable_coverage}{\code{Engine$enable_coverage()}}
\item \href{#method-Engine-disable_coverage}{\code{Engine$disable_coverage()}}
\item \href{#method-Engine-get_coverage}{\code{Engine$get_coverage()}}
\item \href{#method-Engine-reset_coverage}{\code{Engine$reset_coverage()}}
\item \href{#method-Engine-get_env}{\code{Engine$get_env()}}
\item \href{#method-Engine-format_value}{\code{Engine$format_value()}}
\item \href{#method-Engine-with_error_context}{\code{Engine$with_error_context()}}
\item \href{#method-Engine-print_error}{\code{Engine$print_error()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-new"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-new}{}}}
\subsection{Method \code{new()}}{
Initialize engine components and base environment.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$new(
  env = NULL,
  parent = NULL,
  use_env_cache = NULL,
  coverage_tracker = NULL,
  load_stdlib = TRUE,
  disable_tco = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{env}}{Optional existing environment to use. If NULL, creates a new environment.}

\item{\code{parent}}{Optional parent environment for the new environment. Only used if env is NULL.
Defaults to baseenv(). Cannot be specified together with env.}

\item{\code{use_env_cache}}{Optional logical. If TRUE, enables the env cache for 4x faster
module loading. Only safe when dependencies don't change. Defaults to NULL, which
inherits from global option \code{getOption("arl.use_env_cache", FALSE)}.}

\item{\code{coverage_tracker}}{Optional CoverageTracker instance to enable coverage tracking
from the start. If provided, coverage will be tracked during stdlib
loading. Intended for internal development use.}

\item{\code{load_stdlib}}{Logical. If TRUE (the default), loads all stdlib modules
during initialization. Set to FALSE to create a bare engine with only
builtins â€” useful for testing or when you want to import specific modules.}

\item{\code{disable_tco}}{Optional logical. If TRUE, disables self-tail-call optimization
in the compiler, preserving natural call stacks for debugging. Defaults to NULL,
which inherits from global option \code{getOption("arl.disable_tco", FALSE)}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-read"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-read}{}}}
\subsection{Method \code{read()}}{
Tokenize and parse source into expressions. The format returned by this
method is not guaranteed to be stable across package versions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$read(source, source_name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{source}}{Character string containing Arl source.}

\item{\code{source_name}}{Optional source name for error reporting.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-write"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-write}{}}}
\subsection{Method \code{write()}}{
Convert an Arl expression to its string representation. Inverse of read().
The format returned by this method is not guaranteed to be stable across
package versions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$write(expr)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{Arl expression (symbol/call/atomic value).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-eval"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-eval}{}}}
\subsection{Method \code{eval()}}{
Evaluate one or more expressions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$eval(expr, ..., env = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{Arl expression (symbol/call/atomic value).}

\item{\code{...}}{Additional Arl expressions to evaluate (variadic).}

\item{\code{env}}{Optional environment or Env used as the engine base.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-eval_text"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-eval_text}{}}}
\subsection{Method \code{eval_text()}}{
Read and evaluate Arl source text. Convenience wrapper around
\code{read()} and \code{eval()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$eval_text(text, env = NULL, source_name = "<eval>")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{text}}{Character string of Arl code to read/eval.}

\item{\code{env}}{Optional environment or Env used as the engine base.}

\item{\code{source_name}}{Optional source name for error reporting.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-eval_string"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-eval_string}{}}}
\subsection{Method \code{eval_string()}}{
Alias for \code{eval_text()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$eval_string(text, env = NULL, source_name = "<eval>")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{text}}{Character string of Arl code to read/eval.}

\item{\code{env}}{Optional environment or Env used as the engine base.}

\item{\code{source_name}}{Optional source name for error reporting.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-import_stdlib"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-import_stdlib}{}}}
\subsection{Method \code{import_stdlib()}}{
Load and attach all stdlib modules into an environment.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$import_stdlib(env = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{env}}{Target environment. Defaults to the engine top-level environment.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-load_file_under_env"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-load_file_under_env}{}}}
\subsection{Method \code{load_file_under_env()}}{
Load and evaluate an Arl source file in an isolated scope. The file runs in a
child of \code{env}, so definitions and imports in the file are not visible
in \code{env} or to subsequent code. For source-like behavior (definitions
visible in the engine), use \code{load_file_in_env(path, env)}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$load_file_under_env(path, env = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{path}}{File path to load.}

\item{\code{env}}{Optional environment or Env used as the engine base.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-load_file_in_env"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-load_file_in_env}{}}}
\subsection{Method \code{load_file_in_env()}}{
Load and evaluate an Arl source file in the given environment. Definitions
and imports in the file are visible in \code{env}. For isolated execution
(definitions not visible), use \code{load_file_under_env(path, env)}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$load_file_in_env(path, env = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{path}}{File path to load.}

\item{\code{env}}{Optional environment or Env used as the engine base.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-macroexpand"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-macroexpand}{}}}
\subsection{Method \code{macroexpand()}}{
Expand macros in an expression. With \code{depth = NULL} (the default),
fully and recursively expand all macros. With \code{depth = N}, expand
only the top-level macro up to N times without walking into subexpressions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$macroexpand(expr, env = NULL, depth = NULL, preserve_src = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{Arl expression (symbol/call/atomic value).}

\item{\code{env}}{Optional environment or Env used as the engine base.}

\item{\code{depth}}{Number of expansion steps (NULL for full expansion).}

\item{\code{preserve_src}}{Logical; keep source metadata when macroexpanding.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-inspect_compilation"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-inspect_compilation}{}}}
\subsection{Method \code{inspect_compilation()}}{
Inspect expansion and compilation for debugging. Parse text, expand macros in env,
then compile to R. Returns parsed AST, expanded form, compiled R expression, and
deparsed R code so you can see exactly what an Arl program becomes.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$inspect_compilation(text, env = NULL, source_name = "<inspect>")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{text}}{Character; Arl source (single expression or multiple).}

\item{\code{env}}{Environment or NULL (use engine env). Must have macros/stdlib if needed.}

\item{\code{source_name}}{Name for parse errors.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List with \code{parsed} (first expr), \code{expanded}, \code{compiled} (R expr or NULL), \code{compiled_deparsed} (character, or NULL).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-help"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-help}{}}}
\subsection{Method \code{help()}}{
Show help for a topic.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$help(topic, env = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{topic}}{Help topic as a single string.}

\item{\code{env}}{Optional environment or Env used as the engine base.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-repl"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-repl}{}}}
\subsection{Method \code{repl()}}{
Start the Arl REPL using this engine.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$repl()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-enable_coverage"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-enable_coverage}{}}}
\subsection{Method \code{enable_coverage()}}{
Enable coverage tracking.

Creates a coverage tracker and installs it in the eval context.
Should be called before running code you want to track.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$enable_coverage()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-disable_coverage"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-disable_coverage}{}}}
\subsection{Method \code{disable_coverage()}}{
Disable coverage tracking.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$disable_coverage()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-get_coverage"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-get_coverage}{}}}
\subsection{Method \code{get_coverage()}}{
Get coverage data as a data frame.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$get_coverage()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A data frame with columns \code{file}, \code{total_lines},
\code{covered_lines}, and \code{coverage_pct} (one row per tracked file),
with a \code{"total"} attribute containing aggregate stats.
Returns NULL if coverage tracking is not enabled.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-reset_coverage"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-reset_coverage}{}}}
\subsection{Method \code{reset_coverage()}}{
Reset coverage data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$reset_coverage()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-get_env"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-get_env}{}}}
\subsection{Method \code{get_env()}}{
Get the top-level R environment backing this engine.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$get_env()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
An R environment.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-format_value"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-format_value}{}}}
\subsection{Method \code{format_value()}}{
Format a value for display using the engine's formatter.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$format_value(value)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{value}}{Value to format.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Character string.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-with_error_context"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-with_error_context}{}}}
\subsection{Method \code{with_error_context()}}{
Run a function with source-tracking error context.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$with_error_context(fn)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fn}}{A zero-argument function to call.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The return value of \code{fn}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Engine-print_error"></a>}}
\if{latex}{\out{\hypertarget{method-Engine-print_error}{}}}
\subsection{Method \code{print_error()}}{
Format and print an Arl error with source context.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$print_error(e, file = stderr())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{e}}{A condition object.}

\item{\code{file}}{Connection to print to (default \code{stderr()}).}
}
\if{html}{\out{</div>}}
}
}
}
