% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/engine.R
\name{Engine}
\alias{Engine}
\title{Core Arl engine}
\description{
Provides class-based organization for tokenization, parsing, macro expansion,
evaluation, and environment management.
}
\examples{
engine <- Engine$new()
engine$eval_text("(+ 1 2 3)")
engine$eval_string("(+ 4 5)")
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-ArlEngine-new}{\code{Engine$new()}}
\item \href{#method-ArlEngine-read}{\code{Engine$read()}}
\item \href{#method-ArlEngine-write}{\code{Engine$write()}}
\item \href{#method-ArlEngine-eval}{\code{Engine$eval()}}
\item \href{#method-ArlEngine-eval_text}{\code{Engine$eval_text()}}
\item \href{#method-ArlEngine-eval_string}{\code{Engine$eval_string()}}
\item \href{#method-ArlEngine-load_file_in_env}{\code{Engine$load_file_in_env()}}
\item \href{#method-ArlEngine-macroexpand}{\code{Engine$macroexpand()}}
\item \href{#method-ArlEngine-inspect_compilation}{\code{Engine$inspect_compilation()}}
\item \href{#method-ArlEngine-help}{\code{Engine$help()}}
\item \href{#method-ArlEngine-repl}{\code{Engine$repl()}}
\item \href{#method-ArlEngine-enable_coverage}{\code{Engine$enable_coverage()}}
\item \href{#method-ArlEngine-disable_coverage}{\code{Engine$disable_coverage()}}
\item \href{#method-ArlEngine-get_coverage}{\code{Engine$get_coverage()}}
\item \href{#method-ArlEngine-reset_coverage}{\code{Engine$reset_coverage()}}
\item \href{#method-ArlEngine-get_env}{\code{Engine$get_env()}}
\item \href{#method-ArlEngine-define}{\code{Engine$define()}}
\item \href{#method-ArlEngine-format_value}{\code{Engine$format_value()}}
\item \href{#method-ArlEngine-with_error_context}{\code{Engine$with_error_context()}}
\item \href{#method-ArlEngine-print_error}{\code{Engine$print_error()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-new"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-new}{}}}
\subsection{Method \code{new()}}{
Initialize engine components and base environment.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$new(
  coverage_tracker = NULL,
  load_prelude = TRUE,
  disable_tco = NULL,
  disable_constant_folding = NULL,
  disable_optimizations = NULL,
  disable_arithmetic_infix = NULL,
  disable_bytecode = NULL,
  r_packages = "search_path"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{coverage_tracker}}{Optional CoverageTracker instance to enable coverage tracking
from the start. If provided, coverage will be tracked during stdlib
loading. Intended for internal development use.}

\item{\code{load_prelude}}{Logical. If TRUE (the default), loads prelude modules
during initialization. Set to FALSE to create a bare engine with only
builtins â€” useful for testing or when you want to import specific modules.}

\item{\code{disable_tco}}{Optional logical. If TRUE, disables self-tail-call optimization
in the compiler, preserving natural call stacks for debugging. Defaults to NULL,
which inherits from global option \code{getOption("arl.disable_tco", FALSE)}.}

\item{\code{disable_constant_folding}}{Optional logical. If TRUE, disables compile-time
constant folding, forcing all expressions to be evaluated at runtime. Useful for
testing that builtins match R semantics. Defaults to NULL, which inherits from
global option \code{getOption("arl.disable_constant_folding", FALSE)}.}

\item{\code{disable_optimizations}}{Optional logical. If TRUE, disables all non-essential
compiler optimizations (constant folding, TCO, dead code elimination, strength
reduction, identity elimination, truthiness optimization, begin simplification,
and boolean flattening). Individual toggles like \code{disable_tco} and
\code{disable_constant_folding} are applied after this and can override it.
Defaults to NULL, which inherits from global option
\code{getOption("arl.disable_optimizations", FALSE)}.}

\item{\code{disable_arithmetic_infix}}{Logical; if TRUE, disable 2-arg arithmetic infix compilation.}

\item{\code{disable_bytecode}}{Logical; if TRUE, disable bytecode compilation of cached modules.}

\item{\code{r_packages}}{Controls which R packages are visible to Arl code.
\code{"search_path"} (default) tracks R's \code{search()} dynamically;
a character vector pins a fixed set; \code{NULL} exposes only \code{baseenv()}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-read"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-read}{}}}
\subsection{Method \code{read()}}{
Tokenize and parse source into expressions. The format returned by this
method is not guaranteed to be stable across package versions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$read(source, source_name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{source}}{Character string containing Arl source.}

\item{\code{source_name}}{Optional source name for error reporting.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of parsed Arl expressions (R language objects).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-write"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-write}{}}}
\subsection{Method \code{write()}}{
Convert an Arl expression to its string representation. Inverse of read().
The format returned by this method is not guaranteed to be stable across
package versions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$write(expr)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{Arl expression (symbol/call/atomic value).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A character string of the Arl source representation.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-eval"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-eval}{}}}
\subsection{Method \code{eval()}}{
Evaluate one or more expressions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$eval(expr, ..., env = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{Arl expression (symbol/call/atomic value).}

\item{\code{...}}{Additional Arl expressions to evaluate (variadic).}

\item{\code{env}}{Optional environment or Env used as the engine base.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The result of the last evaluated expression.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-eval_text"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-eval_text}{}}}
\subsection{Method \code{eval_text()}}{
Read and evaluate Arl source text. Convenience wrapper around
\code{read()} and \code{eval()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$eval_text(text, env = NULL, source_name = "<eval>")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{text}}{Character string of Arl code to read/eval.}

\item{\code{env}}{Optional environment or Env used as the engine base.}

\item{\code{source_name}}{Optional source name for error reporting.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The result of the last evaluated expression.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-eval_string"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-eval_string}{}}}
\subsection{Method \code{eval_string()}}{
Alias for \code{eval_text()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$eval_string(text, env = NULL, source_name = "<eval>")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{text}}{Character string of Arl code to read/eval.}

\item{\code{env}}{Optional environment or Env used as the engine base.}

\item{\code{source_name}}{Optional source name for error reporting.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The result of the last evaluated expression.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-load_file_in_env"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-load_file_in_env}{}}}
\subsection{Method \code{load_file_in_env()}}{
Load and evaluate an Arl source file in the given environment. Definitions
and imports in the file are visible in \code{env}. To evaluate in an
isolated child scope, create one explicitly:
\code{load_file_in_env(path, new.env(parent = env))}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$load_file_in_env(path, env = NULL, cache = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{path}}{File path to load.}

\item{\code{env}}{Optional environment or Env used as the engine base.}

\item{\code{cache}}{Logical; if TRUE (the default), use the module cache.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The result of the last evaluated expression (invisibly).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-macroexpand"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-macroexpand}{}}}
\subsection{Method \code{macroexpand()}}{
Expand macros in an expression. With \code{depth = NULL} (the default),
fully and recursively expand all macros. With \code{depth = N}, expand
only the top-level macro up to N times without walking into subexpressions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$macroexpand(expr, env = NULL, depth = NULL, preserve_src = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{Arl expression (symbol/call/atomic value).}

\item{\code{env}}{Optional environment or Env used as the engine base.}

\item{\code{depth}}{Number of expansion steps (NULL for full expansion).}

\item{\code{preserve_src}}{Logical; keep source metadata when macroexpanding.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-inspect_compilation"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-inspect_compilation}{}}}
\subsection{Method \code{inspect_compilation()}}{
Inspect expansion and compilation for debugging. Parse text, expand macros in env,
then compile to R. Returns parsed AST, expanded form, compiled R expression, and
deparsed R code so you can see exactly what an Arl program becomes.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$inspect_compilation(text, env = NULL, source_name = "<inspect>")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{text}}{Character; Arl source (single expression or multiple).}

\item{\code{env}}{Environment or NULL (use engine env). Must have macros/stdlib if needed.}

\item{\code{source_name}}{Name for parse errors.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List with \code{parsed} (first expr), \code{expanded},
\code{compiled} (R expr or NULL), \code{compiled_deparsed}
(character, or NULL).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-help"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-help}{}}}
\subsection{Method \code{help()}}{
Show help for a topic.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$help(topic, env = NULL, package = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{topic}}{Help topic as a single string.}

\item{\code{env}}{Optional environment/Env to resolve Arl bindings against.}

\item{\code{package}}{Optional package name (string or symbol) to force R help
lookup in a specific package.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Help text (invisibly), or NULL if topic not found.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-repl"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-repl}{}}}
\subsection{Method \code{repl()}}{
Start the Arl REPL using this engine.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$repl()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
NULL (invisibly); called for side effects.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-enable_coverage"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-enable_coverage}{}}}
\subsection{Method \code{enable_coverage()}}{
Enable coverage tracking.

Creates a coverage tracker and installs it in the eval context.
Should be called before running code you want to track.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$enable_coverage()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The engine (invisibly), for method chaining.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-disable_coverage"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-disable_coverage}{}}}
\subsection{Method \code{disable_coverage()}}{
Disable coverage tracking.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$disable_coverage()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The engine (invisibly), for method chaining.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-get_coverage"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-get_coverage}{}}}
\subsection{Method \code{get_coverage()}}{
Get coverage data as a data frame.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$get_coverage()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A data frame with columns \code{file}, \code{total_lines},
\code{covered_lines}, and \code{coverage_pct} (one row per tracked file),
with a \code{"total"} attribute containing aggregate stats.
Returns NULL if coverage tracking is not enabled.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-reset_coverage"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-reset_coverage}{}}}
\subsection{Method \code{reset_coverage()}}{
Reset coverage data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$reset_coverage()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The engine (invisibly), for method chaining.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-get_env"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-get_env}{}}}
\subsection{Method \code{get_env()}}{
Get the top-level R environment backing this engine.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$get_env()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
An R environment.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-define"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-define}{}}}
\subsection{Method \code{define()}}{
Define a binding in the engine's top-level environment. This is the
supported way to inject R objects for use in Arl code.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$define(name, value)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{Character string; the binding name.}

\item{\code{value}}{The value to bind.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisible self (for chaining).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-format_value"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-format_value}{}}}
\subsection{Method \code{format_value()}}{
Format a value for display using the engine's formatter.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$format_value(value)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{value}}{Value to format.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Character string.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-with_error_context"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-with_error_context}{}}}
\subsection{Method \code{with_error_context()}}{
Run a function with source-tracking error context.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$with_error_context(fn)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fn}}{A zero-argument function to call.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The return value of \code{fn}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ArlEngine-print_error"></a>}}
\if{latex}{\out{\hypertarget{method-ArlEngine-print_error}{}}}
\subsection{Method \code{print_error()}}{
Format and print an Arl error with source context.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Engine$print_error(e, file = stderr())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{e}}{A condition object.}

\item{\code{file}}{Connection to print to (default \code{stderr()}).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL (invisibly); called for side effects.
}
}
}
