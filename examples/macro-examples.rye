;; Macro System Examples
;; Demonstrates defmacro, quasiquote, unquote, and macro expansion

;; ============================================================================
;; Simple Macros
;; ============================================================================

(println "=== Simple Macros ===\n")

;; A macro that doubles its argument
(defmacro double (x)
  `(* 2 ,x))

(println (str "(double 5) = " (double 5)))
(println (str "(double (+ 1 2)) = " (double (+ 1 2))))

;; A macro that creates a variable with a default value
(defmacro defvar (name value)
  `(define ,name ,value))

(defvar x 42)
(println (str "x = " x))

;; ============================================================================
;; Macros with Multiple Expressions
;; ============================================================================

(println "\n=== Macros with Multiple Expressions ===\n")

;; A macro that executes multiple forms and returns the last
(defmacro progn (first . rest)
  `(begin ,first ,@rest))

(println "Using progn:")
(progn
  (println "First")
  (println "Second")
  (println "Third"))

;; ============================================================================
;; Control Flow Macros
;; ============================================================================

(println "\n=== Control Flow Macros ===\n")

;; Custom when-not macro
(defmacro when-not (test . body)
  `(if (not ,test)
       (begin ,@body)
       #nil))

(when-not #f
  (println "This should print"))

(when-not #t
  (println "This should not print"))

;; A do-times macro
(defmacro do-times (n . body)
  (let ((counter (gensym "counter")))
    `(let ((,counter 0))
       (while (< ,counter ,n)
         (begin ,@body)
         (set! ,counter (+ ,counter 1))))))

(println "do-times example:")
(define count 0)
(do-times 5
  (set! count (+ count 1))
  (println (str "Count: " count)))

;; ============================================================================
;; Macro Expansion Examples
;; ============================================================================

(println "\n=== Macro Expansion ===\n")

(println "Original: (when (> 5 3) (println \"yes\"))")
(println "Expanded:")
(println (macroexpand-1 '(when (> 5 3) (println "yes"))))

(println "\nOriginal: (let ((x 1)) (+ x 2))")
(println "Expanded:")
(println (macroexpand-1 '(let ((x 1)) (+ x 2))))

;; ============================================================================
;; Anaphoric Macros (macros that capture a name)
;; ============================================================================

(println "\n=== Anaphoric Macros ===\n")

;; An anaphoric if that binds result to 'it'
(defmacro aif (test then else)
  `(let ((it ,test))
     (if it ,then ,else)))

(println "Anaphoric if example:")
(aif (+ 2 3)
     (println (str "Result is: " it))
     (println "No result"))

;; ============================================================================
;; Building DSLs with Macros
;; ============================================================================

(println "\n=== Simple DSL Example ===\n")

;; A macro for defining test cases
(defmacro deftest (name . body)
  `(begin
     (println (str "Running test: " (quote ,name)))
     ,@body
     (println "Test passed!\n")))

(deftest addition-works
  (assert (= (+ 1 2) 3) "1 + 2 should equal 3")
  (assert (= (+ 5 5) 10) "5 + 5 should equal 10"))

(deftest string-operations
  (assert (= (str "hello" " " "world") "hello world")
          "String concatenation works"))

;; ============================================================================
;; Hygiene with gensym
;; ============================================================================

(println "\n=== Macro Hygiene ===\n")

;; Without hygiene (could capture user variables)
(defmacro bad-swap (a b)
  `(let ((temp ,a))
     (set! ,a ,b)
     (set! ,b temp)))

;; With hygiene (uses gensym)
(defmacro good-swap (a b)
  (let ((temp-var (gensym "temp")))
    `(let ((,temp-var ,a))
       (set! ,a ,b)
       (set! ,b ,temp-var))))

(println "Demonstrating gensym:")
(println (str "Generated symbol 1: " (gensym)))
(println (str "Generated symbol 2: " (gensym)))
(println (str "Generated symbol with prefix: " (gensym "my-prefix")))

;; ============================================================================
;; Quasiquote Examples
;; ============================================================================

(println "\n=== Quasiquote Examples ===\n")

(define x 10)
(define y 20)

(println "Without quasiquote:")
(println (list '+ 1 2))

(println "\nWith quasiquote and unquote:")
(println `(+ ,x ,y))

(println "\nWith unquote-splicing:")
(define nums (list 1 2 3))
(println `(+ ,@nums))  ; Should expand to (+ 1 2 3)

;; ============================================================================
;; Recursive Macros
;; ============================================================================

(println "\n=== Recursive Macro Example ===\n")

;; A macro that chains function calls
(defmacro -> (value . forms)
  (if (null? forms)
      value
      (let ((first-form (car forms))
            (rest-forms (cdr forms)))
        `(-> (,first-form ,value) ,@rest-forms))))

(println "Threading macro example:")
(println (str "Result: " (-> 5
                              (+ 3)
                              (* 2)
                              (- 1))))  ; ((5 + 3) * 2) - 1 = 15

;; ============================================================================
;; Compile-Time Computation
;; ============================================================================

(println "\n=== Compile-Time Computation ===\n")

;; A macro that computes at macro expansion time
(defmacro const-multiply (a b)
  (let ((result (* a b)))
    `(quote ,result)))

(println (str "(const-multiply 6 7) = " (const-multiply 6 7)))
(println "This multiplication happened at macro expansion time!")

(println "\nExample complete!")
