---
title: "Language Reference"
output: arl::arl_html_vignette
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{{ "{" }}Language Reference{{ "}" }}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- AUTO-GENERATED from inst/arl/ source files. Do not edit manually. -->
<!-- Regenerate with: make lang-docs -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
arl::register_knitr_engine()
```

## Special forms

**Special forms** are expressions with evaluation rules that differ from normal
function calls -- for example, `if` does not evaluate all its arguments, and
`define` binds a name rather than passing it as a value. They are handled
directly by the compiler and cannot be redefined or passed as values.

{% for sf in special_forms %}
- {{ sf.name_link }} -- {{ sf.description }}
{% endfor %}

Anything not in this list is a function or macro, whether
[built-in](#built-in-functions), [standard library](#standard-library),
user-defined, or inherited from R. Unlike special forms, these are ordinary
values and can be passed around, stored in variables, and so on.

## Built-in functions

Certain **built-in functions** are implemented in R ([`R/engine.R`]({{
github_base }}/R/engine.R)) rather than in Arl source modules. These are
low-level primitives that need direct access to engine internals — cons-cell
operations, the macro expander, the evaluator, promise handling, and
documentation helpers. They are always available, even when the stdlib modules
are not loaded (`Engine$new(load_stdlib = FALSE)`).

| Category | Functions |
|----------|-----------|
{% for bc in builtin_categories %}
| {{ bc.cat }} | {{ bc.functions }} |
{% endfor %}

These builtins are documented alongside the stdlib functions they relate to
in the individual reference pages below.

## Inherited R functions

Because Arl compiles to R and its environment chain ultimately parents to
R's `baseenv()`, every function in base R is available in Arl without any
import or special syntax. This is not just interop glue — many common
operations you will use day-to-day come directly from R rather than from Arl's
own builtins or stdlib.

### What "inherited" means

When you write `(max 1 2 3)` in Arl, the compiler emits an R call to `max()`.
There is no Arl wrapper — R's own `max` function runs directly. The same is
true for hundreds of base R functions. They work because R's `baseenv()` sits
at the bottom of the environment chain, so any name not shadowed by an Arl
builtin, stdlib export, or user definition resolves to R's version.

### Examples of commonly used inherited functions

Here are some examples of base R functions that are used routinely in Arl
code and are **not** redefined — R's own implementations run directly:

| Category | Examples |
|----------|----------|
| Math | `max`, `min`, `sum`, `prod` |
| Vectors | `c`, `length`, `seq`, `seq_len`, `seq_along`, `rep`, `rev`, `unique`, `which` |
| Predicates | `is.null`, `is.na`, `is.numeric`, `is.character`, `is.logical`, `is.function`, `is.list`, `is.environment` |
| Coercion | `as.numeric`, `as.character`, `as.logical`, `as.integer`, `as.double`, `as.list` |
| Strings | `paste`, `paste0`, `sprintf`, `nchar`, `substr`, `sub`, `gsub`, `grepl`, `toupper`, `tolower`, `trimws`, `strsplit` |
| Data structures | `list`, `vector`, `matrix`, `data.frame`, `names`, `attr`, `attributes` |
| Accessors | `$`, `[`, `[[`, `@` |
| Apply family | `lapply`, `sapply`, `vapply`, `mapply`, `tapply`, `do.call` |
| I/O | `cat`, `message`, `warning`, `stop`, `readLines`, `writeLines`, `readRDS`, `saveRDS` |
| Environment | `environment`, `new.env`, `parent.env`, `exists`, `assign`, `ls`, `rm` |

This is far from exhaustive — any function in R's base package works in
Arl the same way.

### When Arl shadows R

Arl intentionally redefines some R names with its own versions. The most
important are the **operators**:

- **Arithmetic** (`+`, `-`, `*`, `/`): Arl's versions are variadic, so
  `(+ 1 2 3 4)` works. R's `+` is binary.
- **Comparison** (`<`, `<=`, `>`, `>=`): Arl's versions chain, so
  `(< 1 2 3)` means "1 < 2 and 2 < 3". R's `<` compares two vectors.
- **Equality** (`=`, `==`, `!=`): Arl's versions are NULL-safe and variadic.
  R's `=` is assignment, not comparison.
- **Logical** (`!`): Arl uses `not` and the special forms `and`/`or`.
- **Control flow** (`if`, `while`, `for`): These are Arl special forms or
  macros with Lisp-style syntax.

The stdlib also shadows some base R function names with Lisp-flavored
versions:

- **Math wrappers** (`abs`, `sqrt`, `exp`, `log`, `floor`, `ceiling`,
  `round`): Arl's versions are thin wrappers that add documentation and
  integrate with the help system; behavior is the same.
- **List operations** (`append`, `sort`, `reverse`): Arl's versions work on
  both R lists and cons-cell pair lists, with Lisp-style semantics.
- **I/O and display** (`print`, `format`, `system`): Arl's versions add
  Lisp-style formatting or Arl-specific behavior.
- **Other** (`get`, `identity`, `subset`, `transform`, `try`): Arl provides
  its own implementations of these with Arl-specific semantics.

When you need R's original, use the `base::` namespace prefix:

```{arl, eval=FALSE}
(base::sort (c 3 1 2))      ; R's vector sort, not Arl's list sort
(base::identity (list 1 2))  ; R's identity, not Arl's
```

### What `baseenv()` does and does not contain

An important subtlety: Arl's environment chain parents to R's `baseenv()`,
**not** to R's `.GlobalEnv`. This means only functions from R's **base**
package are inherited automatically.

In a normal R session, several other packages are attached to the search
path by default — `stats`, `utils`, `grDevices`, `graphics`, `datasets`,
and `methods`. Functions from these packages feel like they are part of
"base R" because you never have to load them explicitly in R. But they
are not in `baseenv()`, so they are **not** automatically visible in Arl.

Some commonly used functions that require an explicit package prefix:

| Package | Examples |
|---------|----------|
| `stats` | `median`, `sd`, `var`, `cor`, `lm`, `glm`, `t.test`, `predict`, `dnorm`, `pnorm`, `rnorm` |
| `utils` | `head`, `tail`, `str`, `read.csv`, `write.csv`, `read.table` |
| `grDevices` | `pdf`, `png`, `dev.off`, `rgb`, `colorRamp` |
| `graphics` | `plot`, `lines`, `points`, `hist`, `barplot`, `legend` |

To use these in Arl, prefix with the package name:

```{arl, eval=FALSE}
(stats::median (c 1 2 3 4 5))   ; not just (median ...)
(utils::head mtcars)
(graphics::hist (rnorm 100))
```

This is a deliberate choice: depending on whatever happens to be attached
to the user's `.GlobalEnv` would make Arl code fragile and
non-reproducible. The explicit prefix makes dependencies clear and
ensures code works the same way regardless of the R session's search path.

See [R Interop and Data Workflows](r-interop.html) for more on calling R
functions, using keyword arguments, formulas, and `r/eval`.

## Standard library

In addition to built-in functions, Arl has a **standard library** written in
Arl (`inst/arl/*.arl`). These stdlib modules provide various features: list
operations, math, strings, control flow, and everything else. Modules are
loaded in dependency order (each module declares its dependencies with `(import
...)` and is loaded after the modules it imports).

For the full, per-function reference, see the individual stdlib reference
pages:

{% for v in vignette_links %}
- [{{ v.title }}]({{ v.name }}.html)
{% endfor %}

## Importing modules

All stdlib modules are loaded automatically by `Engine$new()`. The `import`
form is useful inside your own modules (where you start with an empty scope)
and when working with a bare engine (`Engine$new(load_stdlib = FALSE)`):

```{arl, eval=FALSE}
; Import focused modules
(import control)   ; when/unless/cond/case/try*
(import binding)   ; let/let*/letrec
(import looping)   ; for/loop/recur/until
(import threading) ; -> and ->>
(import error)     ; try/catch/finally
```

From R, you can create an engine with the stdlib already loaded:

```r
engine <- Engine$new()                   # all stdlib loaded
bare <- Engine$new(load_stdlib=FALSE)    # builtins only
```

{% for vs in vignette_sections %}

## [{{ vs.heading }}]({{ vs.name }}.html)
{% if vs.summary %}

{{ vs.summary }}
{% endif %}
{% if vs.func_list %}

{{ vs.func_list }}
{% endif %}

Modules: {{ vs.modules_line }}
{% endfor %}

## Source files

Built-in functions are defined in
[`R/engine.R`]({{ github_base }}/R/engine.R). The
Arl stdlib modules are organized by topic in
[`inst/arl/`]({{ github_tree }}/inst/arl) (each file
defines a module). The engine loads these modules in dependency order when
initializing.

{% for sf in source_files %}
{{ sf }}
{% endfor %}

If you're looking for implementation details, these files are the source of
truth for the stdlib definitions.
