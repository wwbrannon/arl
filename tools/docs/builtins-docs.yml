# Documentation for R-defined builtins (injected by RyeEngine$initialize_environment).
# These functions are defined in R code (R/rye-engine.R) rather than .rye source files,
# so they need a separate documentation source for the stdlib vignette generator.
#
# Format matches the output of parse_rye_annotations(): each entry has the same fields
# (description, signature, examples, seealso, note, section) plus a vignette target.

builtins:
  pair?:
    vignette: stdlib-types
    section: List and Pair Predicates
    description: "Return #t if x is a cons cell (dotted pair)."
    signature: "(pair? x)"
    examples: |
      (pair? (cons 1 2))        ; => #t
      (pair? '(1 2 3))          ; => #t
      (pair? '())               ; => #f
    seealso: "list?, null?, atom?"

  identical?:
    vignette: stdlib-equality
    section: Equality Predicates
    description: "R's native equality test. Structural comparison for value types, pointer comparison for reference types."
    signature: "(identical? a b)"
    examples: |
      (identical? 1 1)          ; => #t
      (identical? 1 1.0)        ; => #f (different types)
      (identical? "a" "a")      ; => #t
    seealso: "equal?, eq?, eqv?"
    note: "This is R's `identical()` with no modifications. Use `equal?` for deep structural equality with type coercion."

  eval:
    vignette: stdlib-macro-eval-interop
    section: Evaluation
    description: "Evaluate a Rye expression in the current environment."
    signature: "(eval expr)"
    examples: |
      (eval '(+ 1 2))           ; => 3
      (eval '(list 1 2 3))      ; => (1 2 3)
    seealso: "r/eval, macroexpand"

  gensym:
    vignette: stdlib-macro-eval-interop
    section: Macro Utilities
    description: "Generate a unique uninterned symbol, useful for writing hygienic macros."
    signature: "(gensym [prefix])"
    examples: |
      (gensym)                  ; => G1 (unique symbol)
      (gensym "tmp")            ; => tmp2 (unique with prefix)
    seealso: "macroexpand, macroexpand-1"
    note: "Each call returns a fresh symbol guaranteed not to conflict with user-defined names. The optional prefix defaults to \"G\"."

  macro?:
    vignette: stdlib-macro-eval-interop
    section: Macro Utilities
    description: "Return #t if the symbol names a currently-defined macro."
    signature: "(macro? sym)"
    examples: |
      (defmacro my-mac (x) x)
      (macro? 'my-mac)          ; => #t
      (macro? 'car)             ; => #f

  macroexpand:
    vignette: stdlib-macro-eval-interop
    section: Macro Utilities
    description: "Recursively expand all macros in expr until no macro calls remain."
    signature: "(macroexpand expr)"
    examples: |
      (defmacro my-when (test body)
        `(if ,test ,body #nil))
      (macroexpand '(my-when #t 42))  ; => (if #t 42 #nil)
    seealso: "macroexpand-1, macro?, gensym"
    note: "Also available as `macroexpand-all` (alias)."

  macroexpand-1:
    vignette: stdlib-macro-eval-interop
    section: Macro Utilities
    description: "Expand only the outermost macro call in expr (one step)."
    signature: "(macroexpand-1 expr)"
    examples: |
      (defmacro my-when (test body)
        `(if ,test ,body #nil))
      (macroexpand-1 '(my-when #t 42))  ; => (if #t 42 #nil)
    seealso: "macroexpand, macro?"

  promise?:
    vignette: stdlib-macro-eval-interop
    section: Promises (Lazy Evaluation)
    description: "Return #t if x is a promise (created with `delay`)."
    signature: "(promise? x)"
    examples: |
      (define p (delay (+ 1 2)))
      (promise? p)              ; => #t
      (promise? 42)             ; => #f
    seealso: "force, promise-expr"

  force:
    vignette: stdlib-macro-eval-interop
    section: Promises (Lazy Evaluation)
    description: "Force a promise, evaluating its delayed expression and returning the result. If x is not a promise, returns x unchanged."
    signature: "(force x)"
    examples: |
      (define p (delay (+ 1 2)))
      (force p)                 ; => 3
      (force 42)                ; => 42 (non-promise passed through)
    seealso: "promise?, promise-expr, delay"

  promise-expr:
    vignette: stdlib-macro-eval-interop
    section: Promises (Lazy Evaluation)
    description: "Extract the unevaluated expression from a promise."
    signature: "(promise-expr p)"
    examples: |
      (define p (delay (+ 1 2)))
      (promise-expr p)          ; => (+ 1 2)
    seealso: "promise?, force, delay"
    note: "Signals an error if p is not a promise."

  r/eval:
    vignette: stdlib-macro-eval-interop
    section: Evaluation
    description: "Evaluate an R expression directly via R's eval(), bypassing Rye's compiler."
    signature: "(r/eval expr)"
    examples: |
      (r/eval (quote (seq_len 5)))  ; => c(1, 2, 3, 4, 5)
    seealso: "eval, r/call"
    note: "Useful for evaluating raw R calls that use R control flow (for, while) or other constructs that Rye normally overrides."

  stdlib-env:
    vignette: stdlib-macro-eval-interop
    section: Environment Introspection
    description: "Return the stdlib environment (the environment where all standard library bindings live)."
    signature: "(stdlib-env)"
    examples: |
      (environment? (stdlib-env))  ; => #t
    seealso: "current-env"

  current-env:
    vignette: stdlib-macro-eval-interop
    section: Environment Introspection
    description: "Return the current Rye evaluation environment."
    signature: "(current-env)"
    examples: |
      (environment? (current-env))  ; => #t
    seealso: "stdlib-env"
