---
title: "Standard Library: Predicates"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library: Predicates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

### list?

Tests if a value is a list.

**Signature:** `(list? x)`

**Examples:**
```lisp
(list? (list 1 2 3))  ; => #t
(list? ())            ; => #t
(list? "hello")       ; => #f
```

**See also:** pair?, list-or-pair?, null?

---

### pair?

Tests if a value is a dotted pair (pairlist cell / RyeCons). In R terms, a pair is not a list (type-generic vector); it is a cons cell.

**Signature:** `(pair? x)`

**Examples:**
```lisp
(pair? (cons 1 2))    ; => #t   (dotted pair)
(pair? (list 1))      ; => #f   (list, not a pair)
(pair? ())            ; => #f
```

**See also:** list?, list-or-pair?, null?

---

### list-or-pair?

Tests if a value is a non-empty list or a dotted pair.

**Signature:** `(list-or-pair? x)`

**Examples:**
```lisp
(list-or-pair? (list 1))      ; => #t
(list-or-pair? (list 1 2 3))  ; => #t
(list-or-pair? (cons 1 2))    ; => #t
(list-or-pair? ())            ; => #f
```

**See also:** list?, pair?, null?

---

### null?

Tests if a value is NULL or an empty list.

**Signature:** `(null? x)`

**Examples:**
```lisp
(null? #nil)          ; => #t
(null? ())            ; => #t
(null? (list 1))      ; => #f
```

**See also:** nil?, pair?, list-or-pair?

---

### nil?

Alias for `null?`.

**Signature:** `(nil? x)`

**See also:** null?

---

### symbol?

Tests if a value is a symbol.

**Signature:** `(symbol? x)`

**Examples:**
```lisp
(symbol? 'foo)        ; => #t
(symbol? "foo")       ; => #f
(symbol? 42)          ; => #f
```

---

### keyword?

Tests if a value is a keyword (`:key` syntax).

**Signature:** `(keyword? x)`

**Examples:**
```lisp
(keyword? :foo)       ; => #t
(keyword? 'foo)       ; => #f
```

---

## Numeric Predicates

Rye implements a numeric tower adapted for R's type system:

```
number?    (is.numeric OR is.complex)
├─ complex?  (is.complex)
└─ real?     (is.numeric AND NOT is.complex)
   ├─ ±Inf   (real but not rational)
   └─ rational? (real? AND is.finite)
      └─ integer? (is.finite AND is.numeric AND x == as.integer(x))
         └─ natural? (integer? AND x >= 0)

Orthogonal predicates:
exact?   (is.integer - storage type)
inexact? (number? AND NOT is.integer)
```

---

### number?

Tests if a value is a number (real or complex).

**Signature:** `(number? x)`

**Examples:**
```lisp
(number? 42)                              ; => #t
(number? 3.14)                            ; => #t
(number? (complex :real 3 :imaginary 4))  ; => #t
(number? "42")                            ; => #f
```

**See also:** real?, complex?, rational?

---

### rational?

Tests if a value is a rational number (finite real number in R).

**Signature:** `(rational? x)`

**Examples:**
```lisp
(rational? 42)        ; => #t
(rational? 3.14)      ; => #t
(rational? Inf)       ; => #f (infinities are real but not rational)
(rational? NaN)       ; => #f
```

**Note:** In R, all finite floating-point numbers can be represented as rationals (IEEE 754). R does not have a built-in rational or decimal type like some Schemes.

**See also:** real?, integer?, number?

---

### real?

Tests if a value is a real number (includes infinities, excludes complex).

**Signature:** `(real? x)`

**Examples:**
```lisp
(real? 42)            ; => #t
(real? 3.14)          ; => #t
(real? Inf)           ; => #t
(real? (complex :real 3 :imaginary 4))  ; => #f
```

**See also:** rational?, complex?, number?

---

### complex?

Tests if a value is a complex number.

**Signature:** `(complex? x)`

**Examples:**
```lisp
(complex? (complex :real 3 :imaginary 4))  ; => #t
(complex? 42)         ; => #f
```

**See also:** real?, number?, make-rectangular

---

### exact?

Tests if a number is exact (integer storage type in R).

**Signature:** `(exact? x)`

**Examples:**
```lisp
(exact? 5L)           ; => #t (integer type)
(exact? 5.0)          ; => #f (double type)
(exact? (->integer 5)); => #t
```

**Note:** In Scheme, exactness is a property of the number. In R (and Rye), exactness corresponds to integer storage type. All integers are exact; all doubles and complex numbers are inexact.

**See also:** inexact?, exact->inexact

---

### inexact?

Tests if a number is inexact (double or complex storage type in R).

**Signature:** `(inexact? x)`

**Examples:**
```lisp
(inexact? 5.0)        ; => #t
(inexact? (complex :real 3 :imaginary 4))  ; => #t
(inexact? 5L)         ; => #f
```

**See also:** exact?, inexact->exact

---

### Type Coercion Functions

#### exact->inexact

Converts an exact number to inexact (integer to double).

**Signature:** `(exact->inexact x)`

**Examples:**
```lisp
(exact->inexact 5)    ; => 5.0
```

**See also:** inexact->exact, ->double

---

#### inexact->exact

Converts an inexact number to exact (double to integer, rounds toward zero).

**Signature:** `(inexact->exact x)`

**Examples:**
```lisp
(inexact->exact 5.7)  ; => 5
(inexact->exact 5.2)  ; => 5
```

**See also:** exact->inexact, ->integer

---

#### ->integer

Converts a value to integer.

**Signature:** `(->integer x)`

**Examples:**
```lisp
(->integer 5.7)       ; => 5
(->integer "42")      ; => 42
```

**See also:** ->double, ->number

---

#### ->double

Converts a value to double.

**Signature:** `(->double x)`

**Examples:**
```lisp
(->double 5)          ; => 5.0
(->double "3.14")     ; => 3.14
```

**See also:** ->integer, ->number

---

#### ->complex

Converts a value to complex number (imaginary part = 0).

**Signature:** `(->complex x)`

**Examples:**
```lisp
(->complex 5)         ; => 5+0i
(->complex "3+4i")    ; => 3+4i
```

**See also:** make-rectangular, make-polar

---

### Complex Number Utilities

#### make-rectangular

Constructs a complex number from real and imaginary parts.

**Signature:** `(make-rectangular real imag)`

**Examples:**
```lisp
(make-rectangular 3 4)  ; => 3+4i
```

**See also:** make-polar, real-part, imag-part

---

#### make-polar

Constructs a complex number from polar coordinates (magnitude and angle).

**Signature:** `(make-polar magnitude angle)`

**Examples:**
```lisp
(make-polar 5 0)      ; => 5+0i
```

**See also:** make-rectangular, magnitude, angle

---

#### real-part

Extracts the real part of a complex number.

**Signature:** `(real-part z)`

**Examples:**
```lisp
(real-part (make-rectangular 3 4))  ; => 3.0
```

**See also:** imag-part, make-rectangular

---

#### imag-part

Extracts the imaginary part of a complex number.

**Signature:** `(imag-part z)`

**Examples:**
```lisp
(imag-part (make-rectangular 3 4))  ; => 4.0
```

**See also:** real-part, make-rectangular

---

#### magnitude

Computes the magnitude (modulus) of a complex number.

**Signature:** `(magnitude z)`

**Examples:**
```lisp
(magnitude (make-rectangular 3 4))  ; => 5.0
```

**See also:** angle, make-polar

---

#### angle

Computes the angle (argument) of a complex number in radians.

**Signature:** `(angle z)`

**Examples:**
```lisp
(angle (make-rectangular 1 1))  ; => 0.7853981633974483 (π/4)
```

**See also:** magnitude, make-polar

---

### string?

Tests if a value is a string.

**Signature:** `(string? x)`

**Examples:**
```lisp
(string? "hello")     ; => #t
(string? 'hello)      ; => #f
(string? 42)          ; => #f
```

---

### vector?

Tests if a value is a numeric vector.

**Signature:** `(vector? x)`

**Examples:**
```lisp
(vector? [1 2 3])     ; => #t
(vector? (list 1 2))  ; => #f
```

**Note:** Only numeric vectors are considered vectors by this predicate.

---

### true?

Tests if a value is exactly TRUE.

**Signature:** `(true? x)`

**Examples:**
```lisp
(true? #t)            ; => #t
(true? 1)             ; => #f
```

---

### false?

Tests if a value is exactly FALSE.

**Signature:** `(false? x)`

**Examples:**
```lisp
(false? #f)           ; => #t
(false? 0)            ; => #f
```

---

### fn?

Tests if a value is a function.

**Signature:** `(fn? x)`

**Examples:**
```lisp
(fn? +)               ; => #t
(fn? (lambda (x) x))  ; => #t
(fn? 42)              ; => #f
```

**See also:** callable?

---

### callable?

Alias for `fn?`.

**Signature:** `(callable? x)`

**See also:** fn?
