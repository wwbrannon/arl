---
title: "Standard Library: Core, R Interop, and Testing"
output: arl::arl_html_vignette
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{Standard Library: Core, R Interop, and Testing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- AUTO-GENERATED from inst/arl/ source files. Do not edit manually. -->
<!-- Regenerate with: make lang-docs -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
arl::register_knitr_engine()
```

## Error and Warning {#section-error-and-warning}

### error {#error}

Signal an error with message.

**Signature:** `(error msg)`

**Examples:**
```{arl}
(try (error "something went wrong")
  (catch e ($ e "message")))     ; => "something went wrong"
(try (error "oops")
  (catch e "caught"))            ; => "caught"
```

```{arl, include=FALSE}
(assert-equal "something went wrong" (try (error "something went wrong") (catch e ($ e "message"))))
(assert-equal "caught" (try (error "oops") (catch e "caught")))
```

**See also:** [warn](#warn), [assert](#assert), [try](lang-control.html#try)

---

### warn {#warn}

Emit warning with message.

**Signature:** `(warn msg)`

**Examples:**
```{arl}
(warn "check your input")       ; emits warning, returns #nil
```

**See also:** [error](#error), [trace](lang-strings-io.html#trace)

---

## Identity and Values {#section-identity-and-values}

### identity {#identity}

Return argument.

**Signature:** `(identity x)`

**Examples:**
```{arl}
(identity 42)             ; => 42
(identity "hello")        ; => "hello"
(map identity '(1 2 3))   ; => (1 2 3)
```

```{arl, include=FALSE}
(assert-equal 42 (identity 42))
(assert-equal "hello" (identity "hello"))
```

**See also:** [map](lang-functional.html#map)

---

### values {#values}

Return multiple values to a call-with-values consumer.

**Signature:** `(values args...)`

**Examples:**
```{arl}
(values 1 2 3)            ; => multiple-values container
```

```{arl, include=FALSE}
(assert-true (values? (values 1 2 3)))
```

**See also:** [values?](#values-p), [call-with-values](#call-with-values)

---

### values? {#values-p}

Return #t if x is a multiple-values container.

**Signature:** `(values? x)`

**Examples:**
```{arl}
(values? (values 1 2))    ; => #t
(values? 42)              ; => #f
```

```{arl, include=FALSE}
(assert-true (values? (values 1 2)))
(assert-false (values? 42))
```

**See also:** [values](#values), [call-with-values](#call-with-values)

---

### call-with-values {#call-with-values}

Call producer and pass its values to consumer.

**Signature:** `(call-with-values producer consumer)`

**Examples:**
```{arl}
(call-with-values
  (lambda () (values 1 2))
  (lambda (a b) (+ a b)))  ; => 3
```

```{arl, include=FALSE}
(assert-equal 3 (call-with-values (lambda () (values 1 2)) (lambda (a b) (+ a b))))
```

**See also:** [values](#values), [values?](#values-p)

---

## Function Application {#section-function-application}

### funcall {#funcall}

Apply a function with a provided list of arguments.

**Signature:** `(funcall fn args)`

**Examples:**
```{arl}
(funcall + (list 1 2 3))  ; => 6
(funcall c (list 1 2 3))  ; => c(1, 2, 3)
```

```{arl, include=FALSE}
(assert-equal 6 (funcall + (list 1 2 3)))
```

**See also:** apply, [r/call](#r-call)

---

### r/call {#r-call}

Call an R function with optional environment.
Searches from .GlobalEnv by default, finding base and loaded
package functions.

**Signature:** `(r/call fn [args (list])`

**Examples:**
```{arl}
(r/call "mean" (list (c 1 2 3)))   ; => 2
(r/call "ls" (list))                ; list .GlobalEnv bindings
(r/call "Sys.time" (list))          ; current time
```

```{arl, include=FALSE}
(assert-equal 2 (r/call "mean" (list (c 1 2 3))))
```

**Note:** R functions are directly available in Arl without `r/call`. Use `r/call` when you need to look up a function by string name or specify the search environment.

**See also:** [funcall](#funcall), [r/eval](#r-eval)

---

### get {#get}

Get a binding by name, defaulting to .GlobalEnv.

**Signature:** `(get name [envir] [inherits])`

**Examples:**
```{arl}
(get "mean")              ; => the `mean` function
(get "pi" (baseenv))      ; => 3.141593
```

```{arl, include=FALSE}
(assert-true (is.function (get "mean")))
(assert-true (> (get "pi" (baseenv)) 3.14))
```

**See also:** [r/call](#r-call)

---

### unbind-variable {#unbind-variable}

Remove a variable binding from an environment.

**Signature:** `(unbind-variable name [envir])`

**Examples:**
```{arl}
(begin
  (define tmp-var 42)
  (unbind-variable "tmp-var" (current-env))
  (try tmp-var (catch e "gone")))  ; => "gone"
```

```{arl, include=FALSE}
(assert-equal "gone" (begin (define ub-test 1) (unbind-variable "ub-test" (current-env)) (try ub-test (catch e "gone"))))
```

**See also:** [get](#get), define

---

## License {#section-license}

### license {#license}

Display Arl and R license information.

**Signature:** `(license)`

**Examples:**
```{arl}
(license)                 ; prints Arl and R license info
```

---

## Macro Introspection {#section-macro-introspection}

### macroexpand-1 {#macroexpand-1}

Expand one layer of macros in expr.

**Signature:** `(macroexpand-1 expr)`

**Examples:**
```{arl}
(macroexpand-1 '(when #t 42))  ; => (if #t (begin 42) #nil)
```

```{arl, include=FALSE}
(assert-equal '(if #t (begin 42) #nil) (macroexpand-1 '(when #t 42)))
```

**See also:** [macroexpand](#macroexpand), [macroexpand-all](#macroexpand-all)

---

### macroexpand-all {#macroexpand-all}

Fully expand all macros in expr. Same as macroexpand with no depth.

**Examples:**
```{arl}
(macroexpand-all '(when #t 42))  ; => (if #t (begin 42) #nil)
```

```{arl, include=FALSE}
(assert-equal '(if #t (begin 42) #nil) (macroexpand-all '(when #t 42)))
```

**See also:** [macroexpand](#macroexpand), [macroexpand-1](#macroexpand-1)

---

## R Nonstandard Evaluation Wrappers {#section-r-nonstandard-evaluation-wrappers}

These macros provide Arl-friendly interfaces to R functions that use
nonstandard evaluation (NSE). They automatically quote expressions so
you can write natural Arl code without manual quoting.

### suppressWarnings {#suppresswarnings}

Suppress warnings generated by evaluating expr.

**Signature:** `(suppressWarnings expr)`

**Examples:**
```{arl}
(suppressWarnings (as.numeric "not a number"))  ; => NA (warning suppressed)
(suppressWarnings (log -1))                     ; => NaN (warning suppressed)
```

```{arl, include=FALSE}
(assert-true (is.na (suppressWarnings (as.numeric "not a number"))))
(assert-true (is.nan (suppressWarnings (log -1))))
```

**See also:** [suppressMessages](#suppressmessages)

---

### suppressMessages {#suppressmessages}

Suppress messages generated by evaluating expr.

**Signature:** `(suppressMessages expr)`

**Examples:**
```{arl}
(suppressMessages (message "hello"))            ; => #nil (message suppressed)
```

```{arl, include=FALSE}
(assert-true (is.null (suppressMessages (message "hello"))))
```

**See also:** [suppressWarnings](#suppresswarnings)

---

### with {#with}

Evaluate expr in the context of data (a data frame or list).

**Signature:** `(with data expr)`

**Examples:**
```{arl}
(define df (data.frame :x (c 1 2 3) :y (c 4 5 6)))
(with df (+ x y))         ; => c(5, 7, 9)
```

```{arl, include=FALSE}
(assert-equal (c 5 7 9) (with (data.frame :x (c 1 2 3) :y (c 4 5 6)) (+ x y)))
```

**See also:** [within](#within)

---

### within {#within}

Evaluate expr within data, returning modified data.

**Signature:** `(within data expr)`

**Examples:**
```{arl}
(define df (data.frame :x (c 1 2 3)))
(within df (<- z (* x 2)))   ; returns df with new column z
```

```{arl, include=FALSE}
(assert-true (%in% "z" (names (within (data.frame :x (c 1 2 3)) (<- z (* x 2))))))
```

**See also:** [with](#with)

---

### subset {#subset}

Subset x using condition. Optional rest args for select, drop, etc.

**Signature:** `(subset x condition rest...)`

**Examples:**
```{arl}
(define df (data.frame :x (c 1 2 3) :y (c 10 20 30)))
(subset df (> x 1))       ; rows where x > 1
```

```{arl, include=FALSE}
(assert-equal 2L (nrow (subset (data.frame :x (c 1 2 3) :y (c 10 20 30)) (> x 1))))
```

**See also:** [with](#with), [within](#within)

---

### transform {#transform}

transform is difficult to implement - use within() or dplyr::mutate() instead.

**Signature:** `(transform args...)`

**Note:** Not yet supported due to R named-argument syntax. Use `within` or `dplyr::mutate` instead.

**See also:** [within](#within)

---

### substitute {#substitute}

Perform substitution in an expression, or error if called with 1 arg.

**Signature:** `(substitute args...)`

**Note:** Single-argument `substitute` does not work in Arl due to eager evaluation. Use macros or explicit quoting instead. Two-argument form works normally.

**See also:** defmacro

---

## Assertion Helpers {#section-assertion-helpers}

These functions provide test-style assertions that signal errors on failure
and return `#t` on success.

### assert {#assert}

Assert condition or raise error.

**Signature:** `(assert cond [msg "Assertion failed"])`

**Examples:**
```{arl, eval=FALSE}
(assert #t)               ; => #t
(assert (> 3 2))          ; => #t
(assert #f "must be true")  ; signals "must be true"
(assert #f)               ; signals "Assertion failed"
```

```{arl, include=FALSE}
(assert-true (assert #t))
(assert-true (assert (> 3 2)))
(assert-error (assert #f "must be true"))
(assert-error (assert #f))
```

**See also:** [error](#error)

---

### assert-equal {#assert-equal}

Assert expected and actual are equal?.

**Signature:** `(assert-equal expected actual)`

**Examples:**
```{arl, eval=FALSE}
(assert-equal 3 (+ 1 2))  ; => #t
(assert-equal "a" "a")    ; => #t
(assert-equal 1 2)        ; signals error
```

```{arl, include=FALSE}
(assert-true (assert-equal 3 (+ 1 2)))
(assert-true (assert-equal "a" "a"))
(assert-error (assert-equal 1 2))
```

**See also:** [assert-eq](#assert-eq), [assert-true](#assert-true)

---

### assert-true {#assert-true}

Assert value is truthy.

**Signature:** `(assert-true value)`

**Examples:**
```{arl, eval=FALSE}
(assert-true #t)          ; => #t
(assert-true 1)           ; => #t
(assert-true #f)          ; signals error
```

```{arl, include=FALSE}
(assert-true (assert-true #t))
(assert-true (assert-true 1))
(assert-error (assert-true #f))
```

**See also:** [assert-false](#assert-false), [assert](#assert)

---

### assert-false {#assert-false}

Assert value is falsy.

**Signature:** `(assert-false value)`

**Examples:**
```{arl, eval=FALSE}
(assert-false #f)         ; => #t
(assert-false #nil)       ; => #t
(assert-false #t)         ; signals error
```

```{arl, include=FALSE}
(assert-true (assert-false #f))
(assert-true (assert-false #nil))
(assert-error (assert-false #t))
```

**See also:** [assert-true](#assert-true), [assert](#assert)

---

### assert-eq {#assert-eq}

Assert expected and actual are identical (R's `identical()`).

**Signature:** `(assert-eq expected actual)`

**Examples:**
```{arl, eval=FALSE}
(assert-eq 42 42)          ; => #t
(assert-eq "abc" "abc")    ; => #t
(assert-eq 1 1L)           ; signals error (double vs integer)
(assert-eq 1 "1")          ; signals error (different types)
```

```{arl, include=FALSE}
(assert-true (assert-eq 42 42))
(assert-true (assert-eq "abc" "abc"))
(assert-error (assert-eq 1 "1"))
```

**Note:** Uses R's `identical()`, which checks exact structural identity including type. `1` (double) and `1L` (integer) are not identical. Use `assert-equal` for value comparison with `equal?`.

**See also:** [assert-equal](#assert-equal), [assert](#assert)

---

### assert-error {#assert-error}

Assert expression throws an error.

**Signature:** `(assert-error expr)`

**Examples:**
```{arl, eval=FALSE}
(assert-error (error "boom"))   ; => #t
(assert-error (stop "fail"))    ; => #t
(assert-error 42)               ; signals error
```

```{arl, include=FALSE}
(assert-true (assert-error (error "boom")))
(assert-true (assert-error (stop "fail")))
(assert-error (assert-error 42))
```

**See also:** [assert](#assert), [error](#error)

---

### assert-no-error {#assert-no-error}

Assert expression does not throw an error.

**Signature:** `(assert-no-error expr)`

**Examples:**
```{arl, eval=FALSE}
(assert-no-error 42)                ; => #t
(assert-no-error (+ 1 2))           ; => #t
(assert-no-error (error "boom"))    ; signals error
```

```{arl, include=FALSE}
(assert-true (assert-no-error 42))
(assert-true (assert-no-error (+ 1 2)))
(assert-error (assert-no-error (error "boom")))
```

**See also:** [assert-error](#assert-error), [assert](#assert)

---

## Evaluation {#section-evaluation}

### eval {#eval}

Evaluate a Arl expression in the current environment.

**Signature:** `(eval expr)`

**Examples:**
```{arl}
(eval '(+ 1 2))           ; => 3
(eval '(list 1 2 3))      ; => (1 2 3)
```

```{arl, include=FALSE}
(assert-equal 3 (eval '(+ 1 2)))
(assert-equal (list 1 2 3) (eval '(list 1 2 3)))
```

**See also:** [r/eval](#r-eval), [read](#read), [macroexpand](#macroexpand)

---

### read {#read}

Parse a string into a Arl expression without evaluating it.

**Signature:** `(read source)`

**Examples:**
```{arl}
(read "(+ 1 2)")          ; => (+ 1 2) (unevaluated)
(read "42")               ; => 42
(read "foo")              ; => foo (symbol)
```

```{arl, include=FALSE}
(assert-equal 42 (read "42"))
(assert-equal 3 (eval (read "(+ 1 2)")))
```

**Note:** Returns the first expression from the source string, or #nil if
the string contains no expressions. Like R's parse(), but returns Arl
S-expressions.

**See also:** [eval](#eval), [read-from-string](lang-strings-io.html#read-from-string)

---

### write {#write}

Convert a Arl expression to its string representation.
The inverse of read.

**Signature:** `(write expr)`

**Examples:**
```{arl}
(write '(+ 1 2))          ; => "(+ 1 2)"
(write 42)                ; => "42"
(write "hello")           ; => "\"hello\""
(write #t)                ; => "#t"
```

```{arl, include=FALSE}
(assert-equal "42" (write 42))
(assert-equal "#t" (write #t))
```

**Note:** Produces output that can be parsed back with read, ensuring the
round-trip property: (read (write expr)) equals expr for any expression
produced by read.

**See also:** [read](#read), [eval](#eval), [format-value](lang-strings-io.html#format-value)

---

### r/eval {#r-eval}

Evaluate an R expression directly via R's eval(), bypassing
Arl's compiler.

**Signature:** `(r/eval expr)`

**Examples:**
```{arl}
(r/eval (quote (seq_len 5)))  ; => c(1, 2, 3, 4, 5)
```

```{arl, include=FALSE}
(assert-equal (c 1 2 3 4 5) (r/eval (quote (seq_len 5))))
```

**Note:** Useful for evaluating raw R calls that use R control flow (for,
while) or other constructs that Arl normally overrides.

**See also:** [eval](#eval), [r/call](#r-call)

---

## Macro Utilities {#section-macro-utilities}

### capture {#capture}

Mark a symbol for intentional capture in a macro body,
overriding hygiene.

**Signature:** `(capture 'sym expr)`

**Examples:**
```{arl}
(defmacro aif (test then alt)
`(let ((it ,test))
(if it ,(capture 'it then) ,(capture 'it alt))))
(aif (+ 2 3) it 0)          ; => 5
```

```{arl, include=FALSE}
(assert-equal 5 (aif (+ 2 3) it 0))
```

**Note:** Use capture when writing anaphoric macros or other macros that
intentionally introduce a binding visible to the caller. Without
capture, Arl's automatic hygiene renames macro-introduced symbols to
prevent accidental capture.

**See also:** [gensym](#gensym), [macroexpand](#macroexpand), defmacro

---

### gensym {#gensym}

Generate a unique uninterned symbol, useful for writing
hygienic macros.

**Signature:** `(gensym [prefix])`

**Examples:**
```{arl}
(gensym)                  ; => G1 (unique symbol)
(gensym "tmp")            ; => tmp2 (unique with prefix)
```

```{arl, include=FALSE}
(assert-true (symbol? (gensym)))
(assert-true (symbol? (gensym "tmp")))
```

**Note:** Each call returns a fresh symbol guaranteed not to conflict with
user-defined names. The optional prefix defaults to "G".

**See also:** [macroexpand](#macroexpand), [macroexpand-1](#macroexpand-1)

---

### macro? {#macro-p}

Return #t if the symbol names a currently-defined macro.

**Signature:** `(macro? sym)`

**Examples:**
```{arl}
(defmacro my-mac (x) x)
(macro? 'my-mac)          ; => #t
(macro? 'car)             ; => #f
```

```{arl, include=FALSE}
(assert-true (macro? 'my-mac))
(assert-false (macro? 'car))
```

---

### macroexpand {#macroexpand}

Recursively expand all macros in expr until no macro calls
remain.

**Signature:** `(macroexpand expr)`

**Examples:**
```{arl}
(defmacro my-when (test body)
`(if ,test ,body #nil))
(macroexpand '(my-when #t 42))  ; => (if #t 42 #nil)
```

```{arl, include=FALSE}
(assert-equal '(if #t 42 #nil) (macroexpand '(my-when #t 42)))
```

**Note:** Also available as `macroexpand-all` (alias).

**See also:** [macroexpand-1](#macroexpand-1), [macro?](#macro-p), [gensym](#gensym)

---

## Promises (Lazy Evaluation) {#section-promises-lazy-evaluation}

### promise? {#promise-p}

Return #t if x is a promise (created with `delay`).

**Signature:** `(promise? x)`

**Examples:**
```{arl}
(define p (delay (+ 1 2)))
(promise? p)              ; => #t
(promise? 42)             ; => #f
```

```{arl, include=FALSE}
(define __p (delay (+ 1 2)))
(assert-true (promise? __p))
(assert-false (promise? 42))
```

**See also:** [force](#force), [promise-expr](#promise-expr)

---

### force {#force}

Force a promise, evaluating its delayed expression and
returning the result. If x is not a promise, returns x unchanged.

**Signature:** `(force x)`

**Examples:**
```{arl}
(define p (delay (+ 1 2)))
(force p)                 ; => 3
(force 42)                ; => 42 (non-promise passed through)
```

```{arl, include=FALSE}
(define __fp (delay (+ 10 20)))
(assert-equal 30 (force __fp))
(assert-equal 42 (force 42))
```

**See also:** [promise?](#promise-p), [promise-expr](#promise-expr), delay

---

### promise-expr {#promise-expr}

Extract the unevaluated expression from a promise.

**Signature:** `(promise-expr p)`

**Examples:**
```{arl}
(define p (delay (+ 1 2)))
(promise-expr p)          ; => (+ 1 2)
```

```{arl, include=FALSE}
(define __pe (delay (+ 1 2)))
(assert-equal '(+ 1 2) (promise-expr __pe))
```

**Note:** Signals an error if p is not a promise.

**See also:** [promise?](#promise-p), [force](#force), delay

---

## Environment Introspection {#section-environment-introspection}

### toplevel-env {#toplevel-env}

Return the top-level environment (the environment where all
standard library bindings live).

**Signature:** `(toplevel-env)`

**Examples:**
```{arl}
(environment? (toplevel-env))  ; => #t
```

```{arl, include=FALSE}
(assert-true (environment? (toplevel-env)))
```

**See also:** [current-env](#current-env)

---

### current-env {#current-env}

Return the current Arl evaluation environment.

**Signature:** `(current-env)`

**Examples:**
```{arl}
(environment? (current-env))  ; => #t
```

```{arl, include=FALSE}
(assert-true (environment? (current-env)))
```

**See also:** [toplevel-env](#toplevel-env)

---

## Documentation Helpers {#section-documentation-helpers}

### doc! {#doc-bang}

Attach documentation fields to a function. With a single
string argument, sets the description (backward compatible). With keyword
arguments, sets specific fields and merges with existing documentation.

**Signature:** `(doc! fn "docstring") or (doc! fn :description "..." :examples "...")`

**Examples:**
```{arl, eval=FALSE}
(doc! my-fn "Doubles the input.")
(doc! my-fn :examples "(my-fn 3) ; => 6")
(doc! my-fn :description "Doubles." :note "Fast path.")
```

```{arl, include=FALSE}
(define __doc-test-fn (lambda (x) (* x 2)))
(doc! __doc-test-fn "Doubles the input.")
(assert-equal "Doubles the input." (doc __doc-test-fn))
(doc! __doc-test-fn :examples "(my-fn 3) ; => 6")
(assert-equal "(my-fn 3) ; => 6" (doc __doc-test-fn "examples"))
```

**See also:** [doc](#doc), help

---

### doc {#doc}

Retrieve documentation from a function. With no field argument,
returns the description. Pass a field name string to get a specific field,
or "all" to get the full documentation list.

**Signature:** `(doc fn) or (doc fn "field")`

**Examples:**
```{arl, eval=FALSE}
(doc my-fn)              ; => "Doubles the input."
(doc my-fn "examples")   ; => "(my-fn 3) ; => 6"
(doc my-fn "all")        ; => named list of all fields
```

```{arl, include=FALSE}
(define __doc-get-fn (lambda (x) (+ x 1)))
(doc! __doc-get-fn "Increments input.")
(assert-equal "Increments input." (doc __doc-get-fn))
(doc! __doc-get-fn :note "Simple function.")
(assert-equal "Simple function." (doc __doc-get-fn "note"))
```

**See also:** [doc!](#doc-bang), help

---

