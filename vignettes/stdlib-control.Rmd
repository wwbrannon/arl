---
title: "Standard Library: Control Flow and Macros"
output: arl::arl_html_vignette
vignette: >
  %\VignetteIndexEntry{Standard Library: Control Flow and Macros}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- AUTO-GENERATED from inst/arl/ source files. Do not edit manually. -->
<!-- Regenerate with: make stdlib-docs -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
arl::register_knitr_engine()
```

## Control Flow Macros {#section-control-flow-macros}

### when {#when}

Evaluate body forms when test is truthy.

**Signature:** `(when test body...)`

**Examples:**
```{arl}
(when #t "yes")          ; => "yes"
(when #f "yes")          ; => #nil
(when (> 3 2) (+ 1 1))   ; => 2
```

**See also:** [unless](#unless), if, [cond](#cond)

---

### unless {#unless}

Evaluate body forms when test is falsy.

**Signature:** `(unless test body...)`

**Examples:**
```{arl}
(unless #f "fallback")    ; => "fallback"
(unless #t "fallback")    ; => #nil
(unless (= 1 2) "nope")  ; => "nope"
```

**See also:** [when](#when), if

---

## Conditional Macros {#section-conditional-macros}

### cond {#cond}

Multi-branch conditional.

**Signature:** `(cond clause rest...)`

**Examples:**
```{arl}
(cond
  ((= 1 2) "a")
  ((= 1 1) "b")
  (else "c"))            ; => "b"

(cond
  ((> 10 20) "big")
  (else "small"))        ; => "small"
```

**See also:** [case](#case), if, [when](#when)

---

### case {#case}

Branch on key equality. Each clause:
((datum ...) body ...) or (else body ...).
Key expression is evaluated only once.

**Signature:** `(case key clause rest...)`

**Examples:**
```{arl}
(case (+ 1 1)
  ((1) "one")
  ((2) "two")
  ((3) "three")
  (else "other"))        ; => "two"

(case 'x
  ((a b) "ab")
  ((x y) "xy")
  (else "?"))            ; => "xy"
```

**Note:** The key expression is evaluated only once. Each clause datum list can contain multiple values.

**See also:** [cond](#cond), if

---

## Error Handling Helper {#section-error-handling-helper}

### try* {#try-star}

Evaluate thunk with error/finally handlers.

**Signature:** `(try* thunk [error_handler] [finally_handler])`

**Examples:**
```{arl}
(try* (lambda () 42))                           ; => 42
(try* (lambda () (stop "oops"))
      :error_handler (lambda (e) "caught"))      ; => "caught"
(try* (lambda () 1)
      :finally_handler (lambda () (display "done")))  ; => 1
```

**Note:** Low-level functional interface to R's tryCatch. Prefer the `try` macro for cleaner syntax.

**See also:** [try](#try) (in `error` module), catch, finally

---

## Binding Macros {#section-binding-macros}

### pattern-symbols {#pattern-symbols}

Collect all symbols from a destructuring pattern, ignoring dots.

**Signature:** `(pattern-symbols pattern)`

**See also:** [destructuring-bind](#destructuring-bind)

---

### destructuring-bind {#destructuring-bind}

Bind a destructuring pattern to a value, then evaluate body forms.

**Signature:** `(destructuring-bind pattern value body...)`

**See also:** [let](#let), [let*](#let-star), [pattern-symbols](#pattern-symbols)

---

### let {#let}

Bind names to values within body.

**Signature:** `(let bindings body...)`

**Examples:**
```{arl}
(let ((x 1) (y 2))
  (+ x y))               ; => 3

(let ((x 10))
  (* x x))               ; => 100
```

**Note:** Bindings are evaluated in parallel: earlier bindings are NOT visible to later ones. Use `let*` for sequential binding.

**See also:** [let*](#let-star), [letrec](#letrec)

---

### let* {#let-star}

Sequential let bindings.

**Examples:**
```{arl}
(let* ((x 1) (y (+ x 1)))
  (+ x y))               ; => 3

(let* ((a 10) (b (* a 2)) (c (+ a b)))
  c)                      ; => 30
```

**Note:** Bindings are evaluated sequentially: each binding can refer to previously bound names. Supports destructuring patterns.

**See also:** [let](#let), [letrec](#letrec)

---

### letrec {#letrec}

Recursive bindings.

**Signature:** `(letrec bindings body...)`

**Examples:**
```{arl}
(letrec ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
         (odd?  (lambda (n) (if (= n 0) #f (even? (- n 1))))))
  (even? 10))             ; => #t
```

**Note:** All bindings are visible to all init expressions, enabling mutual recursion. Init values are assigned via `set!` into pre-allocated slots.

**See also:** [let](#let), [let*](#let-star)

---

### when-let {#when-let}

Bind pattern to value and evaluate body when value is truthy.

**Signature:** `(when-let binding body...)`

**Examples:**
```{arl}
(when-let ((x (assoc 'a '((a . 1) (b . 2)))))
  (cdr x))               ; => 1

(when-let ((x #f))
  "never reached")       ; => #nil
```

**See also:** [if-let](#if-let), [when](#when), [let](#let)

---

### if-let {#if-let}

Bind pattern to value and choose branch based on its truthiness.

**Signature:** `(if-let binding then rest...)`

**Examples:**
```{arl}
(if-let ((x 42))
  (+ x 1)
  "nothing")             ; => 43

(if-let ((x #f))
  "truthy"
  "falsy")               ; => "falsy"
```

**See also:** [when-let](#when-let), if, [let](#let)

---

## Looping Macros {#section-looping-macros}

### for {#for}

Loop over seq binding var each iteration. Expands to while.

**Signature:** `(for binding body...)`

**Examples:**
```{arl}
(define total 0)
(for (x '(1 2 3))
  (set! total (+ total x)))
total                       ; => 6

(define result (list))
(for (ch '("a" "b" "c"))
  (set! result (append result (list ch))))
result                      ; => ("a" "b" "c")
```

**Note:** Expands to a `while` loop over the sequence converted to a list.

**See also:** while, [map](stdlib-functional.html#map), [loop](#loop)

---

### recur {#recur}

Signal a recur back to the enclosing `loop`. Only valid inside a `loop` body.

**Signature:** `(recur args...)`

**See also:** [loop](#loop)

---

### loop {#loop}

Clojure-style loop/recur that expands to an R while loop.

**Signature:** `(loop bindings body...)`

**Examples:**
```{arl}
;; Factorial via loop/recur
(loop ((n 5) (acc 1))
  (if (= n 0)
    acc
    (recur (- n 1) (* acc n))))  ; => 120

;; Sum of a list via loop/recur
(loop ((xs '(1 2 3 4)) (total 0))
  (if (null? xs)
    total
    (recur (cdr xs) (+ total (car xs)))))  ; => 10
```

**Note:** The compiler auto-optimizes self-tail-calls in `(define name (lambda ...))` patterns, so `loop`/`recur` is primarily useful for anonymous iteration and mutual recursion patterns. Expands to an R `while` loop internally.

**See also:** [recur](#recur), while, [for](#for)

---

### until {#until}

Repeat body until test is truthy.

**Signature:** `(until test body...)`

**Examples:**
```{arl}
(define i 0)
(until (= i 5)
  (set! i (+ i 1)))
i                          ; => 5
```

**See also:** while

---

## Threading Macros {#section-threading-macros}

### -> {#thread-first}

Thread value through forms (first argument).

**Signature:** `(-> value forms...)`

**Examples:**
```{arl}
(-> 5 (+ 3) (* 2))       ; => 16  ; (5+3)*2
(-> '(1 2 3) (cons 0))   ; => (0 1 2 3)
(-> "hello"
    nchar)                ; => 5
```

**Note:** Threads the value as the FIRST argument to each successive form. If a form is a bare symbol, it is called as a one-argument function.

**See also:** [->>](#thread-last)

---

### ->> {#thread-last}

Thread value through forms (last argument).

**Signature:** `(->> value forms...)`

**Examples:**
```{arl}
(->> '(1 2 3) (map (lambda (x) (* x x))))  ; => (1 4 9)
(->> 5 (- 10))           ; => 5  ; (- 10 5)
(->> '(1 2 3)
     (map (lambda (x) (+ x 10)))
     (car))              ; => 11
```

**Note:** Threads the value as the LAST argument to each successive form. Compare with `->` which threads as the first argument.

**See also:** [->](#thread-first)

---

## Error Handling {#section-error-handling}

### try {#try}

Macro wrapper around try* with catch/finally.

**Signature:** `(try body clauses...)`

**Examples:**
```{arl}
;; Basic try with catch
(try (/ 1 0)
  (catch e (string-append "caught: " ($ e "message"))))

;; try with finally (always runs)
(try (+ 1 2)
  (finally (display "cleanup")))    ; => 3

;; try with both catch and finally
(try (stop "oops")
  (catch e (string-append "error: " ($ e "message")))
  (finally (display "done")))       ; => "error: oops"

;; try with no handlers (just evaluates body)
(try (+ 1 2))                       ; => 3
```

**Note:** Macro wrapper around `try*` that provides familiar catch/finally syntax. The catch clause binds the error condition to the given variable. The finally clause runs regardless of success or failure.

**See also:** [try*](#try-star) (in `control` module)

---

