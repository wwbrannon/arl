---
title: "Standard Library: Macro, Eval, Interop, and Convenience"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library: Macro, Eval, Interop, and Convenience}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

## Macro and Eval

### gensym

Generates a unique symbol.

**Signature:** `(gensym)` or `(gensym prefix)`

**Examples:**
```lisp
(gensym)       ; => 'g1234
(gensym "tmp") ; => 'tmp5678
```

**See also:** defmacro

---

### macro?

Tests if a symbol names a macro.

**Signature:** `(macro? sym)`

**Examples:**
```lisp
(macro? 'when)   ; => #t
(macro? 'car)    ; => #f
```

**See also:** defmacro

---

### eval

Evaluates an expression.

**Signature:** `(eval expr)` or `(eval expr env)`

**Examples:**
```lisp
(eval '(+ 1 2))  ; => 3
(eval (list '+ 1 2))  ; => 3
```

**See also:** apply, call

---

### r/eval

Evaluate an R expression in the current Rye environment.

Use this when you need to execute R special forms (like `for` or `while`) that
cannot be called as regular functions.

**Signature:** `(r/eval expr)` or `(r/eval expr env)`

**Examples:**
```lisp
(begin
  (define i 0)
  (r/eval (call (list 'while
                      '(< i 3)
                      '(<- i (+ i 1)))))
  i)
```

**See also:** eval, for-r, while-r

---

### macroexpand

Fully expands all macros in an expression.

**Signature:** `(macroexpand expr)` or `(macroexpand expr env)`

**Examples:**
```lisp
(macroexpand '(when #t 42))
; => (if #t (begin 42) #nil)
```

**See also:** macroexpand-1, macro?

---

### macroexpand-1

Expands macros one level.

**Signature:** `(macroexpand-1 expr)` or `(macroexpand-1 expr env)`

**Examples:**
```lisp
(macroexpand-1 '(when #t 42))
; => (if #t (begin 42) #nil)
```

**See also:** macroexpand, macro?

---

### defstruct

Defines a simple S3-backed struct constructor, predicate, and accessors.

**Signature:** `(defstruct Name (field ...))`

**Examples:**
```lisp
(defstruct Point (x y))
(define p (make-Point 1 2))
(Point? p)      ; => #t
(Point-x p)     ; => 1
(Point-y p)     ; => 2
```

---

## Documentation Helpers

### doc

Retrieves the docstring attached to a function.

**Signature:** `(doc fn)`

**Examples:**
```lisp
(doc map)      ; => "Apply fn to each element of lst."
(doc filter)   ; => "Return elements of lst satisfying pred."
```

**See also:** doc!, help

---

### doc!

Attaches a docstring to an existing function.

**Signature:** `(doc! fn "docstring")`

**Examples:**
```lisp
(define add (lambda (a b) (+ a b)))
(doc! add "Add two numbers.")
(doc add)   ; => "Add two numbers."
```

**See also:** doc, help

---

## Interop Helpers

### dict

Creates a hash-backed dictionary.

**Signature:** `(dict key1: value1 key2: value2 ...)`

**Examples:**
```lisp
(dict :name "Alice" :age 30)
; => (name: "Alice" age: 30)
```

**See also:** hash

---

### dict?

Tests if a value is a dictionary.

**Signature:** `(dict? x)`

**Examples:**
```lisp
(dict? (dict :a 1))  ; => #t
(dict? (list 1 2))   ; => #f
```

---

### dict-get

Gets the value for a key, or a default if missing.

**Signature:** `(dict-get dict key)` or `(dict-get dict key default)`

**Examples:**
```lisp
(define d (dict :name "Alice" :age 30))
(dict-get d "name")         ; => "Alice"
(dict-get d "missing" 0)    ; => 0
```

**See also:** dict-set, dict-has?

---

### dict-set

Sets a key to a value in the dictionary (mutates and returns the dict).

**Signature:** `(dict-set dict key value)`

**Examples:**
```lisp
(define d (dict :a 1))
(dict-set d "b" 2)
(dict-get d "b")  ; => 2
```

**See also:** dict-get, dict-remove

---

### dict-remove

Removes a key from the dictionary (mutates and returns the dict).

**Signature:** `(dict-remove dict key)`

**Examples:**
```lisp
(define d (dict :a 1 :b 2))
(dict-remove d "a")
(dict-has? d "a")  ; => #f
```

**See also:** dict-set

---

### dict-keys

Returns a list of the dictionary's keys.

**Signature:** `(dict-keys dict)`

**Examples:**
```lisp
(dict-keys (dict :a 1 :b 2))  ; => ("a" "b")
```

**See also:** dict-values

---

### dict-values

Returns a list of the dictionary's values.

**Signature:** `(dict-values dict)`

**Examples:**
```lisp
(dict-values (dict :a 1 :b 2))  ; => (1 2)
```

**See also:** dict-keys

---

### dict-has?

Tests if a dictionary contains a key.

**Signature:** `(dict-has? dict key)`

**Examples:**
```lisp
(define d (dict :x 10))
(dict-has? d "x")  ; => #t
(dict-has? d "y")  ; => #f
```

**See also:** dict-get

---

### dict-merge

Merges multiple dictionaries. Later values override earlier ones.

**Signature:** `(dict-merge dict1 dict2 ...)`

**Examples:**
```lisp
(define d1 (dict :a 1 :b 2))
(define d2 (dict :b 99 :c 3))
(define merged (dict-merge d1 d2))
(dict-get merged "b")  ; => 99
(dict-get merged "c")  ; => 3
```

**See also:** dict, dict-set

---

### set

Creates a hash-backed set.

**Signature:** `(set item ...)`

**Examples:**
```lisp
(define s (set 1 2 3 3))
(set-contains? s 2)   ; => #t
(set-contains? s 9)   ; => #f
```

---

### set?

Tests if a value is a set.

**Signature:** `(set? x)`

**Examples:**
```lisp
(set? (set 1 2 3))  ; => #t
(set? (list 1 2))   ; => #f
```

---

### set-add

Adds an item to a set (mutates and returns the set).

**Signature:** `(set-add set item)`

**Examples:**
```lisp
(define s (set 1 2))
(set-add s 3)
(set-contains? s 3)  ; => #t
```

**See also:** set-remove

---

### set-remove

Removes an item from a set (mutates and returns the set).

**Signature:** `(set-remove set item)`

**Examples:**
```lisp
(define s (set 1 2 3))
(set-remove s 2)
(set-contains? s 2)  ; => #f
```

**See also:** set-add

---

### set-contains?

Tests if a set contains an item.

**Signature:** `(set-contains? set item)`

**Examples:**
```lisp
(define s (set 1 2 3))
(set-contains? s 2)  ; => #t
(set-contains? s 9)  ; => #f
```

---

### set-union

Returns the union of two sets.

**Signature:** `(set-union a b)`

**Examples:**
```lisp
(define a (set 1 2))
(define b (set 2 3))
(define u (set-union a b))
(set-contains? u 1)  ; => #t
(set-contains? u 3)  ; => #t
```

**See also:** set-intersection, set-difference

---

### set-intersection

Returns the intersection of two sets.

**Signature:** `(set-intersection a b)`

**Examples:**
```lisp
(define a (set 1 2 3))
(define b (set 2 3 4))
(define i (set-intersection a b))
(set-contains? i 2)  ; => #t
(set-contains? i 1)  ; => #f
```

**See also:** set-union, set-difference

---

### set-difference

Returns items in the first set that are not in the second.

**Signature:** `(set-difference a b)`

**Examples:**
```lisp
(define a (set 1 2 3))
(define b (set 2 3 4))
(define d (set-difference a b))
(set-contains? d 1)  ; => #t
(set-contains? d 2)  ; => #f
```

**See also:** set-union, set-intersection

---

### hash

Alias for `dict`.

**Signature:** `(hash key1: value1 key2: value2 ...)`

**See also:** dict

---

### r/call

Calls an R function with arguments.

**Signature:** `(r/call fn args)`

**Examples:**
```lisp
(r/call "sum" (list 1 2 3))  ; => 6
(r/call 'sqrt (list 16))     ; => 4
```

**Note:** R functions are also available directly in Rye code (e.g., `(sum 1 2 3)`).

---

## Convenience Functions

### identity

Identity function - returns its argument unchanged.

**Signature:** `(identity x)`

**Examples:**
```lisp
(identity 42)        ; => 42
(map identity lst)   ; => lst
```

**See also:** map

---

### first

Alias for `car` - returns first element.

**Signature:** `(first lst)`

**Examples:**
```lisp
(first (list 1 2 3))  ; => 1
```

**See also:** car, rest, last

---

### rest

Alias for `cdr` - returns all but first element.

**Signature:** `(rest lst)`

**Examples:**
```lisp
(rest (list 1 2 3))  ; => (2 3)
```

**See also:** cdr, first

---

### last

Returns the last element of a list.

**Signature:** `(last lst)`

**Examples:**
```lisp
(last (list 1 2 3))  ; => 3
(last (list 42))     ; => 42
(last ())            ; => #nil
```

**See also:** first, nth

---

### nth

Returns the nth element of a list (0-indexed).

**Signature:** `(nth lst n)`

**Examples:**
```lisp
(nth (list 10 20 30) 0)  ; => 10
(nth (list 10 20 30) 1)  ; => 20
(nth (list 10 20 30) 2)  ; => 30
```

**See also:** first, last

---

### complement

Returns the negation of a predicate function.

**Signature:** `(complement pred)`

**Examples:**
```lisp
(define odd? (complement even?))
(filter odd? (list 1 2 3 4))  ; => (1 3)
```

**See also:** not, filter

---

### compose

Composes two functions (right-to-left application).

**Signature:** `(compose f g)`

**Examples:**
```lisp
(define double (lambda (x) (* x 2)))
(define add-one (lambda (x) (+ x 1)))
(define f (compose add-one double))
(f 5)  ; => 11  (equivalent to (add-one (double 5)))
```

**See also:** partial

---

### repeatedly

Calls a function n times, collecting results.

**Signature:** `(repeatedly n fn)`

**Examples:**
```lisp
(repeatedly 3 random)  ; => (0.123 0.456 0.789)
(repeatedly 5 (lambda () 42))  ; => (42 42 42 42 42)
```

**See also:** repeat, map

---

### repeat

Repeats a value n times.

**Signature:** `(repeat n value)`

**Examples:**
```lisp
(repeat 3 "x")  ; => ("x" "x" "x")
(repeat 5 0)    ; => (0 0 0 0 0)
```

**See also:** repeatedly

---

### partial

Partially applies arguments to a function.

**Signature:** `(partial fn arg1 arg2 ...)`

**Examples:**
```lisp
(define add-five (partial + 5))
(add-five 10)  ; => 15

(define multiply-by-2-3 (partial * 2 3))
(multiply-by-2-3 4)  ; => 24
```

**See also:** compose

---

## Quick Reference by Category

### Core List Operations
`car`, `cdr`, `cons`, `call`, `list*`, `append`, `reverse`, `apply`, `first`, `rest`, `last`, `nth`

### Iteration & Transformation
`map`, `mapcat`, `filter`, `remove`, `reduce`, `foldl`, `foldr`

### Sequence Operations
`take`, `drop`, `take-while`, `drop-while`, `partition`, `flatten`, `zip`

### Predicates
`list?`, `pair?`, `list-or-pair?`, `null?`, `nil?`, `symbol?`, `keyword?`, `number?`, `string?`, `vector?`, `true?`, `false?`, `fn?`, `callable?`

### Control Flow
`when`, `unless`, `and`, `or`, `not`, `cond`, `case`

### Looping
`while`, `for`

### Binding
`let`, `let*`, `letrec`

### Error Handling
`error`, `warn`, `assert`, `trace`, `try`, `catch`, `finally`, `try*`

### String Operations
`str`, `string-join`, `string-split`, `trim`, `format`

### I/O
`display`, `println`, `read-line`

### Higher-Order Utilities
`every?`, `any?`, `identity`, `complement`, `compose`, `partial`, `repeatedly`, `repeat`

### Macro System
`gensym`, `macro?`, `eval`, `macroexpand`, `macroexpand-1`

### Documentation
`help`, `doc`, `doc!`

### Sorting
`sort`, `sort-by`, `merge`, `stable-sort`

### Interop
`dict`, `hash`, `dict?`, `dict-get`, `dict-set`, `dict-remove`, `dict-keys`, `dict-values`, `dict-has?`, `dict-merge`,
`set`, `set?`, `set-add`, `set-remove`, `set-contains?`, `set-union`, `set-intersection`, `set-difference`,
`r/call`

### Threading
`->`, `->>`
