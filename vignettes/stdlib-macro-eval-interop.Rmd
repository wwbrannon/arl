---
title: "Standard Library: Macro, Eval, Interop, and Convenience"
output: arl::arl_html_vignette
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{Standard Library: Macro, Eval, Interop, and Convenience}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- AUTO-GENERATED from inst/arl/ source files. Do not edit manually. -->
<!-- Regenerate with: make stdlib-docs -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
arl::register_knitr_engine()
```

## Error and Warning {#section-error-and-warning}

### error {#error}

Signal an error with message.

**Signature:** `(error msg)`

**Examples:**
```{arl}
(try (error "something went wrong")
  (catch e ($ e "message")))     ; => "something went wrong"
(try (error "oops")
  (catch e "caught"))            ; => "caught"
```

**See also:** [warn](#warn), [assert](#assert), [try](stdlib-control.html#try)

---

### warn {#warn}

Emit warning with message.

**Signature:** `(warn msg)`

**Examples:**
```{arl}
(warn "check your input")       ; emits warning, returns #nil
```

**See also:** [error](#error), [trace](stdlib-strings-io.html#trace)

---

## Identity and Values {#section-identity-and-values}

### identity {#identity}

Return argument.

**Signature:** `(identity x)`

**Examples:**
```{arl}
(identity 42)             ; => 42
(identity "hello")        ; => "hello"
(map identity '(1 2 3))   ; => (1 2 3)
```

**See also:** [map](stdlib-functional.html#map)

---

### values {#values}

Return multiple values to a call-with-values consumer.

**Signature:** `(values args...)`

**Examples:**
```{arl}
(values 1 2 3)            ; => multiple-values container
```

**See also:** [values?](#values-p), [call-with-values](#call-with-values)

---

### values? {#values-p}

Return #t if x is a multiple-values container.

**Signature:** `(values? x)`

**Examples:**
```{arl}
(values? (values 1 2))    ; => #t
(values? 42)              ; => #f
```

**See also:** [values](#values), [call-with-values](#call-with-values)

---

### call-with-values {#call-with-values}

Call producer and pass its values to consumer.

**Signature:** `(call-with-values producer consumer)`

**Examples:**
```{arl}
(call-with-values
  (lambda () (values 1 2))
  (lambda (a b) (+ a b)))  ; => 3
```

**See also:** [values](#values), [values?](#values-p)

---

## Continuations {#section-continuations}

### call/cc {#call-cc}

**Signature:** `(call/cc receiver)`

**Note:** Alias for R's `callCC`. The receiver is passed the current continuation.

**See also:** [call-with-current-continuation](#call-with-current-continuation)

---

### call-with-current-continuation {#call-with-current-continuation}

**Signature:** `(call-with-current-continuation receiver)`

**Note:** Full name alias for `call/cc`.

**See also:** [call/cc](#call-cc)

---

## Function Application {#section-function-application}

### funcall {#funcall}

Apply a function with a provided list of arguments.

**Signature:** `(funcall fn args)`

**Examples:**
```{arl}
(funcall + (list 1 2 3))  ; => 6
(funcall c (list 1 2 3))  ; => c(1, 2, 3)
```

**See also:** apply, [r/call](#r-call)

---

### r/call {#r-call}

Call an R function with optional environment.
Searches from .GlobalEnv by default, finding base and loaded
package functions.

**Signature:** `(r/call fn [args (list])`

**Examples:**
```{arl}
(r/call "mean" (list (c 1 2 3)))   ; => 2
(r/call "ls" (list))                ; list .GlobalEnv bindings
(r/call "Sys.time" (list))          ; current time
```

**Note:** R functions are directly available in Arl without `r/call`. Use `r/call` when you need to look up a function by string name or specify the search environment.

**See also:** [funcall](#funcall), [r/eval](#r-eval)

---

### get {#get}

Get a binding by name, defaulting to .GlobalEnv.

**Signature:** `(get name [envir] [inherits])`

**Examples:**
```{arl}
(get "mean")              ; => the `mean` function
(get "pi" (baseenv))      ; => 3.141593
```

**See also:** [r/call](#r-call)

---

## License {#section-license}

### license {#license}

Display Arl and R license information.

**Signature:** `(license)`

**Examples:**
```{arl}
(license)                 ; prints Arl and R license info
```

---

## Macro Introspection {#section-macro-introspection}

### macroexpand-1 {#macroexpand-1}

Expand one layer of macros in expr.

**Signature:** `(macroexpand-1 expr)`

**Examples:**
```{arl}
(macroexpand-1 '(when #t 42))  ; => (if #t 42 #nil)
```

**See also:** [macroexpand](#macroexpand), [macroexpand-all](#macroexpand-all)

---

### macroexpand-all {#macroexpand-all}

Fully expand all macros in expr. Same as macroexpand with no depth.

**Examples:**
```{arl}
(macroexpand-all '(when #t 42))  ; => (if #t 42 #nil)
```

**See also:** [macroexpand](#macroexpand), [macroexpand-1](#macroexpand-1)

---

## R Nonstandard Evaluation Wrappers {#section-r-nonstandard-evaluation-wrappers}

These macros provide Arl-friendly interfaces to R functions that use
nonstandard evaluation (NSE). They automatically quote expressions so
you can write natural Arl code without manual quoting.

### suppressWarnings {#suppresswarnings}

Suppress warnings generated by evaluating expr.

**Signature:** `(suppressWarnings expr)`

**Examples:**
```{arl}
(suppressWarnings (as.numeric "not a number"))  ; => NA (warning suppressed)
(suppressWarnings (log -1))                     ; => NaN (warning suppressed)
```

**See also:** [suppressMessages](#suppressmessages)

---

### suppressMessages {#suppressmessages}

Suppress messages generated by evaluating expr.

**Signature:** `(suppressMessages expr)`

**Examples:**
```{arl}
(suppressMessages (message "hello"))            ; => #nil (message suppressed)
```

**See also:** [suppressWarnings](#suppresswarnings)

---

### with {#with}

Evaluate expr in the context of data (a data frame or list).

**Signature:** `(with data expr)`

**Examples:**
```{arl}
(define df (data.frame :x (c 1 2 3) :y (c 4 5 6)))
(with df (+ x y))         ; => c(5, 7, 9)
```

**See also:** [within](#within)

---

### within {#within}

Evaluate expr within data, returning modified data.

**Signature:** `(within data expr)`

**Examples:**
```{arl}
(define df (data.frame :x (c 1 2 3)))
(within df (<- z (* x 2)))   ; returns df with new column z
```

**See also:** [with](#with)

---

### subset {#subset}

Subset x using condition. Optional rest args for select, drop, etc.

**Signature:** `(subset x condition rest...)`

**Examples:**
```{arl}
(define df (data.frame :x (c 1 2 3) :y (c 10 20 30)))
(subset df (> x 1))       ; rows where x > 1
```

**See also:** [with](#with), [within](#within)

---

### transform {#transform}

transform is difficult to implement - use within() or dplyr::mutate() instead.

**Signature:** `(transform args...)`

**Note:** Not yet supported due to R named-argument syntax. Use `within` or `dplyr::mutate` instead.

**See also:** [within](#within)

---

### substitute {#substitute}

Perform substitution in an expression, or error if called with 1 arg.

**Signature:** `(substitute args...)`

**Note:** Single-argument `substitute` does not work in Arl due to eager evaluation. Use macros or explicit quoting instead. Two-argument form works normally.

**See also:** defmacro

---

## Dictionary (Hash Table) {#section-dictionary-hash-table}

Dictionaries are mutable key-value stores backed by R environments.
Keys must be strings, symbols, or keywords; values can be anything.

### dict-new {#dict-new}

Create a new empty dictionary environment.

**Signature:** `(dict-new)`

---

### dict-key-to-name {#dict-key-to-name}

Convert key to string name for dict storage.

**Signature:** `(dict-key-to-name key)`

---

### dict {#dict}

Create a hash-backed dictionary from key/value pairs.

**Signature:** `(dict args...)`

**Examples:**
```{arl}
(dict :x 1 :y 2)           ; => dict with keys "x" and "y"
(dict)                      ; => empty dict
(define d (dict :name "Alice" :age 30))
(dict-get d "name")         ; => "Alice"
```

**See also:** [hash](#hash)

---

### hash {#hash}

**Signature:** `(hash . args)`

**Note:** Alias for `dict`.

**See also:** [dict](#dict)

---

### dict? {#dict-p}

Return #t if x is a dictionary.

**Signature:** `(dict? x)`

**Examples:**
```{arl}
(dict? (dict :x 1))        ; => #t
(dict? (list 1 2))         ; => #f
(dict? 42)                 ; => #f
```

---

### dict-keys-ordered {#dict-keys-ordered}

Return ordered keys vector (internal helper).

**Signature:** `(dict-keys-ordered dict)`

---

### dict-get {#dict-get}

Get value for key or default if missing.

**Signature:** `(dict-get dict key rest...)`

**Examples:**
```{arl}
(define d (dict :x 1 :y 2))
(dict-get d "x")           ; => 1
(dict-get d "z")           ; => #nil
(dict-get d "z" 99)        ; => 99  (default value)
```

**See also:** [dict-set](#dict-set), [dict-has?](#dict-has-p)

---

### dict-set {#dict-set}

Set key to value in dict and return dict.

**Signature:** `(dict-set dict key value)`

**Examples:**
```{arl}
(define d (dict))
(dict-set d "x" 42)        ; => d (mutated, x=42)
(dict-get d "x")           ; => 42
```

**See also:** [dict-get](#dict-get), [dict-remove](#dict-remove)

---

### dict-remove {#dict-remove}

Remove key from dict and return dict.

**Signature:** `(dict-remove dict key)`

**Examples:**
```{arl}
(define d (dict :x 1 :y 2))
(dict-remove d "x")        ; => d (mutated, x removed)
(dict-has? d "x")          ; => #f
```

**See also:** [dict-set](#dict-set)

---

### dict-keys {#dict-keys}

Return a list of dict keys.

**Signature:** `(dict-keys dict)`

**Examples:**
```{arl}
(define d (dict :x 1 :y 2))
(dict-keys d)              ; => ("x" "y")
(dict-keys (dict))         ; => ()
```

**See also:** [dict-values](#dict-values)

---

### dict-values {#dict-values}

Return a list of dict values.

**Signature:** `(dict-values dict)`

**Examples:**
```{arl}
(define d (dict :x 1 :y 2))
(dict-values d)            ; => (1 2)
```

**See also:** [dict-keys](#dict-keys)

---

### dict-has? {#dict-has-p}

Return #t if dict contains key.

**Signature:** `(dict-has? dict key)`

**Examples:**
```{arl}
(define d (dict :x 1 :y 2))
(dict-has? d "x")          ; => #t
(dict-has? d "z")          ; => #f
```

**See also:** [dict-get](#dict-get)

---

### dict-merge {#dict-merge}

Merge dicts, later values override earlier.

**Signature:** `(dict-merge dicts...)`

**Examples:**
```{arl}
(define a (dict :x 1 :y 2))
(define b (dict :y 99 :z 3))
(define m (dict-merge a b))
(dict-get m "y")           ; => 99  (b overrides a)
(dict-get m "z")           ; => 3
```

**See also:** [dict](#dict), [dict-set](#dict-set)

---

## Set (Hash-Backed) {#section-set-hash-backed}

Sets are mutable collections of unique items backed by R environments.
Any value can be a set element; uniqueness is determined by serialization.

### set-new {#set-new}

Create a new empty set environment.

**Signature:** `(set-new)`

---

### set-key {#set-key}

Convert value to string key for set storage via serialization.

**Signature:** `(set-key value)`

---

### set {#set}

Create a hash-backed set of unique items.

**Signature:** `(set args...)`

**Examples:**
```{arl}
(set 1 2 3)                ; => set of {1, 2, 3}
(set 1 1 2)                ; => set of {1, 2} (duplicates removed)
(set)                      ; => empty set
(set '(a b c))             ; => set from list
```

---

### set? {#set-p}

Return #t if x is a set.

**Signature:** `(set? x)`

**Examples:**
```{arl}
(set? (set 1 2))           ; => #t
(set? (list 1 2))          ; => #f
(set? 42)                  ; => #f
```

---

### set-add {#set-add}

Add item to set and return set.

**Signature:** `(set-add set item)`

**Examples:**
```{arl}
(define s (set 1 2))
(set-add s 3)              ; => s (mutated, now {1, 2, 3})
(set-contains? s 3)        ; => #t
```

**See also:** [set-remove](#set-remove)

---

### set-remove {#set-remove}

Remove item from set and return set.

**Signature:** `(set-remove set item)`

**Examples:**
```{arl}
(define s (set 1 2 3))
(set-remove s 2)           ; => s (mutated, now {1, 3})
(set-contains? s 2)        ; => #f
```

**See also:** [set-add](#set-add)

---

### set-contains? {#set-contains-p}

Return #t if set contains item.

**Signature:** `(set-contains? set item)`

**Examples:**
```{arl}
(define s (set 1 2 3))
(set-contains? s 2)        ; => #t
(set-contains? s 99)       ; => #f
```

---

### set-union {#set-union}

Return union of two sets.

**Signature:** `(set-union a b)`

**Examples:**
```{arl}
(define a (set 1 2 3))
(define b (set 3 4 5))
(define u (set-union a b))
(set-contains? u 1)        ; => #t
(set-contains? u 5)        ; => #t
```

**See also:** [set-intersection](#set-intersection), [set-difference](#set-difference)

---

### set-intersection {#set-intersection}

Return intersection of two sets.

**Signature:** `(set-intersection a b)`

**Examples:**
```{arl}
(define a (set 1 2 3))
(define b (set 2 3 4))
(define i (set-intersection a b))
(set-contains? i 2)        ; => #t
(set-contains? i 1)        ; => #f
```

**See also:** [set-union](#set-union), [set-difference](#set-difference)

---

### set-difference {#set-difference}

Return items in a that are not in b.

**Signature:** `(set-difference a b)`

**Examples:**
```{arl}
(define a (set 1 2 3))
(define b (set 2 3 4))
(define d (set-difference a b))
(set-contains? d 1)        ; => #t
(set-contains? d 2)        ; => #f
```

**See also:** [set-union](#set-union), [set-intersection](#set-intersection)

---

### set-copy-into {#set-copy-into}

Copy items from source into target (internal helper).

**Signature:** `(set-copy-into target source)`

---

## Struct Definition {#section-struct-definition}

### defstruct {#defstruct}

Define a struct constructor, predicate, and accessors.

**Signature:** `(defstruct name fields)`

**Examples:**
```{arl}
;; Define a Point struct
(defstruct Point (x y))

;; Constructor: make-Point
(define p (make-Point 3 4))

;; Predicate: Point?
(Point? p)                  ; => #t
(Point? 42)                 ; => #f

;; Accessors: Point-x, Point-y
(Point-x p)                 ; => 3
(Point-y p)                 ; => 4
```

**Note:** `defstruct` generates a constructor (`make-Name`), a type predicate (`Name?`), and field accessors (`Name-field`) for each field. The struct is backed by an R named list with an S3 class.

**See also:** [dict](#dict)

---

## Assertion Helpers {#section-assertion-helpers}

These functions provide test-style assertions that signal errors on failure
and return `#t` on success.

### assert {#assert}

Assert condition or raise error.

**Signature:** `(assert cond [msg "Assertion failed"])`

**Examples:**
```{arl, eval=FALSE}
(assert #t)               ; => #t
(assert (> 3 2))          ; => #t
(assert #f "must be true")  ; signals "must be true"
(assert #f)               ; signals "Assertion failed"
```

**See also:** [error](#error)

---

### assert-equal {#assert-equal}

Assert expected and actual are equal?.

**Signature:** `(assert-equal expected actual)`

**Examples:**
```{arl, eval=FALSE}
(assert-equal 3 (+ 1 2))  ; => #t
(assert-equal "a" "a")    ; => #t
(assert-equal 1 2)        ; signals error
```

**See also:** [assert-eq](#assert-eq), [assert-true](#assert-true)

---

### assert-true {#assert-true}

Assert value is truthy.

**Signature:** `(assert-true value)`

**Examples:**
```{arl, eval=FALSE}
(assert-true #t)          ; => #t
(assert-true 1)           ; => #t
(assert-true #f)          ; signals error
```

**See also:** [assert-false](#assert-false), [assert](#assert)

---

### assert-false {#assert-false}

Assert value is falsy.

**Signature:** `(assert-false value)`

**Examples:**
```{arl, eval=FALSE}
(assert-false #f)         ; => #t
(assert-false #nil)       ; => #t
(assert-false #t)         ; signals error
```

**See also:** [assert-true](#assert-true), [assert](#assert)

---

### assert-eq {#assert-eq}

Assert expected and actual are identical?.

**Signature:** `(assert-eq expected actual)`

**Examples:**
```{arl, eval=FALSE}
(define x '(1 2 3))
(assert-eq x x)           ; => #t (same object)
(assert-eq '(1) '(1))     ; signals error (not identical)
```

**Note:** Uses `identical?` (pointer equality), not `equal?` (structural equality). Use `assert-equal` for value comparison.

**See also:** [assert-equal](#assert-equal), [assert](#assert)

---

### assert-error {#assert-error}

Assert thunk throws an error.

**Signature:** `(assert-error thunk)`

**Examples:**
```{arl, eval=FALSE}
(assert-error (lambda () (error "boom")))   ; => #t
(assert-error (lambda () (/ 1 0)))           ; => #t
(assert-error (lambda () 42))                ; signals error
```

**See also:** [assert](#assert), [error](#error)

---

## Evaluation {#section-evaluation}

### eval {#eval}

Evaluate a Arl expression in the current environment.

**Signature:** `(eval expr)`

**Examples:**
```{arl}
(eval '(+ 1 2))           ; => 3
(eval '(list 1 2 3))      ; => (1 2 3)
```

**See also:** [r/eval](#r-eval), [read](#read), [macroexpand](#macroexpand)

---

### read {#read}

Parse a string into a Arl expression without evaluating it.

**Signature:** `(read source)`

**Examples:**
```{arl}
(read "(+ 1 2)")          ; => (+ 1 2) (unevaluated)
(read "42")               ; => 42
(read "foo")              ; => foo (symbol)
```

**Note:** Returns the first expression from the source string, or #nil if
the string contains no expressions. Like R's parse(), but returns Arl
S-expressions.

**See also:** [eval](#eval), [read-from-string](stdlib-strings-io.html#read-from-string)

---

### write {#write}

Convert a Arl expression to its string representation.
The inverse of read.

**Signature:** `(write expr)`

**Examples:**
```{arl}
(write '(+ 1 2))          ; => "(+ 1 2)"
(write 42)                ; => "42"
(write "hello")           ; => "\"hello\""
(write #t)                ; => "#t"
```

**Note:** Produces output that can be parsed back with read, ensuring the
round-trip property: (read (write expr)) equals expr for any expression
produced by read.

**See also:** [read](#read), [eval](#eval), [format-value](stdlib-strings-io.html#format-value)

---

### r/eval {#r-eval}

Evaluate an R expression directly via R's eval(), bypassing
Arl's compiler.

**Signature:** `(r/eval expr)`

**Examples:**
```{arl}
(r/eval (quote (seq_len 5)))  ; => c(1, 2, 3, 4, 5)
```

**Note:** Useful for evaluating raw R calls that use R control flow (for,
while) or other constructs that Arl normally overrides.

**See also:** [eval](#eval), [r/call](#r-call)

---

## Macro Utilities {#section-macro-utilities}

### capture {#capture}

Mark a symbol for intentional capture in a macro body,
overriding hygiene.

**Signature:** `(capture 'sym expr)`

**Examples:**
```{arl}
(defmacro aif (test then alt)
`(let ((it ,test))
(if it ,(capture 'it then) ,(capture 'it alt))))
(aif (+ 2 3) it 0)          ; => 5
```

**Note:** Use capture when writing anaphoric macros or other macros that
intentionally introduce a binding visible to the caller. Without
capture, Arl's automatic hygiene renames macro-introduced symbols to
prevent accidental capture.

**See also:** [gensym](#gensym), [macroexpand](#macroexpand), defmacro

---

### gensym {#gensym}

Generate a unique uninterned symbol, useful for writing
hygienic macros.

**Signature:** `(gensym [prefix])`

**Examples:**
```{arl}
(gensym)                  ; => G1 (unique symbol)
(gensym "tmp")            ; => tmp2 (unique with prefix)
```

**Note:** Each call returns a fresh symbol guaranteed not to conflict with
user-defined names. The optional prefix defaults to "G".

**See also:** [macroexpand](#macroexpand), [macroexpand-1](#macroexpand-1)

---

### macro? {#macro-p}

Return #t if the symbol names a currently-defined macro.

**Signature:** `(macro? sym)`

**Examples:**
```{arl}
(defmacro my-mac (x) x)
(macro? 'my-mac)          ; => #t
(macro? 'car)             ; => #f
```

---

### macroexpand {#macroexpand}

Recursively expand all macros in expr until no macro calls
remain.

**Signature:** `(macroexpand expr)`

**Examples:**
```{arl}
(defmacro my-when (test body)
`(if ,test ,body #nil))
(macroexpand '(my-when #t 42))  ; => (if #t 42 #nil)
```

**Note:** Also available as `macroexpand-all` (alias).

**See also:** [macroexpand-1](#macroexpand-1), [macro?](#macro-p), [gensym](#gensym)

---

### macroexpand-1 {#macroexpand-1}

Expand only the outermost macro call in expr (one step).

**Signature:** `(macroexpand-1 expr)`

**Examples:**
```{arl}
(defmacro my-when (test body)
`(if ,test ,body #nil))
(macroexpand-1 '(my-when #t 42))  ; => (if #t 42 #nil)
```

**See also:** [macroexpand](#macroexpand), [macro?](#macro-p)

---

## Promises (Lazy Evaluation) {#section-promises-lazy-evaluation}

### promise? {#promise-p}

Return #t if x is a promise (created with `delay`).

**Signature:** `(promise? x)`

**Examples:**
```{arl}
(define p (delay (+ 1 2)))
(promise? p)              ; => #t
(promise? 42)             ; => #f
```

**See also:** [force](#force), [promise-expr](#promise-expr)

---

### force {#force}

Force a promise, evaluating its delayed expression and
returning the result. If x is not a promise, returns x unchanged.

**Signature:** `(force x)`

**Examples:**
```{arl}
(define p (delay (+ 1 2)))
(force p)                 ; => 3
(force 42)                ; => 42 (non-promise passed through)
```

**See also:** [promise?](#promise-p), [promise-expr](#promise-expr), delay

---

### promise-expr {#promise-expr}

Extract the unevaluated expression from a promise.

**Signature:** `(promise-expr p)`

**Examples:**
```{arl}
(define p (delay (+ 1 2)))
(promise-expr p)          ; => (+ 1 2)
```

**Note:** Signals an error if p is not a promise.

**See also:** [promise?](#promise-p), [force](#force), delay

---

## Environment Introspection {#section-environment-introspection}

### toplevel-env {#toplevel-env}

Return the top-level environment (the environment where all
standard library bindings live).

**Signature:** `(toplevel-env)`

**Examples:**
```{arl}
(environment? (toplevel-env))  ; => #t
```

**See also:** [current-env](#current-env)

---

### current-env {#current-env}

Return the current Arl evaluation environment.

**Signature:** `(current-env)`

**Examples:**
```{arl}
(environment? (current-env))  ; => #t
```

**See also:** [toplevel-env](#toplevel-env)

---

## Documentation Helpers {#section-documentation-helpers}

### doc! {#doc-bang}

Attach documentation fields to a function. With a single
string argument, sets the description (backward compatible). With keyword
arguments, sets specific fields and merges with existing documentation.

**Signature:** `(doc! fn "docstring") or (doc! fn :description "..." :examples "...")`

**Examples:**
```{arl, eval=FALSE}
(doc! my-fn "Doubles the input.")
(doc! my-fn :examples "(my-fn 3) ; => 6")
(doc! my-fn :description "Doubles." :note "Fast path.")
```

**See also:** [doc](#doc), help

---

### doc {#doc}

Retrieve documentation from a function. With no field argument,
returns the description. Pass a field name string to get a specific field,
or "all" to get the full documentation list.

**Signature:** `(doc fn) or (doc fn "field")`

**Examples:**
```{arl, eval=FALSE}
(doc my-fn)              ; => "Doubles the input."
(doc my-fn "examples")   ; => "(my-fn 3) ; => 6"
(doc my-fn "all")        ; => named list of all fields
```

**See also:** [doc!](#doc-bang), help

---

