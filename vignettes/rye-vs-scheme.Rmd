---
title: "Rye Compared to Scheme"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Rye Compared to Scheme}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Rye is a Lisp dialect implemented in and with access to R. It borrows Lisp
syntax and macro conventions, but its runtime model and interop are rooted in R.
This vignette highlights key similarities with Scheme and the most important
differences.

## Common ground

Rye and Scheme share a Lisp-family surface syntax and several familiar ideas:

- **S-expressions**: code and data use the same list syntax.
- **Homoiconic macros**: `defmacro` plus quasiquote/unquote are central.
- **First-class functions**: anonymous functions and higher-order patterns are
  idiomatic.
- **Lexical scoping**: bindings are local by default and resolve predictably.

## Core differences

The main differences come from Rye leaning on R’s runtime:

### Evaluation model

Rye evaluates expressions via R’s `eval()` and environments. That means:

- R’s base functions are available without importing.
- R’s evaluation and error semantics apply under the hood.

### Data model

Scheme has pairs and lists as the fundamental sequence type. Rye uses R data
structures:

- Lists are R lists or calls (R's type-generic vectors).
- Rye also has dotted pairs (pairlist cells, `pair?`); `list-or-pair?` is true for non-empty lists or dotted pairs.
- Vectors are R vectors.
- `#nil` maps to R’s `NULL`.

### Truthiness

Scheme typically treats only `#f` as false. Rye treats `#f`/`FALSE`,
`#nil`/`NULL`, and `0` as falsey; everything else is truthy.

### Numeric edge cases (R semantics)

Rye mirrors R's numeric behavior rather than Scheme's in several edge cases:

- **Division by zero**: `(/ 1 0)` yields `Inf` (and `(/ -1 0)` yields `-Inf`) instead of raising an error.
- **NaN comparisons**: `(== NaN NaN)` yields `NA` rather than `#f`, due to R's `NA` propagation rules.

This is intentional for R interop, but it is a meaningful semantic difference
from Scheme. Prefer predicates like `is.infinite`, `is.nan`, and `is.na` when
you need to branch on these values.

```lisp
(/ 1 0)         ; => Inf
(== NaN NaN)    ; => NA
(is.infinite (/ 1 0))  ; => TRUE
(is.na (== NaN NaN))   ; => TRUE
```

### Numeric Tower Differences

Rye implements a numeric tower similar to Scheme's, but adapted for R's type system:

```
number?    (is.numeric OR is.complex)
├─ complex?  (is.complex)
└─ real?     (is.numeric AND NOT is.complex)
   ├─ ±Inf   (real but not rational)
   └─ rational? (real? AND is.finite)
      └─ integer? (is.finite AND is.numeric AND x == as.integer(x))
         └─ natural? (integer? AND x >= 0)

Orthogonal predicates:
exact?   (is.integer - storage type)
inexact? (number? AND NOT is.integer)
```

**Key differences from Scheme:**

1. R doesn't distinguish exact rationals from inexact reals - all are IEEE 754 floats
2. `rational?` means "finite real" in Rye (since all finite floats are rationally representable)
3. `exact?` checks storage type (integer vs. double), not mathematical exactness
4. All complex numbers in R are inexact (double-precision)

**Infinities and special values:**

```lisp
(real? Inf)       ; => #t (infinities are real)
(rational? Inf)   ; => #f (but not rational)
(finite? Inf)     ; => #f
(real? NaN)       ; => #t
(finite? NaN)     ; => #f
```

### Keywords and named arguments

Rye keywords (`:from`, `:to`) are self-evaluating and map to **named arguments**
in R calls. This is a major ergonomic difference from Scheme.

### Tail-call optimization

Scheme mandates full tail-call optimization (proper tail calls). Rye implements
**self-TCO**: the compiler detects `(define name (lambda ...))` where the lambda
body has self-calls in tail position and rewrites them as `while` loops. This
covers tail calls through `if`, `begin`, `cond`, `let`, `let*`, and `letrec`.

What is **not** covered:

- **Mutual recursion** (`f` calls `g` in tail position, `g` calls `f`).
- **`apply`-based tail calls** or indirect calls through higher-order functions.
- **Anonymous lambdas** (no name for the compiler to detect self-calls against).

Like Scheme's proper tail calls, self-TCO elides recursive stack frames: on
error inside an optimized function, only the outermost call appears in the
stack trace rather than the full chain of recursive calls.

For cases not covered by self-TCO, use `loop`/`recur` for explicit
tail-recursive patterns.

```lisp
;; Self-TCO optimizes this automatically
(define factorial
  (lambda (n acc)
    (if (< n 2) acc
        (factorial (- n 1) (* acc n)))))

;; loop/recur for explicit control
(import looping)
(loop ((i 10) (acc 1))
  (if (< i 2) acc
      (recur (- i 1) (* acc i))))
```

### Interop

Rye can call R functions directly:

```lisp
(mean (c 1 2 3 4 5))
(seq :from 1 :to 10 :by 2)
```

Scheme code typically requires FFI layers for such interop; Rye treats it as
normal function application.

## Special forms and macros

Many familiar special forms exist (`quote`, `if`, `define`, `lambda`, `begin`),
but there are Rye-specific forms (`~`, `::`, `:::`) and macro helpers tuned for
R interop.

## When to think “Scheme” vs “R”

- **Think Scheme** for macro structure and list processing patterns.
- **Think R** for data frames, formulas, statistical modeling, and named
  argument calls.

## Related guides

- [Getting Started](getting-started.html)
- [Macros and Quasiquote](macros.html)
- [R Interop and Data Workflows](r-interop.html)
