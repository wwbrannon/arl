---
title: "Standard Library: Lists and Sequences"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library: Lists and Sequences}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- AUTO-GENERATED from inst/arl/ source files. Do not edit manually. -->
<!-- Regenerate with: make stdlib-docs -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

## List Operations {#section-list-operations}

Core list constructors and accessors, following Scheme conventions.
Lists in Arl are backed by R lists; `car`/`cdr` provide the fundamental
decomposition and `cons` the fundamental construction.

### call {#call}

Convert a list to a callable form.

**Signature:** `(call lst)`

**Examples:**
```lisp
(call (list '+ 1 2))  ; => language: (+ 1 2)
```

**See also:** [eval](stdlib-macro-eval-interop.html#eval), apply

---

### car {#car}

Return first element or #nil.

**Signature:** `(car lst)`

**Examples:**
```lisp
(car (list 1 2 3))    ; => 1
(car (list))           ; => #nil
(car (cons 'a 'b))    ; => a
```

**See also:** [cdr](#cdr), [cons](#cons), [first](#first)

---

### cdr {#cdr}

Return list without first element (or cdr of dotted pair).

**Signature:** `(cdr lst)`

**Examples:**
```lisp
(cdr (list 1 2 3))    ; => (2 3)
(cdr (list 1))        ; => ()
(cdr (cons 'a 'b))    ; => b
```

**See also:** [car](#car), [cons](#cons), [rest](#rest)

---

### caar {#caar}

car of car.

**Signature:** `(caar x)`

---

### cadr {#cadr}

car of cdr.

**Signature:** `(cadr x)`

---

### cdar {#cdar}

cdr of car.

**Signature:** `(cdar x)`

---

### cddr {#cddr}

cdr of cdr.

**Signature:** `(cddr x)`

---

### caaar {#caaar}

car of car of car.

**Signature:** `(caaar x)`

---

### caadr {#caadr}

car of car of cdr.

**Signature:** `(caadr x)`

---

### cadar {#cadar}

car of cdr of car.

**Signature:** `(cadar x)`

---

### caddr {#caddr}

car of cdr of cdr.

**Signature:** `(caddr x)`

---

### cdaar {#cdaar}

cdr of car of car.

**Signature:** `(cdaar x)`

---

### cdadr {#cdadr}

cdr of car of cdr.

**Signature:** `(cdadr x)`

---

### cddar {#cddar}

cdr of cdr of car.

**Signature:** `(cddar x)`

---

### cdddr {#cdddr}

cdr of cdr of cdr.

**Signature:** `(cdddr x)`

---

### cadddr {#cadddr}

car of cdr of cdr of cdr.

**Signature:** `(cadddr x)`

---

### cddddr {#cddddr}

cdr of cdr of cdr of cdr.

**Signature:** `(cddddr x)`

---

### cons {#cons}

Prepend item to list or call; dotted pair when cdr is not a list.

**Signature:** `(cons item lst)`

**Examples:**
```lisp
(cons 1 (list 2 3))   ; => (1 2 3)
(cons 'a (list 'b))   ; => (a b)
(cons 'a 'b)          ; => dotted pair (a . b)
```

**See also:** [car](#car), [cdr](#cdr), [append](#append)

---

### list* {#list-star}

Build list ending with last arg.

**Signature:** `(list* args...)`

**Examples:**
```lisp
(list* 1 2 (list 3 4))  ; => (1 2 3 4)
(list* 1 2 3)           ; => (1 2 3)
(list*)                  ; => ()
```

**See also:** list, [cons](#cons), [append](#append)

---

### append {#append}

Concatenate multiple lists into one.

**Signature:** `(append lists...)`

**Examples:**
```lisp
(append (list 1 2) (list 3 4))    ; => (1 2 3 4)
(append (list 1) (list 2) (list 3)); => (1 2 3)
(append (list 1 2) (list))         ; => (1 2)
```

**See also:** [cons](#cons), [list*](#list-star)

---

### reverse {#reverse}

Reverse list.

**Signature:** `(reverse x)`

**Examples:**
```lisp
(reverse (list 1 2 3))  ; => (3 2 1)
(reverse (list))        ; => ()
```

---

### first {#first}

Alias for car.

**Signature:** `(first lst)`

**See also:** [car](#car), [rest](#rest), [last](#last)

---

### second {#second}

Return second element or #nil.

**Signature:** `(second lst)`

---

### third {#third}

Return third element or #nil.

**Signature:** `(third lst)`

---

### fourth {#fourth}

Return fourth element or #nil.

**Signature:** `(fourth lst)`

---

### rest {#rest}

Alias for cdr.

**Signature:** `(rest lst)`

**See also:** [cdr](#cdr), [first](#first)

---

### last {#last}

Return last item or #nil.

**Signature:** `(last lst)`

**Examples:**
```lisp
(last (list 1 2 3))   ; => 3
(last (list 42))      ; => 42
(last (list))         ; => #nil
```

**See also:** [first](#first), [nth](#nth)

---

### nth {#nth}

Return nth item (0-based).

**Signature:** `(nth lst n)`

**Examples:**
```lisp
(nth (list 'a 'b 'c) 0)  ; => a
(nth (list 'a 'b 'c) 2)  ; => c
```

**See also:** [first](#first), [last](#last)

---

## Association Lists {#section-association-lists}

Association lists (alists) map keys to values. Each entry is a list
whose `car` is the key and whose `cadr` is the value. `assoc` and
friends search by key; `rassoc` searches by value.

### assoc {#assoc}

Find first alist entry (list or dotted pair) with matching key (uses equal?).

**Signature:** `(assoc key alist)`

**Examples:**
```lisp
(assoc 'b (list (list 'a 1) (list 'b 2) (list 'c 3)))  ; => (b 2)
(assoc 'z (list (list 'a 1) (list 'b 2)))               ; => #nil
```

**See also:** [rassoc](#rassoc), [assoc-by-identical?](#assoc-by-identical-p), [assoc-by-==](#assoc-by-eq-eq)

---

### assoc-by-equal? {#assoc-by-equal-p}

Alias for assoc: find first alist entry with key matching under equal?.

**Signature:** `(assoc-by-equal? key alist)`

**See also:** [assoc](#assoc)

---

### assoc-by-identical? {#assoc-by-identical-p}

Find first alist entry with matching key (uses R's identical?).

**Signature:** `(assoc-by-identical? key alist)`

**See also:** [assoc](#assoc), [assoc-by-==](#assoc-by-eq-eq)

---

### assoc-by-== {#assoc-by-eq-eq}

Find first alist entry with matching key (uses R's ==).

**Signature:** `(assoc-by-== key alist)`

**See also:** [assoc](#assoc), [assoc-by-identical?](#assoc-by-identical-p)

---

### assq {#assq}

assq cannot be properly implemented in R (no eq?).
Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead.

**Signature:** `(assq key alist)`

**Note:** assq cannot be properly implemented in R (no eq?). Use assoc, assoc-by-identical?, or assoc-by-== instead.

---

### assv {#assv}

assv cannot be properly implemented in R (no eqv?).
Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead.

**Signature:** `(assv key alist)`

**Note:** assv cannot be properly implemented in R (no eqv?). Use assoc, assoc-by-identical?, or assoc-by-== instead.

---

### rassoc {#rassoc}

Find first alist entry with matching value
(searches cdr of entries; uses equal?).

**Signature:** `(rassoc value alist)`

**Examples:**
```lisp
(rassoc 2 (list (list 'a 1) (list 'b 2) (list 'c 3)))  ; => (b 2)
(rassoc 9 (list (list 'a 1) (list 'b 2)))               ; => #nil
```

**See also:** [assoc](#assoc), [rassoc-by-equal?](#rassoc-by-equal-p)

---

### rassoc-by-equal? {#rassoc-by-equal-p}

Alias for rassoc: find first alist entry with value matching under equal?.

**Signature:** `(rassoc-by-equal? value alist)`

**See also:** [rassoc](#rassoc)

---

## List Generation {#section-list-generation}

Utilities for creating lists of numbers or repeated values.

### range {#range}

Generate numeric range from start to end (exclusive) with optional step.

**Signature:** `(range start end step-args...)`

**Examples:**
```lisp
(range 0 5)       ; => (0 1 2 3 4)
(range 0 10 2)    ; => (0 2 4 6 8)
(range 5 0 -1)    ; => (5 4 3 2 1)
```

**See also:** [iota](#iota), [make-list](#make-list)

---

### iota {#iota}

Generate sequence of count numbers starting from
start (default 0) with step (default 1).

**Signature:** `(iota count args...)`

**Examples:**
```lisp
(iota 5)          ; => (0 1 2 3 4)
(iota 5 1)        ; => (1 2 3 4 5)
(iota 5 0 2)      ; => (0 2 4 6 8)
```

**See also:** [range](#range), [make-list](#make-list)

---

### make-list {#make-list}

Create list of n copies of value.

**Signature:** `(make-list n value)`

**Examples:**
```lisp
(make-list 3 'x)    ; => (x x x)
(make-list 0 'x)    ; => ()
```

**See also:** [iota](#iota), [range](#range)

---

## Additional List Accessors {#section-additional-list-accessors}

### list-ref {#list-ref}

Scheme-style list accessor (alias for nth).

**Signature:** `(list-ref lst index)`

**Examples:**
```lisp
(list-ref (list 'a 'b 'c) 1)  ; => b
```

**See also:** [nth](#nth)

---

### list-tail {#list-tail}

Return list without first k elements.

**Signature:** `(list-tail lst k)`

**Examples:**
```lisp
(list-tail (list 'a 'b 'c 'd) 2)  ; => (c d)
(list-tail (list 1 2 3) 0)         ; => (1 2 3)
```

**See also:** [drop](#drop)

---

## Sequence Helpers {#section-sequence-helpers}

Higher-level operations for slicing, chunking, and transforming
sequences. These complement the core list operations in the `list`
module with lazy-style idioms common in functional programming.

### take {#take}

Take first n items.

**Signature:** `(take n lst)`

**Examples:**
```lisp
(take 3 (list 1 2 3 4 5))  ; => (1 2 3)
(take 0 (list 1 2 3))      ; => ()
(take 10 (list 1 2))       ; => (1 2)
```

**See also:** [drop](#drop), [take-while](#take-while)

---

### drop {#drop}

Drop first n items.

**Signature:** `(drop n lst)`

**Examples:**
```lisp
(drop 2 (list 1 2 3 4 5))  ; => (3 4 5)
(drop 0 (list 1 2 3))      ; => (1 2 3)
(drop 10 (list 1 2))       ; => ()
```

**See also:** [take](#take), [drop-while](#drop-while)

---

### take-while {#take-while}

Take items while predicate is true.

**Signature:** `(take-while pred lst)`

**Examples:**
```lisp
(take-while odd? (list 1 3 5 2 4))   ; => (1 3 5)
(take-while even? (list 1 2 3))       ; => ()
```

**See also:** [take](#take), [drop-while](#drop-while), [filter](stdlib-functional.html#filter)

---

### drop-while {#drop-while}

Drop items while predicate is true.

**Signature:** `(drop-while pred lst)`

**Examples:**
```lisp
(drop-while odd? (list 1 3 5 2 4))   ; => (2 4)
(drop-while even? (list 1 2 3))       ; => (1 2 3)
```

**See also:** [drop](#drop), [take-while](#take-while), [filter](stdlib-functional.html#filter)

---

### partition {#partition}

Split list into chunks of size n.

**Signature:** `(partition n lst [step n])`

**Examples:**
```lisp
(partition 2 (list 1 2 3 4 5 6))       ; => ((1 2) (3 4) (5 6))
(partition 3 (list 1 2 3 4 5 6) 2)     ; => ((1 2 3) (3 4 5))
(partition 2 (list 1 2 3 4 5))          ; => ((1 2) (3 4))
```

**See also:** [take](#take), [drop](#drop)

---

### flatten {#flatten}

Flatten nested lists.

**Signature:** `(flatten lst)`

**Examples:**
```lisp
(flatten (list 1 (list 2 3) (list 4 (list 5))))  ; => (1 2 3 4 5)
(flatten (list 1 2 3))                            ; => (1 2 3)
```

**See also:** [mapcat](stdlib-functional.html#mapcat), [append](#append)

---

### repeatedly {#repeatedly}

Call fn n times collecting results.

**Signature:** `(repeatedly n fn)`

**Examples:**
```lisp
(repeatedly 3 (lambda () 42))  ; => (42 42 42)
```

**See also:** [repeat](#repeat), [map](stdlib-functional.html#map)

---

### repeat {#repeat}

Repeat value n times.

**Signature:** `(repeat n value)`

**Examples:**
```lisp
(repeat 4 'x)   ; => (x x x x)
(repeat 3 0)     ; => (0 0 0)
```

**See also:** [repeatedly](#repeatedly)

---

### zip {#zip}

Zip lists into list of tuples.

**Signature:** `(zip lists...)`

**Examples:**
```lisp
(zip (list 1 2 3) (list 'a 'b 'c))          ; => ((1 a) (2 b) (3 c))
(zip (list 1 2) (list 'a 'b) (list 'x 'y))  ; => ((1 a x) (2 b y))
```

**See also:** [map](stdlib-functional.html#map)

---

### member {#member}

Return sublist of lst starting at first element
equal to x, or #f if not found. Uses equal? by default;
pass :use-identical #t for R's identical().

**Signature:** `(member x lst [use-identical #f])`

---

### contains? {#contains-p}

Return #t if lst contains element equal to x.

**Signature:** `(contains? x lst)`

---

## Length Predicates {#section-length-predicates}

Efficient length comparisons that short-circuit when possible.

### length= {#length-eq}

Return #t if length of x equals n.

**Signature:** `(length= x n)`

**Examples:**
```lisp
(length= (list 1 2 3) 3)  ; => #t
(length= (list 1 2) 3)    ; => #f
```

**See also:** [length>](#length-gt), [length<](#length-lt), [empty?](stdlib-types.html#empty-p)

---

### length> {#length-gt}

Return #t if length of x is greater than n.

**Signature:** `(length> x n)`

**Examples:**
```lisp
(length> (list 1 2 3) 2)  ; => #t
(length> (list 1 2) 3)    ; => #f
```

**See also:** [length=](#length-eq), [length<](#length-lt)

---

### length< {#length-lt}

Return #t if length of x is less than n.

**Signature:** `(length< x n)`

**Examples:**
```lisp
(length< (list 1 2) 3)    ; => #t
(length< (list 1 2 3) 2)  ; => #f
```

**See also:** [length=](#length-eq), [length>](#length-gt)

---

## Sorting {#section-sorting}

General-purpose sorting with user-supplied comparator functions.
`sort` uses quicksort (not stable); `stable-sort` uses merge sort
and preserves the relative order of equal elements. `merge` combines
two already-sorted lists.

### sort {#sort}

Sort list using comparison function (simple quicksort implementation).

**Signature:** `(sort lst comparator)`

**Examples:**
```lisp
(sort (list 3 1 4 1 5) <)        ; => (1 1 3 4 5)
(sort (list "b" "a" "c") string<); => ("a" "b" "c")
```

**See also:** [stable-sort](#stable-sort), [sort-by](#sort-by)

---

### sort-by {#sort-by}

Sort list by applying key-fn to each element, then comparing.

**Signature:** `(sort-by lst key-fn comparator)`

**Examples:**
```lisp
(sort-by (list (list "b" 2) (list "a" 1)) car string<)  ; => (("a" 1) ("b" 2))
(sort-by (list 3 -1 2) abs <)                            ; => (-1 2 3)
```

**See also:** [sort](#sort), [stable-sort](#stable-sort)

---

### merge {#merge}

Merge two sorted lists into one sorted list.
Stable: when elements are equal (neither comparator direction
is true), takes from list1 first.

**Signature:** `(merge list1 list2 comparator)`

**Examples:**
```lisp
(merge (list 1 3 5) (list 2 4 6) <)  ; => (1 2 3 4 5 6)
(merge (list 1 2) (list) <)           ; => (1 2)
```

**See also:** [stable-sort](#stable-sort), [sort](#sort)

---

### stable-sort {#stable-sort}

Stable sort - preserves order of equal elements. Uses merge sort internally.

**Signature:** `(stable-sort lst comparator)`

**Examples:**
```lisp
(stable-sort (list 3 1 4 1 5) <)  ; => (1 1 3 4 5)
```

**Note:** Preserves the relative order of elements that compare equal, unlike `sort`.

**See also:** [sort](#sort), [merge](#merge), [sort-by](#sort-by)

---

