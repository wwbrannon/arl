---
title: "Standard Library: Lists and Sequences"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library: Lists and Sequences}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- AUTO-GENERATED from inst/rye/ source files. Do not edit manually. -->
<!-- Regenerate with: make stdlib-docs -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

## List Operations

Core list constructors and accessors, following Scheme conventions.
Lists in Rye are backed by R lists; `car`/`cdr` provide the fundamental
decomposition and `cons` the fundamental construction.

### __as-list

Coerce calls and vectors to list; dotted pair to proper prefix.

**Signature:** `(__as-list x)`

---

### call

Convert a list to a callable form.

**Signature:** `(call lst)`

**Examples:**
```lisp
(call (list '+ 1 2))  ; => language: (+ 1 2)
```

**See also:** eval, apply

---

### car

Return first element or #nil.

**Signature:** `(car lst)`

**Examples:**
```lisp
(car (list 1 2 3))    ; => 1
(car (list))           ; => #nil
(car (cons 'a 'b))    ; => a
```

**See also:** cdr, cons, first

---

### cdr

Return list without first element (or cdr of dotted pair).

**Signature:** `(cdr lst)`

**Examples:**
```lisp
(cdr (list 1 2 3))    ; => (2 3)
(cdr (list 1))        ; => ()
(cdr (cons 'a 'b))    ; => b
```

**See also:** car, cons, rest

---

### cons

Prepend item to list or call; dotted pair when cdr is not a list.

**Signature:** `(cons item lst)`

**Examples:**
```lisp
(cons 1 (list 2 3))   ; => (1 2 3)
(cons 'a (list 'b))   ; => (a b)
(cons 'a 'b)          ; => dotted pair (a . b)
```

**See also:** car, cdr, append

---

### list*

Build list ending with last arg.

**Signature:** `(list* args...)`

**Examples:**
```lisp
(list* 1 2 (list 3 4))  ; => (1 2 3 4)
(list* 1 2 3)           ; => (1 2 3)
(list*)                  ; => ()
```

**See also:** list, cons, append

---

### append

Concatenate multiple lists into one.

**Signature:** `(append lists...)`

**Examples:**
```lisp
(append (list 1 2) (list 3 4))    ; => (1 2 3 4)
(append (list 1) (list 2) (list 3)); => (1 2 3)
(append (list 1 2) (list))         ; => (1 2)
```

**See also:** cons, list*

---

### reverse

Reverse list.

**Signature:** `(reverse x)`

**Examples:**
```lisp
(reverse (list 1 2 3))  ; => (3 2 1)
(reverse (list))        ; => ()
```

---

### first

Alias for car.

**Signature:** `(first lst)`

**See also:** car, rest, last

---

### rest

Alias for cdr.

**Signature:** `(rest lst)`

**See also:** cdr, first

---

### last

Return last item or #nil.

**Signature:** `(last lst)`

**Examples:**
```lisp
(last (list 1 2 3))   ; => 3
(last (list 42))      ; => 42
(last (list))         ; => #nil
```

**See also:** first, nth

---

### nth

Return nth item (0-based).

**Signature:** `(nth lst n)`

**Examples:**
```lisp
(nth (list 'a 'b 'c) 0)  ; => a
(nth (list 'a 'b 'c) 2)  ; => c
```

**See also:** first, last

---

## Association Lists

Association lists (alists) map keys to values. Each entry is a list
whose `car` is the key and whose `cadr` is the value. `assoc` and
friends search by key; `rassoc` searches by value.

### __r==-pred

Wrap R's == to handle vector results; returns #t only if all elements match.

**Signature:** `(__r==-pred a b)`

---

### assoc

Find first alist entry (list or dotted pair) with matching key (uses equal?).

**Signature:** `(assoc key alist)`

**Examples:**
```lisp
(assoc 'b (list (list 'a 1) (list 'b 2) (list 'c 3)))  ; => (b 2)
(assoc 'z (list (list 'a 1) (list 'b 2)))               ; => #nil
```

**See also:** rassoc, assoc-by-identical?, assoc-by-==

---

### assoc-by-equal?

Alias for assoc: find first alist entry with key matching under equal?.

**Signature:** `(assoc-by-equal? key alist)`

**See also:** assoc

---

### assoc-by-identical?

Find first alist entry with matching key (uses R's identical?).

**Signature:** `(assoc-by-identical? key alist)`

**See also:** assoc, assoc-by-==

---

### assoc-by-==

Find first alist entry with matching key (uses R's ==).

**Signature:** `(assoc-by-== key alist)`

**See also:** assoc, assoc-by-identical?

---

### assq

assq cannot be properly implemented in R (no eq?). Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead.

**Signature:** `(assq key alist)`

**Note:** assq cannot be properly implemented in R (no eq?). Use assoc, assoc-by-identical?, or assoc-by-== instead.

---

### assv

assv cannot be properly implemented in R (no eqv?). Use assoc (equal?), assoc-by-identical?, or assoc-by-== instead.

**Signature:** `(assv key alist)`

**Note:** assv cannot be properly implemented in R (no eqv?). Use assoc, assoc-by-identical?, or assoc-by-== instead.

---

### rassoc

Find first alist entry with matching value (searches cdr of entries; uses equal?).

**Signature:** `(rassoc value alist)`

**Examples:**
```lisp
(rassoc 2 (list (list 'a 1) (list 'b 2) (list 'c 3)))  ; => (b 2)
(rassoc 9 (list (list 'a 1) (list 'b 2)))               ; => #nil
```

**See also:** assoc, rassoc-by-equal?

---

### rassoc-by-equal?

Alias for rassoc: find first alist entry with value matching under equal?.

**Signature:** `(rassoc-by-equal? value alist)`

**See also:** rassoc

---

## List Generation

Utilities for creating lists of numbers or repeated values.

### range

Generate numeric range from start to end (exclusive) with optional step.

**Signature:** `(range start end step-args...)`

**Examples:**
```lisp
(range 0 5)       ; => (0 1 2 3 4)
(range 0 10 2)    ; => (0 2 4 6 8)
(range 5 0 -1)    ; => (5 4 3 2 1)
```

**See also:** iota, make-list

---

### iota

Generate sequence of count numbers starting from start (default 0) with step (default 1).

**Signature:** `(iota count args...)`

**Examples:**
```lisp
(iota 5)          ; => (0 1 2 3 4)
(iota 5 1)        ; => (1 2 3 4 5)
(iota 5 0 2)      ; => (0 2 4 6 8)
```

**See also:** range, make-list

---

### make-list

Create list of n copies of value.

**Signature:** `(make-list n value)`

**Examples:**
```lisp
(make-list 3 'x)    ; => (x x x)
(make-list 0 'x)    ; => ()
```

**See also:** iota, range

---

## Additional List Accessors

### list-ref

Scheme-style list accessor (alias for nth).

**Signature:** `(list-ref lst index)`

**Examples:**
```lisp
(list-ref (list 'a 'b 'c) 1)  ; => b
```

**See also:** nth

---

### list-tail

Return list without first k elements.

**Signature:** `(list-tail lst k)`

**Examples:**
```lisp
(list-tail (list 'a 'b 'c 'd) 2)  ; => (c d)
(list-tail (list 1 2 3) 0)         ; => (1 2 3)
```

**See also:** drop

---

## Sequence Helpers

Higher-level operations for slicing, chunking, and transforming
sequences. These complement the core list operations in the `list`
module with lazy-style idioms common in functional programming.

### take

Take first n items.

**Signature:** `(take n lst)`

**Examples:**
```lisp
(take 3 (list 1 2 3 4 5))  ; => (1 2 3)
(take 0 (list 1 2 3))      ; => ()
(take 10 (list 1 2))       ; => (1 2)
```

**See also:** drop, take-while

---

### drop

Drop first n items.

**Signature:** `(drop n lst)`

**Examples:**
```lisp
(drop 2 (list 1 2 3 4 5))  ; => (3 4 5)
(drop 0 (list 1 2 3))      ; => (1 2 3)
(drop 10 (list 1 2))       ; => ()
```

**See also:** take, drop-while

---

### take-while

Take items while predicate is true.

**Signature:** `(take-while pred lst)`

**Examples:**
```lisp
(take-while odd? (list 1 3 5 2 4))   ; => (1 3 5)
(take-while even? (list 1 2 3))       ; => ()
```

**See also:** take, drop-while, filter

---

### drop-while

Drop items while predicate is true.

**Signature:** `(drop-while pred lst)`

**Examples:**
```lisp
(drop-while odd? (list 1 3 5 2 4))   ; => (2 4)
(drop-while even? (list 1 2 3))       ; => (1 2 3)
```

**See also:** drop, take-while, filter

---

### partition

**Signature:** `(partition n lst [step n])`

**Examples:**
```lisp
(partition 2 (list 1 2 3 4 5 6))       ; => ((1 2) (3 4) (5 6))
(partition 3 (list 1 2 3 4 5 6) 2)     ; => ((1 2 3) (3 4 5))
(partition 2 (list 1 2 3 4 5))          ; => ((1 2) (3 4))
```

**See also:** take, drop

---

### flatten

Flatten nested lists.

**Signature:** `(flatten lst)`

**Examples:**
```lisp
(flatten (list 1 (list 2 3) (list 4 (list 5))))  ; => (1 2 3 4 5)
(flatten (list 1 2 3))                            ; => (1 2 3)
```

**See also:** mapcat, append

---

### repeatedly

Call fn n times collecting results.

**Signature:** `(repeatedly n fn)`

**Examples:**
```lisp
(repeatedly 3 (lambda () 42))  ; => (42 42 42)
```

**See also:** repeat, map

---

### repeat

Repeat value n times.

**Signature:** `(repeat n value)`

**Examples:**
```lisp
(repeat 4 'x)   ; => (x x x x)
(repeat 3 0)     ; => (0 0 0)
```

**See also:** repeatedly

---

### zip

Zip lists into list of tuples.

**Signature:** `(zip lists...)`

**Examples:**
```lisp
(zip (list 1 2 3) (list 'a 'b 'c))          ; => ((1 a) (2 b) (3 c))
(zip (list 1 2) (list 'a 'b) (list 'x 'y))  ; => ((1 a x) (2 b y))
```

**See also:** map

---

## Length Predicates

Efficient length comparisons that short-circuit when possible.

### length=

Return #t if length of x equals n.

**Signature:** `(length= x n)`

**Examples:**
```lisp
(length= (list 1 2 3) 3)  ; => #t
(length= (list 1 2) 3)    ; => #f
```

**See also:** length>, length<, empty?

---

### length>

Return #t if length of x is greater than n.

**Signature:** `(length> x n)`

**Examples:**
```lisp
(length> (list 1 2 3) 2)  ; => #t
(length> (list 1 2) 3)    ; => #f
```

**See also:** length=, length<

---

### length<

Return #t if length of x is less than n.

**Signature:** `(length< x n)`

**Examples:**
```lisp
(length< (list 1 2) 3)    ; => #t
(length< (list 1 2 3) 2)  ; => #f
```

**See also:** length=, length>

---

## Sorting

General-purpose sorting with user-supplied comparator functions.
`sort` uses quicksort (not stable); `stable-sort` uses merge sort
and preserves the relative order of equal elements. `merge` combines
two already-sorted lists.

### sort

Sort list using comparison function (simple quicksort implementation).

**Signature:** `(sort lst comparator)`

**Examples:**
```lisp
(sort (list 3 1 4 1 5) <)        ; => (1 1 3 4 5)
(sort (list "b" "a" "c") string<); => ("a" "b" "c")
```

**See also:** stable-sort, sort-by

---

### sort-by

Sort list by applying key-fn to each element, then comparing.

**Signature:** `(sort-by lst key-fn comparator)`

**Examples:**
```lisp
(sort-by (list (list "b" 2) (list "a" 1)) car string<)  ; => (("a" 1) ("b" 2))
(sort-by (list 3 -1 2) abs <)                            ; => (-1 2 3)
```

**See also:** sort, stable-sort

---

### merge

Merge two sorted lists into one sorted list. Stable: when elements are equal (neither comparator direction is true), takes from list1 first.

**Signature:** `(merge list1 list2 comparator)`

**Examples:**
```lisp
(merge (list 1 3 5) (list 2 4 6) <)  ; => (1 2 3 4 5 6)
(merge (list 1 2) (list) <)           ; => (1 2)
```

**See also:** stable-sort, sort

---

### stable-sort

Stable sort - preserves order of equal elements. Uses merge sort internally.

**Signature:** `(stable-sort lst comparator)`

**Examples:**
```lisp
(stable-sort (list 3 1 4 1 5) <)  ; => (1 1 3 4 5)
```

**Note:** Preserves the relative order of elements that compare equal, unlike `sort`.

**See also:** sort, merge, sort-by

---

