---
title: "Standard Library: Higher-Order Functions"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library: Higher-Order Functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- AUTO-GENERATED from inst/rye/ source files. Do not edit manually. -->
<!-- Regenerate with: make stdlib-docs -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

## Core Higher-Order Functions

The fundamental building blocks for functional programming in Rye.
These functions operate on lists and follow the convention of taking
the function argument first, then the data argument.

### map

Apply function to each element.

**Signature:** `(map fn lst)`

**Examples:**
```lisp
(map (lambda (x) (* x 2)) (list 1 2 3))  ; => (2 4 6)
(map (lambda (x) (* x x)) (list 1 2 3 4)) ; => (1 4 9 16)
(map string-length (list "hi" "hello"))     ; => (2 5)
```

**See also:** filter, mapcat, reduce

---

### mapcat

Map then concatenate results. Uses do.call(c, ...) for O(n) concatenation.

**Signature:** `(mapcat fn lst)`

**Examples:**
```lisp
(mapcat (lambda (x) (list x (* x 10))) (list 1 2 3))  ; => (1 10 2 20 3 30)
(mapcat (lambda (x) (list x x)) (list 1 2 3))          ; => (1 1 2 2 3 3)
```

**See also:** map, flatten

---

### filter

Filter items by predicate.

**Signature:** `(filter pred lst)`

**Examples:**
```lisp
(filter (lambda (x) (> x 2)) (list 1 2 3 4 5))  ; => (3 4 5)
(filter even? (list 1 2 3 4 5 6))                 ; => (2 4 6)
(filter string? (list 1 "a" 2 "b"))               ; => ("a" "b")
```

**See also:** remove, take-while, drop-while

---

### remove

Remove items where predicate is true.

**Signature:** `(remove pred lst)`

**Examples:**
```lisp
(remove even? (list 1 2 3 4 5 6))                 ; => (1 3 5)
(remove (lambda (x) (> x 3)) (list 1 2 3 4 5))   ; => (1 2 3)
```

**See also:** filter

---

### reduce

Reduce list with function.

**Signature:** `(reduce fn lst rest...)`

**Examples:**
```lisp
(reduce + (list 1 2 3 4))       ; => 10
(reduce * (list 1 2 3 4))       ; => 24
(reduce + (list 1 2 3) 100)     ; => 106 (with initial value)
(reduce string-append (list "a" "b" "c"))  ; => "abc"
```

**See also:** foldl, foldr, map

---

### foldl

Left fold alias for reduce.

**Signature:** `(foldl fn lst rest...)`

**Examples:**
```lisp
(foldl + (list 1 2 3 4))        ; => 10
(foldl - (list 1 2 3) 10)       ; => 4 (10 - 1 - 2 - 3)
(foldl cons (list 1 2 3) (list)) ; => (3 2 1) (reverses)
```

**See also:** foldr, reduce

---

### foldr

Right fold.

**Signature:** `(foldr fn lst rest...)`

**Examples:**
```lisp
(foldr + (list 1 2 3 4))        ; => 10
(foldr - (list 1 2 3) 10)       ; => -8 (1 - (2 - (3 - 10)))
(foldr cons (list 1 2 3) (list)) ; => (1 2 3) (preserves order)
```

**See also:** foldl, reduce

---

### every?

Return #t if predicate true for all items.

**Signature:** `(every? pred lst)`

**Examples:**
```lisp
(every? positive? (list 1 2 3))       ; => #t
(every? even? (list 2 4 6))           ; => #t
(every? even? (list 2 3 6))           ; => #f
(every? string? (list "a" "b" "c"))   ; => #t
```

**See also:** any?, filter

---

### any?

Return #t if predicate true for any item.

**Signature:** `(any? pred lst)`

**Examples:**
```lisp
(any? even? (list 1 3 4 5))           ; => #t
(any? negative? (list 1 2 3))         ; => #f
(any? string? (list 1 "a" 2))         ; => #t
```

**See also:** every?, filter

---

### complement

Negate predicate.

**Signature:** `(complement pred)`

**Examples:**
```lisp
(define not-even? (complement even?))
(not-even? 3)                          ; => #t
(not-even? 4)                          ; => #f
(filter (complement null?) (list 1 #nil 2 #nil 3))  ; => (1 2 3)
```

**See also:** not, filter

---

### compose

Compose two functions.

**Signature:** `(compose f g)`

**Examples:**
```lisp
(define add1-then-double (compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))))
(add1-then-double 3)                   ; => 8  ((3+1)*2)
(define abs-sum (compose abs +))
(abs-sum -3 -4)                        ; => 7
```

**See also:** partial

---

### partial

Partially apply function.

**Signature:** `(partial fn captured...)`

**Examples:**
```lisp
(define add5 (partial + 5))
(add5 3)                               ; => 8
(define greet (partial string-append "Hello, "))
(greet "world")                        ; => "Hello, world"
```

**See also:** compose

---

## Advanced Functional Programming

Higher-order combinators for advanced functional patterns including
currying, juxtaposition, memoization, and iteration.

### curry

Curry a function - enables partial application with optional initial arguments.

**Signature:** `(curry fn initial-args...)`

**Examples:**
```lisp
(define add (curry (lambda (a b) (+ a b))))
(define add5 (add 5))
(add5 3)                               ; => 8
(define multiply (curry (lambda (a b) (* a b))))
((multiply 3) 4)                       ; => 12
```

**See also:** partial

---

### juxt

Juxtaposition - apply multiple functions to same args, return list of results.

**Signature:** `(juxt fns...)`

**Examples:**
```lisp
(define stats (juxt min max mean))
(stats (c 1 2 3 4 5))                  ; => (1 5 3)
(define first-and-last (juxt car last))
(first-and-last (list 1 2 3))          ; => (1 3)
```

**See also:** map, compose

---

### constantly

Return a function that always returns the given value.

**Signature:** `(constantly value)`

**Examples:**
```lisp
(define always-42 (constantly 42))
(always-42)                             ; => 42
(always-42 "ignored" "args")            ; => 42
(map (constantly 0) (list 1 2 3))       ; => (0 0 0)
```

---

### iterate

Apply function n times to initial value.

**Signature:** `(iterate fn n init)`

**Examples:**
```lisp
(iterate (lambda (x) (* x 2)) 5 1)     ; => 32  (1 -> 2 -> 4 -> 8 -> 16 -> 32)
(iterate inc 3 0)                       ; => 3   (0 -> 1 -> 2 -> 3)
(iterate (lambda (x) (* x x)) 2 2)     ; => 65536  (2 -> 4 -> 16 -> 65536... wait: 2^2=4, 4^2=16)
```

**See also:** iterate-until, reduce

---

### iterate-until

Apply function starting from init, collecting values until predicate becomes true. Includes all values where predicate is false, stops when next value would satisfy predicate.

**Signature:** `(iterate-until fn init pred)`

**Examples:**
```lisp
(iterate-until (lambda (x) (* x 2)) 1 (lambda (x) (> x 100)))
  ; => (1 2 4 8 16 32 64)  (stops before 128 which exceeds 100)
(iterate-until inc 0 (lambda (x) (>= x 5)))
  ; => (0 1 2 3 4)
```

**See also:** iterate, take-while

---

### memoize

Memoize function - cache results for previously seen arguments.

**Signature:** `(memoize fn)`

**Examples:**
```lisp
(define slow-fib (lambda (n) (if (< n 2) n (+ (slow-fib (- n 1)) (slow-fib (- n 2))))))
(define fast-fib (memoize slow-fib))
(fast-fib 10)                          ; => 55
(fast-fib 10)                          ; => 55 (cached, instant)
```

---

## Logical Operations

Core logical operations for Rye. Note that `and` and `or` are compiler
special forms (not functions) with short-circuit evaluation, so they
are not part of this module.

### not

Logical negation with Rye truthiness.

**Signature:** `(not x)`

**Examples:**
```lisp
(not #t)          ; => #f
(not #f)          ; => #t
(not 0)           ; => #t (0 is falsy)
(not 1)           ; => #f (non-zero is truthy)
(not #nil)        ; => #t (NULL is falsy)
(not "hello")     ; => #f (non-empty values are truthy)
```

**Note:** Rye follows Scheme-like truthiness: #f/FALSE, #nil/NULL, and 0 are falsy. Everything else is truthy. This differs from R where only FALSE and NULL are falsy.

**See also:** xor, and, or (special forms)

---

### xor

Logical exclusive OR with Rye truthiness.

**Signature:** `(xor a b)`

**Examples:**
```lisp
(xor #t #f)       ; => #t
(xor #f #t)       ; => #t
(xor #t #t)       ; => #f
(xor #f #f)       ; => #f
(xor 1 0)         ; => #t (1 is truthy, 0 is falsy)
(xor 1 2)         ; => #f (both truthy)
```

**Note:** Exclusive OR: returns #t when exactly one argument is truthy, #f when both are truthy or both are falsy.

**See also:** not, and, or (special forms)

---

