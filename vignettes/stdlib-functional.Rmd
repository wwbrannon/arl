---
title: "Standard Library: Higher-Order Functions"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library: Higher-Order Functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

These functions are provided by the `functional` module (`inst/rye/functional.rye`).

### map

Applies a function to each element of a list, returning a new list.

**Signature:** `(map fn lst)`

**Examples:**
```lisp
(map (lambda (x) (* x 2)) (list 1 2 3))  ; => (2 4 6)
(map str (list 1 2 3))                   ; => ("1" "2" "3")
(map first (list (list 1 2) (list 3 4))) ; => (1 3)
```

**See also:** filter, mapcat, reduce

---

### mapcat

Maps a function over a list and concatenates the results.

**Signature:** `(mapcat fn lst)`

**Examples:**
```lisp
(mapcat (lambda (x) (list x x)) (list 1 2 3))  ; => (1 1 2 2 3 3)
(mapcat identity (list (list 1 2) (list 3 4))) ; => (1 2 3 4)
```

**See also:** map, flatten

---

### filter

Returns a list of elements that satisfy a predicate.

**Signature:** `(filter pred lst)`

**Examples:**
```lisp
(filter (lambda (x) (> x 5)) (list 1 10 3 8))  ; => (10 8)
(filter number? (list 1 "a" 2 "b"))            ; => (1 2)
(filter even? (list 1 2 3 4 5 6))              ; => (2 4 6)
```

**See also:** remove, take-while, drop-while

---

### remove

Returns a list of elements that do NOT satisfy a predicate.

**Signature:** `(remove pred lst)`

**Examples:**
```lisp
(remove (lambda (x) (> x 5)) (list 1 10 3 8))  ; => (1 3)
(remove string? (list 1 "a" 2 "b"))            ; => (1 2)
```

**See also:** filter

---

### reduce

Reduces a list to a single value by repeatedly applying a function.

**Signature:** `(reduce fn lst)` or `(reduce fn lst init)`

**Examples:**
```lisp
(reduce + (list 1 2 3 4))       ; => 10
(reduce * (list 2 3 4))         ; => 24
(reduce + (list 1 2 3) 10)      ; => 16
```

**See also:** foldl, foldr, map

---

### foldl

Left fold - reduces from left to right.

**Signature:** `(foldl fn lst)`

**Examples:**
```lisp
(foldl - (list 1 2 3))  ; => -4  (equivalent to ((1 - 2) - 3))
(foldl / (list 8 2 2))  ; => 2   (equivalent to ((8 / 2) / 2))
```

**See also:** foldr, reduce

---

### foldr

Right fold - reduces from right to left.

**Signature:** `(foldr fn lst)`

**Examples:**
```lisp
(foldr - (list 1 2 3))  ; => 2   (equivalent to (1 - (2 - 3)))
(foldr / (list 8 2 2))  ; => 8   (equivalent to (8 / (2 / 2)))
```

**See also:** foldl, reduce

---

### every?

Returns true if all elements satisfy the predicate.

**Signature:** `(every? pred lst)`

**Examples:**
```lisp
(every? number? (list 1 2 3))         ; => #t
(every? (lambda (x) (> x 0)) (list 1 2 3)) ; => #t
(every? even? (list 2 4 5))           ; => #f
```

**See also:** any?, filter

---

### any?

Returns true if any element satisfies the predicate.

**Signature:** `(any? pred lst)`

**Examples:**
```lisp
(any? number? (list "a" 1 "b"))       ; => #t
(any? (lambda (x) (> x 10)) (list 1 2 3)) ; => #f
(any? even? (list 1 3 5 6))           ; => #t
```

**See also:** every?, filter

---

## Advanced Functional Programming

### curry

Curry a function, enabling incremental partial application until all arguments are supplied.

**Signature:** `(curry fn [initial-args...])`

**Examples:**
```lisp
(define add (lambda (a b) (+ a b)))
(define add5 (curry add 5))
(add5 3)               ; => 8

(define cadd (curry add))
((cadd 5) 3)           ; => 8
```

**See also:** partial

---

### juxt

Create a function that applies multiple functions to the same arguments, returning a list of results.

**Signature:** `(juxt fn1 fn2 ...)`

**Examples:**
```lisp
(define stats (juxt min max))
(stats (list 3 1 4 1 5))  ; => (1 5)
```

**See also:** map, compose

---

### constantly

Return a function that always returns the given value, ignoring its arguments.

**Signature:** `(constantly value)`

**Examples:**
```lisp
(define always-42 (constantly 42))
(always-42)           ; => 42
(always-42 "ignored") ; => 42
(map (constantly 0) (list 1 2 3))  ; => (0 0 0)
```

---

### iterate

Apply a function n times to an initial value.

**Signature:** `(iterate fn n init)`

**Examples:**
```lisp
(iterate (lambda (x) (* x 2)) 3 1)  ; => 8  (1 -> 2 -> 4 -> 8)
(iterate inc 5 0)                    ; => 5
```

**See also:** iterate-until, reduce

---

### iterate-until

Apply a function starting from an initial value, collecting values until a predicate becomes true.

**Signature:** `(iterate-until fn init pred)`

**Examples:**
```lisp
(iterate-until (lambda (x) (* x 2)) 1 (lambda (x) (> x 10)))
; => (1 2 4 8)
```

**See also:** iterate, take-while

---

### memoize

Return a memoized version of a function that caches results for previously seen arguments.

**Signature:** `(memoize fn)`

**Examples:**
```lisp
(define slow-fn (memoize (lambda (n)
  (if (< n 2) n
      (+ (slow-fn (- n 1)) (slow-fn (- n 2)))))))
(slow-fn 30)  ; fast due to caching
```

---

## Logical Operations

These functions are provided by the `logic` module (`inst/rye/logic.rye`).

### not

Logical negation with Rye truthiness semantics.

**Signature:** `(not x)`

**Examples:**
```lisp
(not #t)              ; => #f
(not #f)              ; => #t
(not 0)               ; => #t (0 is falsy in Rye)
(not #nil)            ; => #t
(not "hello")         ; => #f (non-falsy values are truthy)
```

**Note:** In Rye, `#f`/`FALSE`, `#nil`/`NULL`, and `0` are falsy. All other values including `""` and `()` are truthy.

**See also:** xor, and, or (special forms)

---

### xor

Logical exclusive OR with Rye truthiness semantics.

**Signature:** `(xor a b)`

**Examples:**
```lisp
(xor #t #f)           ; => #t
(xor #f #t)           ; => #t
(xor #t #t)           ; => #f
(xor #f #f)           ; => #f
(xor 1 0)             ; => #t (1 is truthy, 0 is falsy)
(xor #nil 5)          ; => #t (one falsy, one truthy)
```

**Note:** Returns `#t` if exactly one argument is truthy, `#f` otherwise.

**See also:** not, and, or (special forms)
