---
title: "Standard Library: Type Predicates"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library: Type Predicates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- AUTO-GENERATED from inst/arl/ source files. Do not edit manually. -->
<!-- Regenerate with: make stdlib-docs -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

These functions are provided by the `types` module (`inst/arl/types.arl`).

## List and Pair Predicates {#section-list-and-pair-predicates}

### list? {#list-p}

Return #t if x is a proper list (R list or call), not a dotted pair.

**Signature:** `(list? x)`

**Examples:**
```lisp
(list? (list 1 2 3))  ; => #t
(list? ())  ; => #t
(list? "hello")  ; => #f
```

**See also:** [pair?](#pair-p), [list-or-pair?](#list-or-pair-p), [null?](#null-p)

---

### list-or-pair? {#list-or-pair-p}

Return #t if x is a non-empty list or dotted pair (pairlist cell).

**Signature:** `(list-or-pair? x)`

**Examples:**
```lisp
(list-or-pair? (list 1))  ; => #t
```

**See also:** [list?](#list-p), [pair?](#pair-p), [null?](#null-p), [atom?](#atom-p)

---

### null? {#null-p}

Return #t for empty list or #nil.

**Signature:** `(null? x)`

**Examples:**
```lisp
(null? #nil)  ; => #t
(null? ())  ; => #t
(null? (list 1))  ; => #f
```

**See also:** [nil?](#nil-p), [pair?](#pair-p), [list-or-pair?](#list-or-pair-p)

---

### nil? {#nil-p}

Alias for null?.

**Signature:** `(nil? x)`

**See also:** [null?](#null-p)

---

### atom? {#atom-p}

Return #t if x is not a non-empty list or
dotted pair (i.e. not list-or-pair?).

**Signature:** `(atom? x)`

**Examples:**
```lisp
(atom? 42)  ; => #t
(atom? "hello")  ; => #t
(atom? (list 1 2))  ; => #f
(atom? ())  ; => #t  (empty list is atomic)
```

**See also:** [list-or-pair?](#list-or-pair-p)

---

### empty? {#empty-p}

Return #t if x is empty (0-length).
(Note the empty string "" has length 1 and is not "empty"!)

**Signature:** `(empty? x)`

**Examples:**
```lisp
(empty? ())  ; => #t
(empty? (list))  ; => #t
(empty? [])  ; => #t
(empty? (list 1))  ; => #f
```

**Note:** The empty string `""` has length 1 in R and is NOT considered empty!

**See also:** [null?](#null-p), [length=](stdlib-list-seq.html#length-eq) (in `sequences` module)

---

## Symbol Predicates {#section-symbol-predicates}

### symbol? {#symbol-p}

Return #t if x is a symbol.

**Signature:** `(symbol? x)`

**Examples:**
```lisp
(symbol? 'foo)  ; => #t
(symbol? "foo")  ; => #f
(symbol? 42)  ; => #f
```

---

### keyword? {#keyword-p}

Return #t if x is an Arl keyword.

**Signature:** `(keyword? x)`

**Examples:**
```lisp
(keyword? :foo)  ; => #t
(keyword? 'foo)  ; => #f
```

---

## Basic Type Predicates {#section-basic-type-predicates}

### number? {#number-p}

Return #t if x is a number (real or complex).

**Signature:** `(number? x)`

**Examples:**
```lisp
(number? 42)  ; => #t
```

**Note:** For numeric type hierarchy predicates (real?, complex?, etc.), see the `math` module documentation.

**See also:** stdlib-math vignette for real?, [complex?](stdlib-math.html#complex-p), [rational?](stdlib-math.html#rational-p), [exact?](stdlib-math.html#exact-p), [inexact?](stdlib-math.html#inexact-p)

---

### string? {#string-p}

Return #t if x is character.

**Signature:** `(string? x)`

**Examples:**
```lisp
(string? "hello")  ; => #t
```

---

### vector? {#vector-p}

Return #t if x is a non-list atomic vector.

**Signature:** `(vector? x)`

**Examples:**
```lisp
(vector? [1 2 3])  ; => #t
```

**Note:** Tests whether x is a non-list atomic vector (numeric, character, logical, etc.). R lists are NOT vectors by this predicate.

---

### boolean? {#boolean-p}

Return #t if x is a single logical value.

**Signature:** `(boolean? x)`

**Examples:**
```lisp
(boolean? #t)  ; => #t
(boolean? #f)  ; => #t
(boolean? TRUE)  ; => #t
(boolean? (c TRUE FALSE))  ; => #f
```

---

### true? {#true-p}

Return #t if x is TRUE.

**Signature:** `(true? x)`

**Examples:**
```lisp
(true? #t)  ; => #t
```

---

### false? {#false-p}

Return #t if x is #f.

**Signature:** `(false? x)`

**Examples:**
```lisp
(false? #f)  ; => #t
```

---

## Function Predicates {#section-function-predicates}

### fn? {#fn-p}

Return #t if x is a function.

**Signature:** `(fn? x)`

**Examples:**
```lisp
(fn? car)  ; => #t
```

**See also:** [callable?](#callable-p), [procedure?](#procedure-p)

---

### callable? {#callable-p}

Alias for fn?.

**Signature:** `(callable? x)`

**See also:** [fn?](#fn-p)

---

### procedure? {#procedure-p}

Alias for fn? - return #t if x is a function.

**Signature:** `(procedure? x)`

**See also:** [fn?](#fn-p), [callable?](#callable-p)

---

## Environment Predicates {#section-environment-predicates}

### environment? {#environment-p}

Test if x is an environment (including R6 objects).

**Signature:** `(environment? x)`

**Examples:**
```lisp
(environment? (base-env))  ; => #t
```

**Note:** R6 objects, dicts, and sets are all environments in R, so this predicate returns #t for them.

---

### is-refclass? {#is-refclass-p}

Test if x is a Reference Class object.

**Signature:** `(is-refclass? x)`

**Examples:**
```lisp
(is-refclass? (base-env))  ; => #f
```

---

## Type Introspection {#section-type-introspection}

### type-of {#type-of}

Return the type of value (alias for R's typeof).

**Signature:** `(type-of x)`

**Examples:**
```lisp
(type-of 42)  ; => "double"
```

**See also:** class, mode (R functions)

---

## List and Pair Predicates {#section-list-and-pair-predicates-2}

### pair? {#pair-p}

Return #t if x is a cons cell (dotted pair).

**Signature:** `(pair? x)`

**Examples:**
```lisp
(pair? (cons 1 2))        ; => #t
(pair? '(1 2 3))          ; => #t
(pair? '())               ; => #f
```

**See also:** [list?](#list-p), [null?](#null-p), [atom?](#atom-p)

---

