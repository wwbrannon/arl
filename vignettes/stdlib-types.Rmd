---
title: "Standard Library: Type Predicates"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library: Type Predicates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- AUTO-GENERATED from inst/rye/ source files. Do not edit manually. -->
<!-- Regenerate with: make stdlib-docs -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

These functions are provided by the `types` module (`inst/rye/types.rye`).

## List and Pair Predicates

### list? {#list}

Return #t if x is a proper list (R list or call), not a dotted pair.

**Signature:** `(list? x)`

**Examples:**
```lisp
(list? (list 1 2 3))  ; => #t
(list? ())  ; => #t
(list? "hello")  ; => #f
```

**See also:** [pair?](#pair), [list-or-pair?](#list-or-pair), [null?](#null)

---

### list-or-pair? {#list-or-pair}

Return #t if x is a non-empty list or dotted pair (pairlist cell).

**Signature:** `(list-or-pair? x)`

**Examples:**
```lisp
(list-or-pair? (list 1))  ; => #t
```

**See also:** [list?](#list), [pair?](#pair), [null?](#null), [atom?](#atom)

---

### null? {#null}

Return #t for empty list or #nil.

**Signature:** `(null? x)`

**Examples:**
```lisp
(null? #nil)  ; => #t
(null? ())  ; => #t
(null? (list 1))  ; => #f
```

**See also:** [nil?](#nil), [pair?](#pair), [list-or-pair?](#list-or-pair)

---

### nil? {#nil}

Alias for null?.

**Signature:** `(nil? x)`

**See also:** [null?](#null)

---

### atom? {#atom}

Return #t if x is not a non-empty list or dotted pair (i.e. not list-or-pair?).

**Signature:** `(atom? x)`

**Examples:**
```lisp
(atom? 42)  ; => #t
(atom? "hello")  ; => #t
(atom? (list 1 2))  ; => #f
(atom? ())  ; => #t  (empty list is atomic)
```

**See also:** [list-or-pair?](#list-or-pair)

---

### empty? {#empty}

Return #t if x is empty (0-length). (Note the empty string "" has length 1 and is not "empty"!)

**Signature:** `(empty? x)`

**Examples:**
```lisp
(empty? ())  ; => #t
(empty? (list))  ; => #t
(empty? [])  ; => #t
(empty? (list 1))  ; => #f
```

**Note:** The empty string `""` has length 1 in R and is NOT considered empty!

**See also:** [null?](#null), [length=](stdlib-list-seq.html#length-eq) (in `sequences` module)

---

## Symbol Predicates

### symbol? {#symbol}

Return #t if x is a symbol.

**Signature:** `(symbol? x)`

**Examples:**
```lisp
(symbol? 'foo)  ; => #t
(symbol? "foo")  ; => #f
(symbol? 42)  ; => #f
```

---

### keyword? {#keyword}

Return #t if x is a Rye keyword.

**Signature:** `(keyword? x)`

**Examples:**
```lisp
(keyword? :foo)  ; => #t
(keyword? 'foo)  ; => #f
```

---

## Basic Type Predicates

### number? {#number}

Return #t if x is a number (real or complex).

**Signature:** `(number? x)`

**Examples:**
```lisp
(number? 42)  ; => #t
```

**Note:** For numeric type hierarchy predicates (real?, complex?, etc.), see the `math` module documentation.

**See also:** stdlib-math vignette for real?, [complex?](stdlib-math.html#complex), [rational?](stdlib-math.html#rational), [exact?](stdlib-math.html#exact), [inexact?](stdlib-math.html#inexact)

---

### string? {#string}

Return #t if x is character.

**Signature:** `(string? x)`

**Examples:**
```lisp
(string? "hello")  ; => #t
```

---

### vector? {#vector}

Return #t if x is a non-list atomic vector.

**Signature:** `(vector? x)`

**Examples:**
```lisp
(vector? [1 2 3])  ; => #t
```

**Note:** Tests whether x is a non-list atomic vector (numeric, character, logical, etc.). R lists are NOT vectors by this predicate.

---

### boolean? {#boolean}

Return #t if x is a single logical value.

**Signature:** `(boolean? x)`

**Examples:**
```lisp
(boolean? #t)  ; => #t
(boolean? #f)  ; => #t
(boolean? TRUE)  ; => #t
(boolean? (c TRUE FALSE))  ; => #f
```

---

### true? {#true}

Return #t if x is TRUE.

**Signature:** `(true? x)`

**Examples:**
```lisp
(true? #t)  ; => #t
```

---

### false? {#false}

Return #t if x is #f.

**Signature:** `(false? x)`

**Examples:**
```lisp
(false? #f)  ; => #t
```

---

## Function Predicates

### fn? {#fn}

Return #t if x is a function.

**Signature:** `(fn? x)`

**Examples:**
```lisp
(fn? car)  ; => #t
```

**See also:** [callable?](#callable), [procedure?](#procedure)

---

### callable? {#callable}

Alias for fn?.

**Signature:** `(callable? x)`

**See also:** [fn?](#fn)

---

### procedure? {#procedure}

Alias for fn? - return #t if x is a function.

**Signature:** `(procedure? x)`

**See also:** [fn?](#fn), [callable?](#callable)

---

## Environment Predicates

### environment? {#environment}

Test if x is an environment (including R6 objects).

**Signature:** `(environment? x)`

**Examples:**
```lisp
(environment? (base-env))  ; => #t
```

**Note:** R6 objects, dicts, and sets are all environments in R, so this predicate returns #t for them.

---

### is-refclass? {#is-refclass}

Test if x is a Reference Class object.

**Signature:** `(is-refclass? x)`

**Examples:**
```lisp
(is-refclass? (base-env))  ; => #f
```

---

## Type Introspection

### type-of {#type-of}

Return the type of value (alias for R's typeof).

**Signature:** `(type-of x)`

**Examples:**
```lisp
(type-of 42)  ; => "double"
```

**See also:** class, mode (R functions)

---

## List and Pair Predicates

### pair? {#pair}

Return #t if x is a cons cell (dotted pair).

**Signature:** `(pair? x)`

**Examples:**
```lisp
(pair? (cons 1 2))        ; => #t
(pair? '(1 2 3))          ; => #t
(pair? '())               ; => #f
```

**See also:** [list?](#list), [null?](#null), [atom?](#atom)

---

