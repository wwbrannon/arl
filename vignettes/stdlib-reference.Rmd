---
title: "Standard Library Overview"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library Overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Rye ships with a small standard library implemented in R, plus additional Rye
source modules. The engine loads the base R stdlib and the Rye modules from
`inst/rye/` by default. Stdlib modules are loaded in dependency order (each
module declares its dependencies with `(import ...)` and is loaded after the
modules it imports).

For the full, per-function reference, see the individual stdlib reference pages:

- [Standard Library: Lists and Sequences](stdlib-list-seq.html)
- [Standard Library: Higher-Order Functions](stdlib-functional.html)
- [Standard Library: Predicates](stdlib-predicates.html)
- [Standard Library: Control Flow and Macros](stdlib-control.html)
- [Standard Library: Strings, I/O, and Arithmetic](stdlib-strings-io.html)
- [Standard Library: Macro, Eval, Interop, and Convenience](stdlib-macro-eval-interop.html)

## Loading

```lisp
; Load focused modules
(load "control")   ; when/unless/and/or/cond/case
(load "binding")   ; let/let*/letrec
(load "looping")   ; while/for
(load "threading") ; -> and ->>
(load "error")     ; try/catch/finally
```

From R, you can create an engine with the stdlib already loaded:

```r
engine <- RyeEngine$new()
```

## Core list operations

`car`, `cdr`, `cons`, `call`, `list*`, `append`, `reverse`, `apply`,
`first`, `rest`, `last`, `nth`

## Higher-order functions

`map`, `mapcat`, `filter`, `remove`, `reduce`, `foldl`, `foldr`,
`every?`, `any?`, `complement`, `compose`, `partial`

## Sequence helpers

`take`, `drop`, `take-while`, `drop-while`, `partition`, `flatten`, `zip`,
`repeatedly`, `repeat`

## Predicates

`null?`, `nil?`, `list?`, `pair?`, `list-or-pair?`, `symbol?`, `keyword?`,
`number?`, `string?`, `vector?`, `true?`, `false?`, `fn?`, `callable?`

## Control flow macros

`when`, `unless`, `and`, `or`, `cond`, `case`

## Binding and looping

`let`, `let*`, `letrec`, `defstruct`, `while`, `for`, `loop`, `recur`

## Threading macros

`->`, `->>`

## Error handling

`try`, `catch`, `finally`, `error`, `warn`, `assert`, `trace`, `try*`

## String and I/O

`str`, `string-join`, `string-split`, `trim`, `format`,
`string-contains?`, `string-match?`, `string-find`,
`string-replace`, `string-replace-all`,
`read-line`, `read-file`, `read-lines`,
`write-file`, `write-lines`, `append-file`,
`file-exists?`, `display`, `println`

## Macro system

`gensym`, `macro?`, `eval`, `macroexpand`, `macroexpand-1`

## Interop helpers

`dict`, `hash`, `dict?`, `dict-get`, `dict-set`, `dict-remove`,
`dict-keys`, `dict-values`, `dict-has?`, `dict-merge`,
`set`, `set?`, `set-add`, `set-remove`, `set-contains?`,
`set-union`, `set-intersection`, `set-difference`,
`r/call`, `identity`

## Arithmetic and comparison

`+`, `-`, `*`, `/`, `%`, `=`, `<`, `>`, `<=`, `>=`, `not`

## Source mapping

The base R parts of the stdlib implementation live in `R/stdlib.R`. The rye
parts are organized by topic in `inst/rye/` (each file defines a module). The
engine loads these modules in dependency order when initializing.

- `_r.rye` (R operator/function aliases, internal)
- `core.rye`
- `list.rye`
- `predicates.rye`
- `control.rye`
- `functional.rye`
- `sequences.rye`
- `struct.rye`
- `error.rye`
- `threading.rye`
- `binding.rye`
- `looping.rye`
- `dict.rye`
- `math.rye`
- `set.rye`
- `strings.rye`
- `display.rye`
- `io.rye`
- `assert.rye`
- `r-interop.rye`
- `translator.rye`

If youâ€™re looking for implementation details, these files are the source of
truth for the stdlib definitions.
