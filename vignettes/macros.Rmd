---
title: "Macros and Quasiquote"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Macros and Quasiquote}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Macros let you transform code before evaluation. Arl supports `defmacro`,
`quasiquote`, `unquote`, and `unquote-splicing`.

## Defining a macro

```lisp
;;' @description Evaluate body forms when test is truthy.
(defmacro when (test . body)
  `(if ,test (begin ,@body) #nil))
```

With that macro defined, you can write:

```lisp
(when (> 5 3) (print "yes"))
```

Macros receive their arguments *unevaluated*, so they can rewrite code before
evaluation happens.

You can attach documentation with `;;'` annotation comments above the macro
definition (see [Getting Started â€” Documenting functions](getting-started.html#documenting-functions)):

```lisp
(help "when")
```

## Macro parameters

Macros can take any number of parameters:

```lisp
;;' @description Evaluate body forms when test is falsy.
(defmacro unless (test . body)
  `(if ,test #nil (begin ,@body)))
```

## Generating symbols safely

Use `gensym` to create unique symbols when you need a temporary binding:

```lisp
;;' @description Bind value to a fresh temporary symbol.
(defmacro with-temp (value body)
  (let ((tmp (gensym "tmp")))
    `(let ((,tmp ,value))
       ,body)))
```

## Quasiquote basics

Use backtick to build templates and unquote to evaluate parts.

```lisp
(define x 10)
`(list ,x 20 30)  ; => (list 10 20 30)
```

## Splicing lists

```lisp
(define xs (list 2 3))
`(list 1 ,@xs 4)  ; => (list 1 2 3 4)
```

## Nested quasiquote

If you nest quasiquotes, only the innermost unquote is evaluated:

```lisp
`(list `(,x))   ; => (list (quasiquote (unquote x)))
```

## Macro expansion

You can inspect expansions from R using `engine$macroexpand()`:

```{r eval=FALSE}
engine <- Engine$new()
engine$eval(engine$read("(defmacro when (test . body) `(if ,test (begin ,@body) #nil))")[[1]])
engine$macroexpand(engine$read("(when #t 1)")[[1]])
```

To see both the macro-expanded form and the compiled R code (e.g. for debugging), use `engine$inspect_compilation(text, env)`. It returns a list with `parsed`, `expanded`, `compiled`, and `compiled_deparsed` (the R source as a character vector). See `?Engine` for details.

To expand only one level, use `macroexpand-1` from Arl code:

```lisp
(macroexpand-1 '(when #t 1))
```

For more examples, see the
[Macro Examples](examples.html#macro-examples) article.

## Related guides

- [Getting Started](getting-started.html)
- [Standard Library Overview](stdlib-reference.html)
