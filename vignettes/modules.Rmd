---
title: "Modules and Imports"
output: arl::arl_html_vignette
vignette: >
  %\VignetteIndexEntry{Modules and Imports}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
arl::register_knitr_engine()
```

Arl provides a module system for organizing code into reusable, encapsulated units. This guide covers how to create modules, import them, and understand how the module system resolves paths.

## Overview

Arl has three mechanisms for loading code:

- **`load`**: Evaluates a file in the current environment (source-like; definitions and imports from the file are visible in the caller)
- **`run`**: Evaluates a file in an isolated child environment (definitions and imports in the file are not visible in the caller)
- **`import`**: Loads a module and attaches only its exported symbols into the current environment

## The `load` Special Form

`load` is the simpler mechanism - it reads and evaluates a file in the current environment.

### Signature

```{arl, eval=FALSE}
(load "path")
```

### Examples

```{arl, eval=FALSE}
; Load a file from the current directory
(load "utils.arl")

; Load a stdlib module by name
(load "control")

; Load with an absolute path
(load "/path/to/my/script.arl")

; Load with a relative path
(load "lib/helpers.arl")
```

### Path Resolution

When you call `(load "name")`, Arl resolves the path in this order:

1. **Path separator check**: If the name contains `/` or `\`, it's treated as a file path and checked directly
2. **Stdlib lookup**: If no path separator, checks the stdlib directory (`inst/arl/`) for:
   - `<name>` (exact match)
   - `<name>.arl` (with extension)
3. **Current directory lookup**: If not in stdlib, checks the current working directory for:
   - `<name>` (exact match)
   - `<name>.arl` (with extension)

### Caching Behavior

`load` includes simple caching to prevent re-evaluation:
- Files with path separators are cached by their full path
- Files without separators (potential stdlib modules) are cached by name if found in stdlib

## The `run` Special Form

`run` reads and evaluates a file in a *child* of the current environment. Definitions and imports in that file stay in the child environment and are not visible in the caller. Use `run` when you want to execute a script without polluting the current scope (e.g. running a one-off task or a file that should not affect the caller's bindings).

### Signature

```{arl, eval=FALSE}
(run "path")
```

### Examples

```{arl, eval=FALSE}
; Run a script in isolation; its definitions are not visible here
(run "scripts/one-off.arl")

; Run a stdlib module by name (same path resolution as load)
(run "control")
```

Path resolution is the same as for `load`. Unlike `load`, `run` does not make the file's definitions or imports visible in the current environment.

## The `module` Special Form

The `module` special form defines a named module with explicit exports.

### Signature

```{arl, eval=FALSE}
(module name
  (export symbol1 symbol2 ...)
  body...)

; Or export everything defined in the module
(module name
  (export-all)
  body...)
```

### Examples

```{arl, eval=FALSE}
; File: math-utils.arl
(module math-utils
  (export square cube)

  (define square
    (lambda (x) (* x x)))

  (define cube
    (lambda (x) (* x x x)))

  ; This is private - not exported
  (define helper
    (lambda (x) (+ x 1))))
```

### Export Strategies

**Explicit exports** (recommended):
```{arl, eval=FALSE}
(module mymodule
  (export func1 func2 var1)
  (define func1 (lambda (x) (* x 2)))
  (define func2 (lambda (x) (+ x 1)))
  (define var1 42)
  (define private-helper (lambda (x) (/ x 2))))  ; Not exported
```

**Export all**:
```{arl, eval=FALSE}
(module mymodule
  (export-all)
  (define func1 (lambda (x) (* x 2)))
  (define func2 (lambda (x) (+ x 1))))
```

## The `import` Special Form

The `import` special form loads a module and makes its exports available in the current environment.

### Signature

```{arl, eval=FALSE}
(import name)      ; name is a symbol: module name (stdlib, then CWD)
(import "path")    ; path is a string: file path (path-only resolution)
```

- **Symbol** (e.g. `control`): treated as a **module name**. Resolution looks in the stdlib, then the current working directory (same as `load` by name).
- **String** (e.g. `"lib/utils.arl"`): treated as a **file path**. Only path-based resolution is used (no stdlib lookup). The path is normalized to absolute so that the same file imported with different path strings (e.g. `"inst/arl/control.arl"` and `"./inst/arl/control.arl"`) reuses the same loaded module.

### Examples

```{arl, eval=FALSE}
; Import by module name (symbol): stdlib or CWD
(import math-utils)
(square 5)  ; => 25
(import control)
(when #t (println "hello"))

; Import by path (string): path-only resolution, no stdlib
(import "lib/my-module.arl")
(import "/absolute/path/to/module.arl")
```

### Path Resolution

- **`(import name)`** (symbol): resolve by **module name** — stdlib (`inst/arl/`), then current directory. The file must register itself with `(module name ...)`.
- **`(import "path")`** (string): resolve by **path only** — the string is a file path (existing file or `path.arl`). No stdlib lookup. The path is normalized to absolute for caching, so re-importing the same file with a different path string does not reload it.

### Module Registration and Scoping

When you `import` a module:

1. If the module isn't already registered for this engine, Arl loads the file containing the module (into the engine's shared module cache)
2. The file must contain a `(module ...)` form that registers itself
3. `import` attaches the module's exports into the *current* environment (the scope where you wrote `(import ...)`)
4. Subsequent `(import M)` in any scope reuses the same module instance and attaches its exports into that scope

**Import scoping**: Each `(import M)` only makes M's exports visible in the environment where that form was evaluated. Imports in one file are not visible in another file or in the REPL unless that file (or the REPL) also runs `(import M)`. Modules are loaded once per engine and shared; only the set of environments that "see" the exports depends on where you call `import`.

### Error Handling

```{arl, eval=FALSE}
; Module not found
(import non-existent-module)
; Error: Module not found: non-existent-module

; Module file doesn't register itself
; File: bad.arl containing just (define x 10)
(import bad)
; Error: Module 'bad' did not register itself

; Accessing unexported symbol
; File: restricted.arl
(module restricted
  (export public-fn)
  (define public-fn (lambda () "visible"))
  (define private-fn (lambda () "hidden")))

(import restricted)
public-fn   ; Works
private-fn  ; Error: object 'private-fn' not found
```

## Creating User Modules

### Basic Module Structure

Create a file `mymodule.arl`:

```{arl, eval=FALSE}
(module mymodule
  (export greet farewell)

  (define greet
    (lambda (name)
      (str "Hello, " name "!")))

  (define farewell
    (lambda (name)
      (str "Goodbye, " name "!"))))
```

Then import it:

```{arl, eval=FALSE}
(import mymodule)
(greet "Alice")     ; => "Hello, Alice!"
(farewell "Bob")    ; => "Goodbye, Bob!"
```

### Module with Private Helpers

```{arl, eval=FALSE}
; File: calculator.arl
(module calculator
  (export add subtract)

  ; Private helper
  (define validate-number
    (lambda (x)
      (if (number? x)
        x
        (error "Not a number"))))

  ; Public functions
  (define add
    (lambda (a b)
      (+ (validate-number a)
         (validate-number b))))

  (define subtract
    (lambda (a b)
      (- (validate-number a)
         (validate-number b)))))
```

### Nested Module Loading

Modules can load other modules:

```{arl, eval=FALSE}
; File: string-helpers.arl
(module string-helpers
  (export upcase downcase)
  (define upcase (lambda (s) (toupper s)))
  (define downcase (lambda (s) (tolower s))))

; File: text-utils.arl
(module text-utils
  (export format-name)

  (import string-helpers)

  (define format-name
    (lambda (first last)
      (str (upcase first) " " (upcase last)))))

; Usage:
(import text-utils)
(format-name "john" "doe")  ; => "JOHN DOE"
```

## Standard Library Modules

Arl's standard library is organized into modules that you can load as needed:

```{arl, eval=FALSE}
; Control flow macros
(import control)    ; when, unless, and, or, cond, case

; Binding forms
(import binding)    ; let, let*, letrec

; Looping constructs
(import looping)    ; while, for, loop, recur

; Threading macros
(import threading)  ; ->, ->>

; Error handling
(import error)      ; try, catch, finally

; Functional (higher-order) functions
(import functional)  ; map, filter, reduce, etc.

; String operations
(import strings)    ; str, string-join, string-split, etc.

; I/O operations
(import io)         ; display, println, read-line

; Dictionaries
(import dict)       ; dict operations

; Sets
(import set)        ; set operations
```

The base stdlib (loaded automatically) includes core functions like `car`, `cdr`, `cons`, `list`, basic arithmetic, and predicates.

## Best Practices

### 1. Use Explicit Exports

Prefer `(export symbol1 symbol2 ...)` over `(export-all)` to maintain clear module interfaces:

```{arl, eval=FALSE}
; Good - clear interface
(module utils
  (export public-fn1 public-fn2)
  (define public-fn1 ...)
  (define private-helper ...))

; Avoid - exposes everything
(module utils
  (export-all)
  ...)
```

### 2. Organize Related Functionality

Group related functions into logical modules:

```{arl, eval=FALSE}
; Good organization
(module validation
  (export validate-email validate-phone validate-zipcode)
  ...)

; Rather than one large utils module
```

### 3. Document Module Purpose

Use `;;'` annotation comments to document your modules:

```{arl, eval=FALSE}
;;' @description String manipulation utilities for text processing.
(module string-utils
  (export trim upcase downcase)
  ...)
```

### 4. Avoid Circular Dependencies

Circular module imports will cause infinite recursion errors:

```{arl, eval=FALSE}
; File: a.arl
(module a
  (export fn-a)
  (import b)  ; Depends on b
  ...)

; File: b.arl
(module b
  (export fn-b)
  (import a)  ; Depends on a - circular!
  ...)
```

### 5. Use Load Path Conventions

Organize modules in a predictable directory structure:

```
project/
  lib/
    utils.arl
    validators.arl
  app.arl
```

Then load with relative paths:

```{arl, eval=FALSE}
; In app.arl
(import "lib/utils")
(import "lib/validators")
```

## Differences from Other Lisps

### vs. Common Lisp

- Arl doesn't have package namespaces - imports bring symbols into the current environment
- No `use-package` or package-qualified symbols like `package::symbol`
- Simpler, file-based module system

### vs. Scheme

- Arl's `module` is similar to R6RS libraries but simpler
- No renaming or prefix imports
- Path resolution is more straightforward

### vs. Clojure

- No namespace aliases (`require [module :as alias]`)
- No selective imports (`require [module :refer [fn1 fn2]]`)
- Simpler import mechanism - all exports are imported

## Summary

- **`load`**: Evaluates a file in the current environment (definitions and imports visible in the caller)
- **`run`**: Evaluates a file in an isolated child environment (definitions and imports not visible in the caller)
- **`module`**: Defines a module with explicit exports
- **`import`**: Loads a module and attaches its exports into the current scope only; each module is loaded once per engine
- Path resolution: path separators → stdlib → current directory
- Use explicit exports for maintainable module interfaces
