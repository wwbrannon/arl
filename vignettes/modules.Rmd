---
title: "Modules and Imports"
output: arl::arl_html_vignette
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{Modules and Imports}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
arl::register_knitr_engine()
```

Arl provides a module system for organizing code into reusable, encapsulated units. This guide covers how to create modules, import them, and understand how the module system resolves paths.

## Overview

Arl has three mechanisms for loading code:

- **`load`**: Evaluates a file in the current environment (source-like; definitions and imports from the file are visible in the caller)
- **`run`**: Evaluates a file in an isolated child environment (definitions and imports in the file are not visible in the caller)
- **`import`**: Loads a module and attaches only its exported symbols into the current environment

## The `load` Function

`load` is the simplest mechanism - it reads and evaluates a file in a target
environment (defaulting to the current environment).

### Signature

```{arl, eval=FALSE}
(load "path")
(load "path" env)
```

### Examples

```{arl, eval=FALSE}
; Load a file from the current directory
(load "utils.arl")

; Load with an absolute path
(load "/path/to/my/script.arl")

; Load with a relative path
(load "lib/helpers.arl")
```

### Path Resolution

`load` treats its argument as a file path. It does **not** search the stdlib
directory — use `(import name)` for stdlib modules.

The path is resolved as-is: if the file exists at the given path, it's loaded;
otherwise an error is raised.

### Re-evaluation

`load` always re-evaluates the file on each call. If you call `(load "script.arl")`
twice, the file is read and evaluated twice. This is intentional — `load` is for
sourcing scripts, not for module loading (use `import` for that).

## The `run` Function

`run` reads and evaluates a file in a *child* of the current environment. Definitions and imports in that file stay in the child environment and are not visible in the caller. Use `run` when you want to execute a script without polluting the current scope (e.g. running a one-off task or a file that should not affect the caller's bindings).

### Signature

```{arl, eval=FALSE}
(run "path")
(run "path" parent-env)
```

### Examples

```{arl, eval=FALSE}
; Run a script in isolation; its definitions are not visible here
(run "scripts/one-off.arl")
```

`run` is defined in stdlib `core` and implemented in terms of `load`:
it creates `new.env(parent = parent-env)` and evaluates the file there.

## The `module` Special Form

The `module` special form defines a named module with explicit exports.

### Signature

```{arl, eval=FALSE}
(module name
  (export symbol1 symbol2 ...)
  body...)

; Or export everything defined in the module
(module name
  (export-all)
  body...)
```

### Examples

```{arl, eval=FALSE}
; File: math-utils.arl
(module math-utils
  (export square cube)

  (define square
    (lambda (x) (* x x)))

  (define cube
    (lambda (x) (* x x x)))

  ; This is private - not exported
  (define helper
    (lambda (x) (+ x 1))))
```

```{arl, include=FALSE}
;; Verify inline module definition works
(module __test-math-utils
  (export __test-square __test-cube)
  (define __test-square (lambda (x) (* x x)))
  (define __test-cube (lambda (x) (* x x x)))
  (define __test-helper (lambda (x) (+ x 1))))
(import __test-math-utils)
(assert-equal 25 (__test-square 5))
(assert-equal 27 (__test-cube 3))
```

### Export Strategies

**Explicit exports** (recommended):
```{arl, eval=FALSE}
(module mymodule
  (export func1 func2 var1)
  (define func1 (lambda (x) (* x 2)))
  (define func2 (lambda (x) (+ x 1)))
  (define var1 42)
  (define private-helper (lambda (x) (/ x 2))))  ; Not exported
```

**Export all**:
```{arl, eval=FALSE}
(module mymodule
  (export-all)
  (define func1 (lambda (x) (* x 2)))
  (define func2 (lambda (x) (+ x 1))))
```

## The `import` Special Form

The `import` special form loads a module and makes its exports available in the current environment.

### Signature

```{arl, eval=FALSE}
(import name)      ; name is a symbol: module name (stdlib, then CWD)
(import "path")    ; path is a string: file path (path-only resolution)
```

- **Symbol** (e.g. `control`): treated as a **module name**. Resolution looks in the stdlib, then the current working directory (same as `load` by name).
- **String** (e.g. `"lib/utils.arl"`): treated as a **file path**. Only path-based resolution is used (no stdlib lookup). The path is normalized to absolute so that the same file imported with different path strings (e.g. `"inst/arl/control.arl"` and `"./inst/arl/control.arl"`) reuses the same loaded module.

### Examples

```{arl, eval=FALSE}
; Import by module name (symbol): stdlib or CWD
(import math-utils)
(square 5)  ; => 25
(import control)
(when #t (println "hello"))

; Import by path (string): path-only resolution, no stdlib
(import "lib/my-module.arl")
(import "/absolute/path/to/module.arl")
```

### Path Resolution

- **`(import name)`** (symbol): resolve by **module name** — stdlib (`inst/arl/`), then current directory. The file must register itself with `(module name ...)`.
- **`(import "path")`** (string): resolve by **path only** — the string is a file path (existing file or `path.arl`). No stdlib lookup. Relative paths are resolved from the directory of the file containing the `import`, not from the current working directory. This means `(import "helper.arl")` inside `lib/main.arl` looks for `lib/helper.arl`. When no source file is known (e.g. at the REPL), relative paths fall back to CWD. The path is normalized to absolute for caching, so re-importing the same file with a different path string does not reload it.

### Module Registration and Scoping

When you `import` a module:

1. If the module isn't already registered for this engine, Arl loads the file containing the module (into the engine's shared module cache)
2. The file must contain a `(module ...)` form that registers itself
3. `import` attaches the module's exports into the *current* environment (the scope where you wrote `(import ...)`)
4. Subsequent `(import M)` in any scope reuses the same module instance and attaches its exports into that scope

**Import scoping**: Each `(import M)` only makes M's exports visible in the environment where that form was evaluated. Imports in one file are not visible in another file or in the REPL unless that file (or the REPL) also runs `(import M)`. Modules are loaded once per engine and shared; only the set of environments that "see" the exports depends on where you call `import`.

### Error Handling

```{arl, eval=FALSE}
; Module not found
(import non-existent-module)
; Error: Module not found: non-existent-module

; Module file doesn't register itself
; File: bad.arl containing just (define x 10)
(import bad)
; Error: Module 'bad' did not register itself

; Accessing unexported symbol
; File: restricted.arl
(module restricted
  (export public-fn)
  (define public-fn (lambda () "visible"))
  (define private-fn (lambda () "hidden")))

(import restricted)
public-fn   ; Works
private-fn  ; Error: object 'private-fn' not found
```

## Creating User Modules

### Basic Module Structure

Create a file `mymodule.arl`:

```{arl, eval=FALSE}
(module mymodule
  (export greet farewell)

  (define greet
    (lambda (name)
      (str "Hello, " name "!")))

  (define farewell
    (lambda (name)
      (str "Goodbye, " name "!"))))
```

Then import it:

```{arl, eval=FALSE}
(import mymodule)
(greet "Alice")     ; => "Hello, Alice!"
(farewell "Bob")    ; => "Goodbye, Bob!"
```

### Module with Private Helpers

```{arl, eval=FALSE}
; File: calculator.arl
(module calculator
  (export add subtract)

  ; Private helper
  (define validate-number
    (lambda (x)
      (if (number? x)
        x
        (error "Not a number"))))

  ; Public functions
  (define add
    (lambda (a b)
      (+ (validate-number a)
         (validate-number b))))

  (define subtract
    (lambda (a b)
      (- (validate-number a)
         (validate-number b)))))
```

```{arl, include=FALSE}
(module __test-calculator
  (export __calc-add __calc-subtract)
  (import types)
  (define __validate-number
    (lambda (x)
      (if (number? x) x (error "Not a number"))))
  (define __calc-add
    (lambda (a b)
      (+ (__validate-number a) (__validate-number b))))
  (define __calc-subtract
    (lambda (a b)
      (- (__validate-number a) (__validate-number b)))))
(import __test-calculator)
(assert-equal 7 (__calc-add 3 4))
(assert-equal 1 (__calc-subtract 5 4))
(assert-error (__calc-add "x" 1))
```

### Nested Module Loading

Modules can load other modules:

```{arl, eval=FALSE}
; File: string-helpers.arl
(module string-helpers
  (export upcase downcase)
  (define upcase (lambda (s) (toupper s)))
  (define downcase (lambda (s) (tolower s))))

; File: text-utils.arl
(module text-utils
  (export format-name)

  (import string-helpers)

  (define format-name
    (lambda (first last)
      (str (upcase first) " " (upcase last)))))

; Usage:
(import text-utils)
(format-name "john" "doe")  ; => "JOHN DOE"
```

## Standard Library Modules

Arl's standard library is organized into modules. All modules are loaded
automatically when creating an engine, so everything is available by default.
The module structure is relevant when writing your own modules (which must
explicitly import their dependencies) or when creating a bare engine with
`Engine$new(load_stdlib = FALSE)`:

```{arl, eval=FALSE}
; Control flow macros
(import control)    ; when, unless, cond, case, try*

; Binding forms
(import binding)    ; let, let*, letrec

; Looping constructs
(import looping)    ; until, for, loop, recur

; Threading macros
(import threading)  ; ->, ->>

; Error handling
(import error)      ; try, catch, finally

; Functional (higher-order) functions
(import functional)  ; map, filter, reduce, etc.

; String operations
(import strings)    ; str, string-join, string-split, etc.

; I/O operations
(import io)         ; display, println, read-line

; Dictionaries
(import dict)       ; dict operations

; Sets
(import set)        ; set operations
```

All stdlib modules are loaded automatically when the engine starts. Core
functions (`car`, `cdr`, `cons`, `list`, arithmetic, predicates) come from the
R runtime layer; the Arl modules above add macros and higher-level functions.
To create an engine without stdlib modules, use
`Engine$new(load_stdlib = FALSE)` — builtins like `gensym`, `eval`, `read`,
and `cons` are still available.

## Best Practices

### 1. Use Explicit Exports

Prefer `(export symbol1 symbol2 ...)` over `(export-all)` to maintain clear module interfaces:

```{arl, eval=FALSE}
; Good - clear interface
(module utils
  (export public-fn1 public-fn2)
  (define public-fn1 ...)
  (define private-helper ...))

; Avoid - exposes everything
(module utils
  (export-all)
  ...)
```

### 2. Organize Related Functionality

Group related functions into logical modules:

```{arl, eval=FALSE}
; Good organization
(module validation
  (export validate-email validate-phone validate-zipcode)
  ...)

; Rather than one large utils module
```

### 3. Document Module Purpose

Use `;;'` annotation comments to document your modules:

```{arl, eval=FALSE}
;;' @description String manipulation utilities for text processing.
(module string-utils
  (export trim upcase downcase)
  ...)
```

### 4. Avoid Circular Dependencies

Circular module imports are detected at import time with a clear error message:

```{arl, eval=FALSE}
; File: a.arl
(module a
  (export fn-a)
  (import b)  ; Depends on b
  ...)

; File: b.arl
(module b
  (export fn-b)
  (import a)  ; Depends on a - circular!
  ...)

; (import a) => Error: Circular dependency detected: a -> b -> a
```

### 5. Use Load Path Conventions

Organize modules in a predictable directory structure:

```
project/
  lib/
    utils.arl
    validators.arl
  app.arl
```

Then load with relative paths:

```{arl, eval=FALSE}
; In app.arl
(import "lib/utils")
(import "lib/validators")
```

## Differences from Other Lisps

### vs. Common Lisp

- Arl doesn't have package namespaces - imports bring symbols into the current environment
- No `use-package` or package-qualified symbols like `package::symbol`
- Simpler, file-based module system

### vs. Scheme

- Arl's `module` is similar to R6RS libraries but simpler
- No renaming or prefix imports
- Path resolution is more straightforward

### vs. Clojure

- No namespace aliases (`require [module :as alias]`)
- No selective imports (`require [module :refer [fn1 fn2]]`)
- Simpler import mechanism - all exports are imported

## Summary

- **`load`**: Evaluates a file in the current environment; always re-evaluates (no caching, no stdlib lookup)
- **`run`**: Evaluates a file in an isolated child environment (definitions and imports not visible in the caller)
- **`module`**: Defines a module with explicit exports; `(export-all)` exports only symbols defined in the module, not imported ones
- **`import`**: Loads a module and attaches its exports into the current scope only; each module is loaded once per engine; relative paths resolve from the importing file's directory
- Circular imports are detected with a clear error message
- Use explicit exports for maintainable module interfaces
