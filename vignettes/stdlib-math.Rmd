---
title: "Standard Library: Math and Numeric Functions"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library: Math and Numeric Functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- AUTO-GENERATED from inst/rye/ source files. Do not edit manually. -->
<!-- Regenerate with: make stdlib-docs -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

These functions are provided by the `math` module (`inst/rye/math.rye`).

## Numeric Type Predicates

Rye implements a numeric tower adapted for R's type system:

```
number?    (is.numeric OR is.complex)
├─ complex?  (is.complex)
└─ real?     (is.numeric AND NOT is.complex)
   ├─ ±Inf   (real but not rational)
   └─ rational? (real? AND is.finite)
      └─ integer? (is.finite AND is.numeric AND x == as.integer(x))
         └─ natural? (integer? AND x >= 0)

Orthogonal predicates:
exact?   (is.integer - storage type)
inexact? (number? AND NOT is.integer)
```

**Note:** `number?` is provided by the `types` module, not `math`.

### real? {#real}

Return #t if x is a real number (includes ±Inf, excludes complex).

**Signature:** `(real? x)`

**Examples:**
```lisp
(real? 42)            ; => #t
(real? 3.14)          ; => #t
(real? Inf)           ; => #t
(real? (make-rectangular 3 4))  ; => #f
```

**See also:** [rational?](#rational), [complex?](#complex), [number?](stdlib-types.html#number) (in `types` module)

---

### complex? {#complex}

Return #t if x is a complex number.

**Signature:** `(complex? x)`

**Examples:**
```lisp
(complex? (make-rectangular 3 4))  ; => #t
(complex? 42)         ; => #f
```

**See also:** [real?](#real), [number?](stdlib-types.html#number) (in `types` module), [make-rectangular](#make-rectangular)

---

### rational? {#rational}

Return #t if x is a finite real number (rational in R are finite floats).

**Signature:** `(rational? x)`

**Examples:**
```lisp
(rational? 42)        ; => #t
(rational? 3.14)      ; => #t
(rational? Inf)       ; => #f (infinities are real but not rational)
(rational? NaN)       ; => #f
```

**Note:** In R, all finite floating-point numbers can be represented as rationals (IEEE 754). R does not have a built-in rational or decimal type like some Schemes.

**See also:** [real?](#real), [integer?](#integer), [number?](stdlib-types.html#number) (in `types` module)

---

### exact? {#exact}

Return #t if x is an exact number (integer storage type in R).

**Signature:** `(exact? x)`

**Examples:**
```lisp
(exact? 5L)           ; => #t (integer type)
(exact? 5.0)          ; => #f (double type)
(exact? (->integer 5)); => #t
```

**Note:** In Scheme, exactness is a property of the number. In R (and Rye), exactness corresponds to integer storage type. All integers are exact; all doubles and complex numbers are inexact.

**See also:** [inexact?](#inexact), [exact->inexact](stdlib-conversions.html#exact-to-inexact) (in `conversions` module)

---

### inexact? {#inexact}

Return #t if x is an inexact number (double or complex in R).

**Signature:** `(inexact? x)`

**Examples:**
```lisp
(inexact? 5.0)        ; => #t
(inexact? (make-rectangular 3 4))  ; => #t
(inexact? 5L)         ; => #f
```

**See also:** [exact?](#exact), [inexact->exact](stdlib-conversions.html#inexact-to-exact) (in `conversions` module)

---

### integer? {#integer}

Return #t if x is an integer-valued number.

**Signature:** `(integer? x)`

**Examples:**
```lisp
(integer? 42)         ; => #t
(integer? 42.0)       ; => #t (value is integer even if storage is double)
(integer? 3.14)       ; => #f
(integer? Inf)        ; => #f
```

**Note:** Tests for integer VALUE, not storage type. Use `exact?` to test storage type.

**See also:** [natural?](#natural), [exact?](#exact), [rational?](#rational)

---

### natural? {#natural}

Return #t if x is a natural number (integer >= 0).

**Signature:** `(natural? x)`

**Examples:**
```lisp
(natural? 0)          ; => #t
(natural? 42)         ; => #t
(natural? -5)         ; => #f
(natural? 3.14)       ; => #f
```

**See also:** [integer?](#integer), [positive?](#positive), [non-negative?](#non-negative)

---

### finite? {#finite}

Return #t if x is finite.

**Signature:** `(finite? x)`

**Examples:**
```lisp
(finite? 42)          ; => #t
(finite? Inf)         ; => #f
(finite? NaN)         ; => #f
(finite? -Inf)        ; => #f
```

**See also:** [infinite?](#infinite), [nan?](#nan), [rational?](#rational)

---

### infinite? {#infinite}

Return #t if x is infinite.

**Signature:** `(infinite? x)`

**Examples:**
```lisp
(infinite? Inf)       ; => #t
(infinite? -Inf)      ; => #t
(infinite? 42)        ; => #f
(infinite? NaN)       ; => #f
```

**See also:** [finite?](#finite), [nan?](#nan)

---

### nan? {#nan}

Return #t if x is NaN.

**Signature:** `(nan? x)`

**Examples:**
```lisp
(nan? NaN)            ; => #t
(nan? (/ 0 0))        ; => #t (0/0 = NaN)
(nan? 42)             ; => #f
(nan? Inf)            ; => #f
```

**See also:** [finite?](#finite), [infinite?](#infinite)

---

## Value Predicates

### even? {#even}

Return #t if x is an even number.

**Signature:** `(even? x)`

**Examples:**
```lisp
(even? 4)             ; => #t
(even? 3)             ; => #f
(even? 0)             ; => #t
```

**See also:** [odd?](#odd)

---

### odd? {#odd}

Return #t if x is an odd number.

**Signature:** `(odd? x)`

**Examples:**
```lisp
(odd? 3)              ; => #t
(odd? 4)              ; => #f
```

**See also:** [even?](#even)

---

### zero? {#zero}

Return #t if x is zero.

**Signature:** `(zero? x)`

**Examples:**
```lisp
(zero? 0)             ; => #t
(zero? 0.0)           ; => #t
(zero? 1)             ; => #f
```

**See also:** [positive?](#positive), [negative?](#negative)

---

### positive? {#positive}

Return #t if x is greater than zero.

**Signature:** `(positive? x)`

**Examples:**
```lisp
(positive? 5)         ; => #t
(positive? 0)         ; => #f
(positive? -5)        ; => #f
```

**See also:** [negative?](#negative), [non-negative?](#non-negative), [zero?](#zero)

---

### negative? {#negative}

Return #t if x is less than zero.

**Signature:** `(negative? x)`

**Examples:**
```lisp
(negative? -5)        ; => #t
(negative? 0)         ; => #f
(negative? 5)         ; => #f
```

**See also:** [positive?](#positive), [non-positive?](#non-positive), [zero?](#zero)

---

### non-negative? {#non-negative}

Return #t if x is greater than or equal to zero.

**Signature:** `(non-negative? x)`

**Examples:**
```lisp
(non-negative? 5)     ; => #t
(non-negative? 0)     ; => #t
(non-negative? -5)    ; => #f
```

**See also:** [positive?](#positive), [natural?](#natural)

---

### non-positive? {#non-positive}

Return #t if x is less than or equal to zero.

**Signature:** `(non-positive? x)`

**Examples:**
```lisp
(non-positive? -5)    ; => #t
(non-positive? 0)     ; => #t
(non-positive? 5)     ; => #f
```

**See also:** [negative?](#negative)

---

## Complex Number Utilities

### make-rectangular {#make-rectangular}

Construct a complex number from real and imaginary parts.

**Signature:** `(make-rectangular real imag)`

**Examples:**
```lisp
(make-rectangular 3 4)  ; => 3+4i
```

**See also:** [make-polar](#make-polar), [real-part](#real-part), [imag-part](#imag-part)

---

### make-polar {#make-polar}

Construct a complex number from polar coordinates (magnitude and angle).

**Signature:** `(make-polar magnitude angle)`

**Examples:**
```lisp
(make-polar 5 0)      ; => 5+0i
```

**See also:** [make-rectangular](#make-rectangular), [magnitude](#magnitude), [angle](#angle)

---

### real-part {#real-part}

Extract the real part of a complex number.

**Signature:** `(real-part z)`

**Examples:**
```lisp
(real-part (make-rectangular 3 4))  ; => 3.0
```

**See also:** [imag-part](#imag-part), [make-rectangular](#make-rectangular)

---

### imag-part {#imag-part}

Extract the imaginary part of a complex number.

**Signature:** `(imag-part z)`

**Examples:**
```lisp
(imag-part (make-rectangular 3 4))  ; => 4.0
```

**See also:** [real-part](#real-part), [make-rectangular](#make-rectangular)

---

### magnitude {#magnitude}

Compute the magnitude (modulus) of a complex number.

**Signature:** `(magnitude z)`

**Examples:**
```lisp
(magnitude (make-rectangular 3 4))  ; => 5.0
```

**See also:** [angle](#angle), [make-polar](#make-polar)

---

### angle {#angle}

Compute the angle (argument) of a complex number.

**Signature:** `(angle z)`

**Examples:**
```lisp
(angle (make-rectangular 1 1))  ; => 0.7853981633974483 (π/4)
```

**See also:** [magnitude](#magnitude), [make-polar](#make-polar)

---

## Arithmetic Helpers

### % {#modulo}

Modulo helper using R %%.

**Signature:** `(% x y)`

**Examples:**
```lisp
(% 10 3)   ; => 1
(% 17 5)   ; => 2
```

---

### < {#lt}

Variadic less-than comparison. Checks all adjacent pairs.

**Signature:** `(< a b ...)`

**Examples:**
```lisp
(< 1 2)     ; => #t
(< 1 2 3)   ; => #t
(< 1 3 2)   ; => #f
```

---

### > {#gt}

Variadic greater-than comparison. Checks all adjacent pairs.

**Signature:** `(> a b ...)`

**Examples:**
```lisp
(> 3 2)     ; => #t
(> 3 2 1)   ; => #t
(> 3 1 2)   ; => #f
```

---

### <= {#lte}

Variadic less-than-or-equal comparison. Checks all adjacent pairs.

**Signature:** `(<= a b ...)`

**Examples:**
```lisp
(<= 1 2)    ; => #t
(<= 1 1 2)  ; => #t
(<= 2 1)    ; => #f
```

---

### >= {#gte}

Variadic greater-than-or-equal comparison. Checks all adjacent pairs.

**Signature:** `(>= a b ...)`

**Examples:**
```lisp
(>= 3 2)    ; => #t
(>= 2 2 1)  ; => #t
(>= 1 2)    ; => #f
```

---

### == {#num-eq-eq}

Variadic equality comparison. Checks all adjacent pairs.

**Signature:** `(== a b ...)`

**Examples:**
```lisp
(== 1 1)     ; => #t
(== 1 1 1)   ; => #t
(== 1 2)     ; => #f
```

---

### = {#num-eq}

**Signature:** `(= a b ...)`

**Examples:**
```lisp
(= 1 1)           ; => #t
(= "a" "a")       ; => #t
(= 1 2)           ; => #f
```

---

### + {#plus}

Variadic addition.

**Signature:** `(+ a ...)`

**Examples:**
```lisp
(+ 1 2 3)    ; => 6
(+)           ; => 0
(+ 5)         ; => 5
```

---

### * {#star}

Variadic multiplication.

**Signature:** `(* a ...)`

**Examples:**
```lisp
(* 2 3 4)    ; => 24
(*)           ; => 1
(* 5)         ; => 5
```

---

### - {#minus}

Variadic subtraction.

**Signature:** `(- a ...)`

**Examples:**
```lisp
(- 10 3)     ; => 7
(- 5)        ; => -5
(- 10 3 2)   ; => 5
```

---

### / {#div}

Variadic division.

**Signature:** `(/ a ...)`

**Examples:**
```lisp
(/ 10 2)     ; => 5
(/ 5)        ; => 0.2
(/ 100 5 2)  ; => 10
```

---

### min {#min}

Variadic min.

**Signature:** `(min a ...)`

**Examples:**
```lisp
(min 3 1 2)  ; => 1
```

---

### max {#max}

Variadic max.

**Signature:** `(max a ...)`

**Examples:**
```lisp
(max 3 1 2)  ; => 3
```

---

### inc {#inc}

Increment numeric value by n (default 1).

**Signature:** `(inc x [n 1])`

**Examples:**
```lisp
(inc 5)       ; => 6
(inc 5 3)     ; => 8
```

**See also:** [dec](#dec)

---

### dec {#dec}

Decrement numeric value by n (default 1).

**Signature:** `(dec x [n 1])`

**Examples:**
```lisp
(dec 5)       ; => 4
(dec 5 3)     ; => 2
```

**See also:** [inc](#inc)

---

### clamp {#clamp}

Clamp numeric value x to the inclusive range [lo, hi].

**Signature:** `(clamp x lo hi)`

**Examples:**
```lisp
(clamp 5 0 10)   ; => 5
(clamp -3 0 10)  ; => 0
(clamp 15 0 10)  ; => 10
```

**See also:** [within?](#within)

---

### within? {#within}

Return #t if x is within the inclusive range [lo, hi].

**Signature:** `(within? x lo hi)`

**Examples:**
```lisp
(within? 5 0 10)   ; => #t
(within? -3 0 10)  ; => #f
(within? 10 0 10)  ; => #t
```

**See also:** [clamp](#clamp)

---

## Rounding and Truncation

### abs {#abs}

Return absolute value of x.

**Signature:** `(abs x)`

**Examples:**
```lisp
(abs -5)      ; => 5
(abs 5)       ; => 5
```

---

### floor {#floor}

Return floor (round down) of x.

**Signature:** `(floor x)`

**Examples:**
```lisp
(floor 3.7)   ; => 3
(floor -3.2)  ; => -4
```

**See also:** [ceiling](#ceiling), [truncate](#truncate), [round](#round)

---

### ceiling {#ceiling}

Return ceiling (round up) of x.

**Signature:** `(ceiling x)`

**Examples:**
```lisp
(ceiling 3.2)  ; => 4
(ceiling -3.7) ; => -3
```

**See also:** [floor](#floor), [truncate](#truncate), [round](#round)

---

### truncate {#truncate}

Return truncated (towards zero) value of x.

**Signature:** `(truncate x)`

**Examples:**
```lisp
(truncate 3.7)  ; => 3
(truncate -3.7) ; => -3
```

**See also:** [floor](#floor), [ceiling](#ceiling), [round](#round)

---

### round {#round}

Round x to given number of decimal places (default 0).

**Signature:** `(round x [digits 0])`

**Examples:**
```lisp
(round 3.567)    ; => 4
(round 3.567 2)  ; => 3.57
```

**See also:** [floor](#floor), [ceiling](#ceiling), [truncate](#truncate)

---

### signum {#signum}

Return sign of x: -1, 0, or 1.

**Signature:** `(signum x)`

**Examples:**
```lisp
(signum 42)    ; => 1
(signum -5)    ; => -1
(signum 0)     ; => 0
```

---

## Power, Roots, and Logarithms

### sqrt {#sqrt}

Return square root of x.

**Signature:** `(sqrt x)`

**Examples:**
```lisp
(sqrt 16)     ; => 4
(sqrt 2)      ; => 1.414...
```

**See also:** [expt](#expt)

---

### expt {#expt}

Return base raised to power.

**Signature:** `(expt base power)`

**Examples:**
```lisp
(expt 2 10)   ; => 1024
(expt 3 3)    ; => 27
```

**See also:** [sqrt](#sqrt)

---

### log {#log}

Return logarithm of x. With one argument,
returns natural log. With two, returns log to the given base.

**Signature:** `(log x [base #nil])`

**Examples:**
```lisp
(log 1)           ; => 0
(log (exp 1))     ; => 1.0
(log 100 10)      ; => 2.0
```

**See also:** [exp](#exp), [log10](#log10), [log2](#log2)

---

### exp {#exp}

Return e raised to power x.

**Signature:** `(exp x)`

**Examples:**
```lisp
(exp 0)       ; => 1
(exp 1)       ; => 2.718...
```

**See also:** [log](#log)

---

### log10 {#log10}

Return base-10 logarithm of x.

**Signature:** `(log10 x)`

**Examples:**
```lisp
(log10 100)   ; => 2
(log10 1000)  ; => 3
```

**See also:** [log](#log), [log2](#log2)

---

### log2 {#log2}

Return base-2 logarithm of x.

**Signature:** `(log2 x)`

**Examples:**
```lisp
(log2 8)      ; => 3
(log2 1024)   ; => 10
```

**See also:** [log](#log), [log10](#log10)

---

## Trigonometric Functions

### sin {#sin}

Return sine of x (in radians).

**Signature:** `(sin x)`

**Examples:**
```lisp
(sin 0)       ; => 0
(cos 0)       ; => 1
(tan 0)       ; => 0
```

---

### cos {#cos}

Return cosine of x (in radians).

**Signature:** `(cos x)`

---

### tan {#tan}

Return tangent of x (in radians).

**Signature:** `(tan x)`

---

### asin {#asin}

Return arcsine of x (in radians).

**Signature:** `(asin x)`

**Examples:**
```lisp
(asin 1)      ; => 1.5707... (pi/2)
(acos 1)      ; => 0
(atan 1)      ; => 0.7853... (pi/4)
```

---

### acos {#acos}

Return arccosine of x (in radians).

**Signature:** `(acos x)`

---

### atan {#atan}

Return arctangent of x (in radians).

**Signature:** `(atan x)`

---

### atan2 {#atan2}

Return arctangent of y/x (in radians), respecting quadrant.

**Signature:** `(atan2 y x)`

**Examples:**
```lisp
(atan2 1 1)   ; => 0.7853... (pi/4)
(atan2 -1 -1) ; => -2.356... (-3*pi/4)
```

---

## Integer Division

### quotient {#quotient}

Return integer quotient of x divided by y.

**Signature:** `(quotient x y)`

**Examples:**
```lisp
(quotient 10 3)   ; => 3
(quotient -10 3)  ; => -3
```

**See also:** [remainder](#remainder), [modulo](#modulo)

---

### remainder {#remainder}

Return remainder of x divided by y (same sign as x).

**Signature:** `(remainder x y)`

**Examples:**
```lisp
(remainder 10 3)   ; => 1
(remainder -10 3)  ; => -1
```

**See also:** [quotient](#quotient), [modulo](#modulo)

---

### modulo {#modulo}

Return modulo of x and y (same sign as y).

**Signature:** `(modulo x y)`

**Examples:**
```lisp
(modulo 10 3)    ; => 1
(modulo -10 3)   ; => 2
```

**See also:** [quotient](#quotient), [remainder](#remainder), [%](#modulo)

---

## Number Theory

### gcd {#gcd}

Return greatest common divisor of arguments.

**Signature:** `(gcd a b ...)`

**Examples:**
```lisp
(gcd 12 8)      ; => 4
(gcd 12 8 6)    ; => 2
```

**See also:** [lcm](#lcm)

---

### lcm {#lcm}

Return least common multiple of arguments.

**Signature:** `(lcm a b ...)`

**Examples:**
```lisp
(lcm 4 6)       ; => 12
(lcm 3 4 5)     ; => 60
```

**See also:** [gcd](#gcd)

---

## Migration from predicates Module

Numeric type predicates were previously in the `predicates` module. They are now in the `math` module:

```lisp
; Old (before reorganization)
(import predicates)

; New (after reorganization)
(import math)  ; for real?, complex?, rational?, exact?, inexact?
(import types) ; for number?
```

The function signatures and behavior remain unchanged.

