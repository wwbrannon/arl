---
title: "Standard Library: Math and Numeric Functions"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library: Math and Numeric Functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

These functions are provided by the `math` module (`inst/rye/math.rye`).

## Numeric Type Predicates

Rye implements a numeric tower adapted for R's type system:

```
number?    (is.numeric OR is.complex)
├─ complex?  (is.complex)
└─ real?     (is.numeric AND NOT is.complex)
   ├─ ±Inf   (real but not rational)
   └─ rational? (real? AND is.finite)
      └─ integer? (is.finite AND is.numeric AND x == as.integer(x))
         └─ natural? (integer? AND x >= 0)

Orthogonal predicates:
exact?   (is.integer - storage type)
inexact? (number? AND NOT is.integer)
```

**Note:** `number?` is provided by the `types` module, not `math`.

---

### real?

Tests if a value is a real number (includes infinities, excludes complex).

**Signature:** `(real? x)`

**Examples:**
```lisp
(real? 42)            ; => #t
(real? 3.14)          ; => #t
(real? Inf)           ; => #t
(real? (make-rectangular 3 4))  ; => #f
```

**See also:** rational?, complex?, number? (in `types` module)

---

### complex?

Tests if a value is a complex number.

**Signature:** `(complex? x)`

**Examples:**
```lisp
(complex? (make-rectangular 3 4))  ; => #t
(complex? 42)         ; => #f
```

**See also:** real?, number? (in `types` module), make-rectangular

---

### rational?

Tests if a value is a rational number (finite real number in R).

**Signature:** `(rational? x)`

**Examples:**
```lisp
(rational? 42)        ; => #t
(rational? 3.14)      ; => #t
(rational? Inf)       ; => #f (infinities are real but not rational)
(rational? NaN)       ; => #f
```

**Note:** In R, all finite floating-point numbers can be represented as rationals (IEEE 754). R does not have a built-in rational or decimal type like some Schemes.

**See also:** real?, integer?, number? (in `types` module)

---

### exact?

Tests if a number is exact (integer storage type in R).

**Signature:** `(exact? x)`

**Examples:**
```lisp
(exact? 5L)           ; => #t (integer type)
(exact? 5.0)          ; => #f (double type)
(exact? (->integer 5)); => #t
```

**Note:** In Scheme, exactness is a property of the number. In R (and Rye), exactness corresponds to integer storage type. All integers are exact; all doubles and complex numbers are inexact.

**See also:** inexact?, exact->inexact (in `conversions` module)

---

### inexact?

Tests if a number is inexact (double or complex storage type in R).

**Signature:** `(inexact? x)`

**Examples:**
```lisp
(inexact? 5.0)        ; => #t
(inexact? (make-rectangular 3 4))  ; => #t
(inexact? 5L)         ; => #f
```

**See also:** exact?, inexact->exact (in `conversions` module)

---

### integer?

Tests if a value is an integer-valued number.

**Signature:** `(integer? x)`

**Examples:**
```lisp
(integer? 42)         ; => #t
(integer? 42.0)       ; => #t (value is integer even if storage is double)
(integer? 3.14)       ; => #f
(integer? Inf)        ; => #f
```

**Note:** Tests for integer VALUE, not storage type. Use `exact?` to test storage type.

**See also:** natural?, exact?, rational?

---

### natural?

Tests if a value is a natural number (non-negative integer).

**Signature:** `(natural? x)`

**Examples:**
```lisp
(natural? 0)          ; => #t
(natural? 42)         ; => #t
(natural? -5)         ; => #f
(natural? 3.14)       ; => #f
```

**See also:** integer?, positive?, non-negative?

---

### finite?

Tests if a value is finite (not infinite or NaN).

**Signature:** `(finite? x)`

**Examples:**
```lisp
(finite? 42)          ; => #t
(finite? Inf)         ; => #f
(finite? NaN)         ; => #f
(finite? -Inf)        ; => #f
```

**See also:** infinite?, nan?, rational?

---

### infinite?

Tests if a value is infinite (±Inf).

**Signature:** `(infinite? x)`

**Examples:**
```lisp
(infinite? Inf)       ; => #t
(infinite? -Inf)      ; => #t
(infinite? 42)        ; => #f
(infinite? NaN)       ; => #f
```

**See also:** finite?, nan?

---

### nan?

Tests if a value is NaN (Not a Number).

**Signature:** `(nan? x)`

**Examples:**
```lisp
(nan? NaN)            ; => #t
(nan? (/ 0 0))        ; => #t (0/0 = NaN)
(nan? 42)             ; => #f
(nan? Inf)            ; => #f
```

**See also:** finite?, infinite?

---

## Value Predicates

### even?

Tests if a number is even.

**Signature:** `(even? x)`

**Examples:**
```lisp
(even? 4)             ; => #t
(even? 3)             ; => #f
(even? 0)             ; => #t
```

**See also:** odd?

---

### odd?

Tests if a number is odd.

**Signature:** `(odd? x)`

**Examples:**
```lisp
(odd? 3)              ; => #t
(odd? 4)              ; => #f
```

**See also:** even?

---

### zero?

Tests if a number equals zero.

**Signature:** `(zero? x)`

**Examples:**
```lisp
(zero? 0)             ; => #t
(zero? 0.0)           ; => #t
(zero? 1)             ; => #f
```

**See also:** positive?, negative?

---

### positive?

Tests if a number is greater than zero.

**Signature:** `(positive? x)`

**Examples:**
```lisp
(positive? 5)         ; => #t
(positive? 0)         ; => #f
(positive? -5)        ; => #f
```

**See also:** negative?, non-negative?, zero?

---

### negative?

Tests if a number is less than zero.

**Signature:** `(negative? x)`

**Examples:**
```lisp
(negative? -5)        ; => #t
(negative? 0)         ; => #f
(negative? 5)         ; => #f
```

**See also:** positive?, non-positive?, zero?

---

### non-negative?

Tests if a number is greater than or equal to zero.

**Signature:** `(non-negative? x)`

**Examples:**
```lisp
(non-negative? 5)     ; => #t
(non-negative? 0)     ; => #t
(non-negative? -5)    ; => #f
```

**See also:** positive?, natural?

---

### non-positive?

Tests if a number is less than or equal to zero.

**Signature:** `(non-positive? x)`

**Examples:**
```lisp
(non-positive? -5)    ; => #t
(non-positive? 0)     ; => #t
(non-positive? 5)     ; => #f
```

**See also:** negative?

---

## Complex Number Utilities

### make-rectangular

Constructs a complex number from real and imaginary parts.

**Signature:** `(make-rectangular real imag)`

**Examples:**
```lisp
(make-rectangular 3 4)  ; => 3+4i
```

**See also:** make-polar, real-part, imag-part

---

### make-polar

Constructs a complex number from polar coordinates (magnitude and angle).

**Signature:** `(make-polar magnitude angle)`

**Examples:**
```lisp
(make-polar 5 0)      ; => 5+0i
```

**See also:** make-rectangular, magnitude, angle

---

### real-part

Extracts the real part of a complex number.

**Signature:** `(real-part z)`

**Examples:**
```lisp
(real-part (make-rectangular 3 4))  ; => 3.0
```

**See also:** imag-part, make-rectangular

---

### imag-part

Extracts the imaginary part of a complex number.

**Signature:** `(imag-part z)`

**Examples:**
```lisp
(imag-part (make-rectangular 3 4))  ; => 4.0
```

**See also:** real-part, make-rectangular

---

### magnitude

Computes the magnitude (modulus) of a complex number.

**Signature:** `(magnitude z)`

**Examples:**
```lisp
(magnitude (make-rectangular 3 4))  ; => 5.0
```

**See also:** angle, make-polar

---

### angle

Computes the angle (argument) of a complex number in radians.

**Signature:** `(angle z)`

**Examples:**
```lisp
(angle (make-rectangular 1 1))  ; => 0.7853981633974483 (π/4)
```

**See also:** magnitude, make-polar

---

## Arithmetic Helpers

### inc

Increment a number.

**Signature:** `(inc x [n 1])`

**Examples:**
```lisp
(inc 5)       ; => 6
(inc 5 3)     ; => 8
```

**See also:** dec

---

### dec

Decrement a number.

**Signature:** `(dec x [n 1])`

**Examples:**
```lisp
(dec 5)       ; => 4
(dec 5 3)     ; => 2
```

**See also:** inc

---

### clamp

Clamp a value to an inclusive range.

**Signature:** `(clamp x lo hi)`

**Examples:**
```lisp
(clamp 5 0 10)   ; => 5
(clamp -3 0 10)  ; => 0
(clamp 15 0 10)  ; => 10
```

**See also:** within?

---

### within?

Test if a value is within an inclusive range.

**Signature:** `(within? x lo hi)`

**Examples:**
```lisp
(within? 5 0 10)   ; => #t
(within? -3 0 10)  ; => #f
(within? 10 0 10)  ; => #t
```

**See also:** clamp

---

## Rounding and Truncation

### abs

Return absolute value.

**Signature:** `(abs x)`

**Examples:**
```lisp
(abs -5)      ; => 5
(abs 5)       ; => 5
```

---

### floor

Round down to nearest integer.

**Signature:** `(floor x)`

**Examples:**
```lisp
(floor 3.7)   ; => 3
(floor -3.2)  ; => -4
```

**See also:** ceiling, truncate, round

---

### ceiling

Round up to nearest integer.

**Signature:** `(ceiling x)`

**Examples:**
```lisp
(ceiling 3.2)  ; => 4
(ceiling -3.7) ; => -3
```

**See also:** floor, truncate, round

---

### truncate

Truncate toward zero.

**Signature:** `(truncate x)`

**Examples:**
```lisp
(truncate 3.7)  ; => 3
(truncate -3.7) ; => -3
```

**See also:** floor, ceiling, round

---

### round

Round to given number of decimal places (default 0).

**Signature:** `(round x [digits 0])`

**Examples:**
```lisp
(round 3.567)    ; => 4
(round 3.567 2)  ; => 3.57
```

**See also:** floor, ceiling, truncate

---

### signum

Return the sign of a number: -1, 0, or 1.

**Signature:** `(signum x)`

**Examples:**
```lisp
(signum 42)    ; => 1
(signum -5)    ; => -1
(signum 0)     ; => 0
```

---

## Power, Roots, and Logarithms

### sqrt

Return square root.

**Signature:** `(sqrt x)`

**Examples:**
```lisp
(sqrt 16)     ; => 4
(sqrt 2)      ; => 1.414...
```

**See also:** expt

---

### expt

Raise base to a power.

**Signature:** `(expt base power)`

**Examples:**
```lisp
(expt 2 10)   ; => 1024
(expt 3 3)    ; => 27
```

**See also:** sqrt

---

### log

Natural logarithm, or logarithm to a given base.

**Signature:** `(log x [base])`

**Examples:**
```lisp
(log 1)           ; => 0
(log (exp 1))     ; => 1.0
(log 100 10)      ; => 2.0
```

**See also:** exp, log10, log2

---

### exp

Return e raised to a power.

**Signature:** `(exp x)`

**Examples:**
```lisp
(exp 0)       ; => 1
(exp 1)       ; => 2.718...
```

**See also:** log

---

### log10

Base-10 logarithm.

**Signature:** `(log10 x)`

**Examples:**
```lisp
(log10 100)   ; => 2
(log10 1000)  ; => 3
```

**See also:** log, log2

---

### log2

Base-2 logarithm.

**Signature:** `(log2 x)`

**Examples:**
```lisp
(log2 8)      ; => 3
(log2 1024)   ; => 10
```

**See also:** log, log10

---

## Trigonometric Functions

### sin / cos / tan

Standard trigonometric functions (argument in radians).

**Signatures:** `(sin x)`, `(cos x)`, `(tan x)`

**Examples:**
```lisp
(sin 0)       ; => 0
(cos 0)       ; => 1
(tan 0)       ; => 0
```

---

### asin / acos / atan

Inverse trigonometric functions (result in radians).

**Signatures:** `(asin x)`, `(acos x)`, `(atan x)`

**Examples:**
```lisp
(asin 1)      ; => 1.5707... (pi/2)
(acos 1)      ; => 0
(atan 1)      ; => 0.7853... (pi/4)
```

---

### atan2

Two-argument arctangent, respecting quadrant.

**Signature:** `(atan2 y x)`

**Examples:**
```lisp
(atan2 1 1)   ; => 0.7853... (pi/4)
(atan2 -1 -1) ; => -2.356... (-3*pi/4)
```

---

## Integer Division

### quotient

Integer quotient (truncated toward zero).

**Signature:** `(quotient x y)`

**Examples:**
```lisp
(quotient 10 3)   ; => 3
(quotient -10 3)  ; => -3
```

**See also:** remainder, modulo

---

### remainder

Remainder after integer division (same sign as dividend).

**Signature:** `(remainder x y)`

**Examples:**
```lisp
(remainder 10 3)   ; => 1
(remainder -10 3)  ; => -1
```

**See also:** quotient, modulo

---

### modulo

Modulo operation (same sign as divisor).

**Signature:** `(modulo x y)`

**Examples:**
```lisp
(modulo 10 3)    ; => 1
(modulo -10 3)   ; => 2
```

**See also:** quotient, remainder, %

---

## Number Theory

### gcd

Greatest common divisor (variadic).

**Signature:** `(gcd a b ...)`

**Examples:**
```lisp
(gcd 12 8)      ; => 4
(gcd 12 8 6)    ; => 2
```

**See also:** lcm

---

### lcm

Least common multiple (variadic).

**Signature:** `(lcm a b ...)`

**Examples:**
```lisp
(lcm 4 6)       ; => 12
(lcm 3 4 5)     ; => 60
```

**See also:** gcd

---

## Migration from predicates Module

Numeric type predicates were previously in the `predicates` module. They are now in the `math` module:

```lisp
; Old (before reorganization)
(import predicates)

; New (after reorganization)
(import math)  ; for real?, complex?, rational?, exact?, inexact?
(import types) ; for number?
```

The function signatures and behavior remain unchanged.
