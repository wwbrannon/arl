---
title: "R Interop and Data Workflows"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{R Interop and Data Workflows}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Rye can call any R function directly. Function names, operators, and data
structures are shared between Rye and R.

## Calling R functions

```lisp
(mean (c 1 2 3 4 5))
(seq :from 1 :to 10 :by 2)
```

Keywords (`:from`, `:to`) map to named arguments in R.

### Keyword syntax

Keywords starting with `:` serve a dual purpose in Rye:

1. **As named argument syntax**: Bare keywords in function calls become named arguments
   ```lisp
   (seq :from 1 :to 10)  ; R: seq(from = 1, to = 10)
   ```

2. **As self-evaluating values**: Keywords are first-class values that can be bound to variables
   ```lisp
   :keyword          ; evaluates to a keyword object
   (define k :foo)   ; bind a keyword to a variable
   ```

To pass a keyword as a *value* (rather than as named argument syntax), quote it:

```lisp
(= ':foo ':bar)     ; compares two keywords as values → FALSE
(= ':foo ':foo)     ; → TRUE

(= :foo :bar)       ; error: tries to call = with named argument 'foo'
```

This design allows keywords to work naturally with R's named arguments while
remaining first-class values when needed.

You can also call functions via `r/call` if you need to pass a name
programmatically:

```lisp
(r/call "sum" (list 1 2 3))
```

## Working with formulas

```lisp
(lm (~ y x) :data df)
```

The `~` special form builds an R formula without evaluating its arguments.

## Accessing R objects

```lisp
($ mylist field)
([ vector 1)
```

Use `::` and `:::` to access R packages:

```lisp
(:: stats median)
(::: stats .lm.fit)
```

R base operators are also available directly:

```lisp
(+ 1 2 3)
(< 3 5)
```

### Numeric edge cases

Because Rye delegates to R for numeric operations, edge cases follow R
semantics (not Scheme's). For example, division by zero yields `Inf`, and
`NaN` comparisons propagate `NA`:

```lisp
(/ 1 0)         ; => Inf
(== NaN NaN)    ; => NA
```

## Example workflow

The [data analysis example](examples.html#data-analysis) shows a small analysis pipeline
from Rye that uses `data.frame`, `mean`, and `lm`. You can run it with:

```{r eval=FALSE}
engine <- RyeEngine$new()
engine$load_file(system.file("examples", "data-analysis.rye", package = "rye"))
```

## Standard library helpers

The stdlib exposes helpers like `map`, `filter`, `reduce`, and threading macros
(`->`, `->>`). See the `Standard Library Overview` and reference pages for the
full list.

## Related guides

- [Getting Started](getting-started.html)
- [Macros and Quasiquote](macros.html)
- [Standard Library Overview](stdlib-reference.html)
