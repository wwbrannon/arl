---
title: "R Interop and Data Workflows"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{R Interop and Data Workflows}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Arl can call any R function directly. Function names, operators, and data
structures are shared between Arl and R.

## Calling R functions

```lisp
(mean (c 1 2 3 4 5))
(seq :from 1 :to 10 :by 2)
```

Keywords (`:from`, `:to`) map to named arguments in R.

### Keyword syntax

Keywords starting with `:` serve a dual purpose in Arl:

1. **As named argument syntax**: Bare keywords in function calls become named arguments
   ```lisp
   (seq :from 1 :to 10)  ; R: seq(from = 1, to = 10)
   ```

2. **As self-evaluating values**: Keywords are first-class values that can be bound to variables
   ```lisp
   :keyword          ; evaluates to a keyword object
   (define k :foo)   ; bind a keyword to a variable
   ```

To pass a keyword as a *value* (rather than as named argument syntax), quote it:

```lisp
(= ':foo ':bar)     ; compares two keywords as values → FALSE
(= ':foo ':foo)     ; → TRUE

(= :foo :bar)       ; error: tries to call = with named argument 'foo'
```

This design allows keywords to work naturally with R's named arguments while
remaining first-class values when needed.

You can also call functions via `r/call` if you need to pass a name
programmatically:

```lisp
(r/call "sum" (list 1 2 3))
```

### Non-standard evaluation

Some R functions use non-standard evaluation (NSE) - they expect expressions
that they will evaluate in a controlled context, rather than pre-evaluated
values. Examples include `tryCatch`, `substitute`, `with`, and `eval`.

When using `r/call` with NSE functions, arguments are evaluated **before**
being passed to the R function (via `do.call`). This causes issues with
functions like `tryCatch` that need to control when evaluation happens.

**The solution**: Build an unevaluated call expression and evaluate it with `r/eval`:

```lisp
;; WRONG - thunk is evaluated before tryCatch can catch errors
(r/call "tryCatch"
  (list :expr (thunk) :error (lambda (e) #t)))

;; CORRECT - build unevaluated expression, then eval it
(define thunk-expr (call (list thunk)))     ; unevaluated call
(r/eval (call (list 'tryCatch thunk-expr    ; 'tryCatch = quoted symbol
                    :error (lambda (e) #t)))
        (current-env))
```

**Key points:**

1. Use Arl's `call` function to build unevaluated call expressions
2. Use a quoted symbol (`'tryCatch`) not a string (`"tryCatch"`)
3. Use `r/eval` (not `r/call`) to evaluate the constructed expression
4. Pass `(current-env)` as the evaluation environment

This pattern is used throughout the stdlib - see `try*` in `control.arl` and
`assert-error` in `assert.arl` for working examples.

#### Detecting errors with a sentinel value

When wrapping error-prone code, you need to distinguish "the error handler ran"
from "the code succeeded and happened to return the same value". Use `gensym`
to create a unique sentinel:

```lisp
(define error-caught (gensym "error-caught"))  ; unique symbol
(define result
  (r/eval (call (list 'tryCatch thunk-expr
                      :error (lambda (e) error-caught)))
          (current-env)))
;; Check if error-caught is identical to result
(if (identical? result error-caught)
  "error was caught"
  "code ran successfully")
```

## Working with formulas

```lisp
(lm (~ y x) :data df)
```

The `~` special form builds an R formula without evaluating its arguments.

## Accessing R objects

```lisp
($ mylist field)
([ vector 1)
```

Use `::` and `:::` to access R packages:

```lisp
(:: stats median)
(::: stats .lm.fit)
```

R base operators are also available directly:

```lisp
(+ 1 2 3)
(< 3 5)
```

### Numeric edge cases

Because Arl delegates to R for numeric operations, edge cases follow R
semantics (not Scheme's). For example, division by zero yields `Inf`, and
`NaN` comparisons propagate `NA`:

```lisp
(/ 1 0)         ; => Inf
(== NaN NaN)    ; => NA
```

## Example workflow

The [data analysis example](examples.html#data-analysis) shows a small analysis pipeline
from Arl that uses `data.frame`, `mean`, and `lm`. You can run it with:

```{r eval=FALSE}
engine <- Engine$new()
engine$load_file(system.file("examples", "data-analysis.arl", package = "arl"))
```

## Standard library helpers

The stdlib exposes helpers like `map`, `filter`, `reduce`, and threading macros
(`->`, `->>`). See the `Standard Library Overview` and reference pages for the
full list.

## Related guides

- [Getting Started](getting-started.html)
- [Macros and Quasiquote](macros.html)
- [Standard Library Overview](stdlib-reference.html)
