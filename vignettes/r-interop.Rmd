---
title: "R Interop and Data Workflows"
output: arl::arl_html_vignette
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{R Interop and Data Workflows}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
arl::register_knitr_engine()
```

Arl can call any R function directly. Function names, operators, and data
structures are shared between Arl and R.

## Calling R functions

```{arl}
(mean (c 1 2 3 4 5))
(seq :from 1 :to 10 :by 2)
```

```{arl, include=FALSE}
(assert-equal 3 (mean (c 1 2 3 4 5)))
```

Keywords (`:from`, `:to`) map to named arguments in R.

### Keyword syntax

Keywords starting with `:` serve a dual purpose in Arl:

1. **As named argument syntax**: Bare keywords in function calls become named arguments
   ```{arl}
   (seq :from 1 :to 10)  ; R: seq(from = 1, to = 10)
   ```
   ```{arl, include=FALSE}
   (assert-equal (c 1 2 3 4 5 6 7 8 9 10) (seq :from 1 :to 10))
   ```

2. **As self-evaluating values**: Keywords are first-class values that can be bound to variables
   ```{arl}
   :keyword          ; evaluates to a keyword object
   (define k :foo)   ; bind a keyword to a variable
   ```
   ```{arl, include=FALSE}
   (assert-true (keyword? ':foo))
   ```

To pass a keyword as a *value* (rather than as named argument syntax), quote it:

```{arl, eval=FALSE}
(equal? ':foo ':bar)     ; compares two keyword values → #f
(equal? ':foo ':foo)     ; → #t

(equal? :foo :bar)       ; error: bare keywords become named arguments
```

```{arl, include=FALSE}
(assert-false (equal? ':foo ':bar))
(assert-true (equal? ':foo ':foo))
(assert-error (lambda () (equal? :foo :bar)))
```

This design allows keywords to work naturally with R's named arguments while
remaining first-class values when needed.

You can also call functions via `r/call` if you need to pass a name
programmatically:

```{arl}
(r/call "sum" (list 1 2 3))
```

```{arl, include=FALSE}
(assert-equal 6 (r/call "sum" (list 1 2 3)))
```

### Non-standard evaluation

Some R functions use non-standard evaluation (NSE) - they expect expressions
that they will evaluate in a controlled context, rather than pre-evaluated
values. Examples include `tryCatch`, `substitute`, `with`, and `eval`.

When using `r/call` with NSE functions, arguments are evaluated **before**
being passed to the R function (via `do.call`). This causes issues with
functions like `tryCatch` that need to control when evaluation happens.

**The solution**: Build an unevaluated call expression and evaluate it with `r/eval`:

```{arl, eval=FALSE}
;; WRONG - thunk is evaluated before tryCatch can catch errors
(r/call "tryCatch"
  (list :expr (thunk) :error (lambda (e) #t)))

;; CORRECT - build unevaluated expression, then eval it
(define thunk-expr (call (list thunk)))     ; unevaluated call
(r/eval (call (list 'tryCatch thunk-expr    ; 'tryCatch = quoted symbol
                    :error (lambda (e) #t)))
        (current-env))
```

```{arl, include=FALSE}
;; Verify the correct NSE tryCatch pattern works
(define __nse-thunk (lambda () (error "test error")))
(define __nse-thunk-expr (call (list __nse-thunk)))
(define __nse-result
  (r/eval (call (list 'tryCatch __nse-thunk-expr
                      :error (lambda (e) "caught")))
          (current-env)))
(assert-equal "caught" __nse-result)
```

**Key points:**

1. Use Arl's `call` function to build unevaluated call expressions
2. Use a quoted symbol (`'tryCatch`) not a string (`"tryCatch"`)
3. Use `r/eval` (not `r/call`) to evaluate the constructed expression
4. Pass `(current-env)` as the evaluation environment

This pattern is used throughout the stdlib - see `try*` in `control.arl` and
`assert-error` in `assert.arl` for working examples.

#### Detecting errors with a sentinel value

When wrapping error-prone code, you need to distinguish "the error handler ran"
from "the code succeeded and happened to return the same value". Use `gensym`
to create a unique sentinel:

```{arl, eval=FALSE}
(define error-caught (gensym "error-caught"))  ; unique symbol
(define result
  (r/eval (call (list 'tryCatch thunk-expr
                      :error (lambda (e) error-caught)))
          (current-env)))
;; Check if error-caught is identical to result
(if (identical? result error-caught)
  "error was caught"
  "code ran successfully")
```

```{arl, include=FALSE}
;; Verify sentinel pattern with a concrete thunk that errors
(define __sentinel (gensym "error-caught"))
(define __err-thunk (lambda () (error "boom")))
(define __err-thunk-expr (call (list __err-thunk)))
(define __sentinel-result
  (r/eval (call (list 'tryCatch __err-thunk-expr
                      :error (lambda (e) __sentinel)))
          (current-env)))
(assert-true (identical? __sentinel-result __sentinel))
```

## Working with formulas

```{arl, eval=FALSE}
(lm (~ y x) :data df)
```

The `~` special form builds an R formula without evaluating its arguments.

## Accessing R objects

```{arl, eval=FALSE}
($ mylist field)
([ vector 1)
```

Use `::` and `:::` to access R packages:

```{arl}
(:: stats median)
(::: stats .lm.fit)
```

```{arl, include=FALSE}
(assert-true (is.function (:: stats median)))
(assert-true (is.function (::: stats .lm.fit)))
```

R base operators are also available directly:

```{arl}
(+ 1 2 3)
(< 3 5)
```

```{arl, include=FALSE}
(assert-equal 6 (+ 1 2 3))
(assert-true (< 3 5))
```

### Numeric edge cases

Because Arl delegates to R for numeric operations, edge cases follow R
semantics (not Scheme's). For example, division by zero yields `Inf`, and
`NaN` comparisons propagate `NA`:

```{arl}
(/ 1 0)         ; => Inf
(== NaN NaN)    ; => NA
```

```{arl, include=FALSE}
(assert-true (is.infinite (/ 1 0)))
(assert-true (is.na (== NaN NaN)))
```

## Example workflow

The [data analysis example](examples.html#data-analysis) shows a small analysis pipeline
from Arl that uses `data.frame`, `mean`, and `lm`. You can run it with:

```{r eval=FALSE}
engine <- Engine$new()
engine$load_file_under_env(system.file("examples", "data-analysis.arl", package = "arl"))
```

## Standard library helpers

The stdlib exposes helpers like `map`, `filter`, `reduce`, and threading macros
(`->`, `->>`). See the `Standard Library Overview` and reference pages for the
full list.

## Related guides

- [Getting Started](getting-started.html)
- [Macros and Quasiquote](macros.html)
- [Standard Library Overview](stdlib-reference.html)
