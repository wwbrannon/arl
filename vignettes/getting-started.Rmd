---
title: "Getting Started"
output: arl::arl_html_vignette
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
arl::register_knitr_engine()
```

Arl is a Lisp dialect implemented in and with access to R. This vignette
walks through installing Arl, running the REPL, and evaluating a few
expressions.

## Installation

```{r eval=FALSE}
devtools::install()
```

## Start the REPL

```{r eval=FALSE}
library(arl)
engine <- Engine$new()
engine$repl()
```

The engine loads the base stdlib automatically.

At the prompt, you can enter Arl expressions:

```{arl}
(+ 1 2)
(define x 10)
(* x 2)
```

## Run from the command line

Install the CLI wrapper once after installing the package:

```{r eval=FALSE}
arl::install_cli()
```

Then you can evaluate code without opening R:

```bash
arl --eval "(+ 1 2)"
arl --file script.arl
arl -q
```

You can also pass multiple files; they run in order. Use `-q` or `--quiet` to start the REPL with a minimal banner.

**REPL options (when running from R):** You can control the REPL with options before calling `engine$repl()`: `arl.repl_quiet` (minimal banner), `arl.repl_use_history` (set to `FALSE` to avoid touching R's readline history), and `arl.repl_bracketed_paste` (enable/disable bracketed paste mode for cleaner multiline pastes).

## Evaluate Arl from R

If you want to evaluate Arl inside an R script, you can parse and evaluate
expressions directly:

```{r eval=FALSE}
engine <- Engine$new()
exprs <- engine$read("(define x 10) (+ x 5)")
engine$eval(exprs[[1]])
engine$eval(exprs[[2]])
```

If you have multiple expressions, `engine$eval_exprs()` will evaluate them
sequentially and return the last value.

## Run Arl files

From the REPL, use `load` to run a file in the current environment so that its definitions are visible:

```{arl, eval=FALSE}
(load "script.arl")
```

From R, `engine$load_file(path)` runs the file in an *isolated* environment: definitions and imports in that file are not visible in the engine's main environment or to later code. Use this when you want to execute a script without affecting the session (e.g. run a script and then continue in the REPL with a clean scope). To run a file and have its definitions visible in the engine (e.g. for use in the REPL), call `engine$load_file_in_env(path, engine$env$env)` or evaluate `(load "script.arl")` from the REPL.

```{r eval=FALSE}
engine <- Engine$new()
engine$load_file("script.arl")  # isolated; definitions not visible
# Or, to make definitions visible in the engine:
engine$load_file_in_env("script.arl", engine$env$env)
```

## Loading stdlib modules

The engine loads all stdlib modules automatically, so functions like `when`,
`let`, `for`, `->`, and `try` are available immediately. If you want to
understand the module structure or are working with a bare engine, you can
import modules explicitly:

```{arl, eval=FALSE}
(import control)   ; when/unless/cond/case
(import binding)   ; let/let*/letrec
(import looping)   ; for/loop/recur/until
(import threading) ; -> and ->>
(import error)     ; try/catch/finally
```

See [Modules and Imports](modules.html) for details on creating and importing
modules.

## Core syntax

```{arl}
; Function definition
(define factorial
  (lambda (n)
    (if (< n 2)
      1
      (* n (factorial (- n 1))))))

; Lambda destructuring (pattern wrapper keeps defaults unambiguous)
(define sum-pair
  (lambda ((pattern (a b)))
    (+ a b)))

; Dotted rest destructuring
(define head-tail
  (lambda (x . (pattern (a b)))
    (list x a b)))

; Lists
(list 1 2 3)
(car (list 1 2 3))
(cdr (list 1 2 3))

; Quoting
'(+ 1 2)           ; => (+ 1 2)
`(list ,x 20 30)   ; => (list 10 20 30)

; Comments start with semicolon
; This line is ignored
```

For more details on the standard library and macros, see the other vignettes in
this package.

## Getting help

Arl has a built-in help system. Use `help` with a string to look up any
special form, macro, or function:

```{arl, eval=FALSE}
(help "define")   ; special form
(help "when")     ; macro -- shows docs and usage
(help "map")      ; stdlib function
```

For functions with documentation, `help` shows the signature, description,
examples, and cross-references automatically. It also falls through to R's
built-in help for R functions.

## Documenting functions

Arl has two ways to attach documentation to functions: `;;'` annotation
comments (used at definition time) and the `doc!` builtin (used at
runtime). Both produce the same `arl_doc` attribute on the function, which
`help` and `doc` read.

### Annotation comments (`;;'`)

Annotation comments use the `;;'` prefix and support roxygen-like tags.
Place them immediately before a `define`:

```{arl}
;;' @description Compute the square of x.
;;' @examples
;;' (square 3)   ; => 9
;;' (square -2)  ; => 4
;;' @seealso cube, expt
;;' @note Pure function; no side effects.
(define square
  (lambda (x) (* x x)))
```

Supported tags:

| Tag | Purpose |
|-----|---------|
| `@description` | One-line or multi-line description. If omitted, the parser falls back to a `(doc! ...)` call. |
| `@examples` | One or more example expressions (one per continuation line). |
| `@seealso` | Comma-separated list of related function names. |
| `@note` | Additional notes (caveats, performance, history). |
| `@signature` | Override the auto-detected call signature. |
| `@section` | Section heading for grouping functions in generated docs. |

Multi-line content is written with continuation `;;'` lines:

```{arl, eval=FALSE}
;;' @description Concatenate strings with a separator.
;;'   Accepts any number of string arguments.
;;' @examples
;;' (string-join ", " '("a" "b" "c"))  ; => "a, b, c"
;;' (string-join "" '("x" "y"))        ; => "xy"
(define string-join ...)
```

The compiler reads `;;'` blocks at compile time and bakes the resulting
documentation into the function's `arl_doc` attribute, so no runtime
overhead is incurred. This is the recommended way to document stdlib
functions and module exports.

### Runtime documentation with `doc!`

`doc!` attaches documentation fields to an already-defined function. It
is useful for interactive work, dynamically generated functions, or adding
fields incrementally:

```{arl}
(define double (lambda (x) (* x 2)))

; Set just the description (backward-compatible form)
(doc! double "Double the input value.")

; Set specific fields with keyword arguments
(doc! double :examples "(double 3) ; => 6")
(doc! double :note "Pure function.")

; Set multiple fields at once
(doc! double :description "Double x." :examples "(double 5) ; => 10")
```

`doc!` **merges** with existing documentation â€” setting `:examples` does
not erase a previously set `:description`.

### Retrieving documentation with `doc`

`doc` reads fields from a function's documentation:

```{arl}
(doc double)              ; => "Double x." (description, the default)
(doc double "examples")   ; => "(double 5) ; => 10"
(doc double "note")       ; => "Pure function."
(doc double "all")        ; => named list of all fields
```

### Which mechanism to use

| Situation | Use |
|-----------|-----|
| Defining a function in a `.arl` source file | `;;'` annotations |
| Attaching docs interactively in the REPL | `doc!` or `;;'` |
| Building docs dynamically from data | `doc!` with keyword args |
| Reading docs programmatically | `doc` |
| Looking up docs as a user | `help` |

Both `;;'` and `doc!` produce the same `arl_doc` attribute, so `help`
and `doc` work identically regardless of how the documentation was
attached.

## Next steps

- [Modules and Imports](modules.html)
- [Macros and Quasiquote](macros.html)
- [R Interop and Data Workflows](r-interop.html)
- [Standard Library Overview](stdlib-reference.html)
