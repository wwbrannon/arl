---
title: "Getting Started"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Rye is a Lisp dialect implemented in and with access to R. This vignette
walks through installing Rye, running the REPL, and evaluating a few
expressions.

## Installation

```{r eval=FALSE}
devtools::install()
```

## Start the REPL

```{r eval=FALSE}
library(rye)
engine <- RyeEngine$new()
engine$repl()
```

The engine loads the base stdlib automatically.

At the prompt, you can enter Rye expressions:

```lisp
(+ 1 2)
(define x 10)
(* x 2)
```

## Run from the command line

Install the CLI wrapper once after installing the package:

```{r eval=FALSE}
rye::rye_install_cli()
```

Then you can evaluate code without opening R:

```bash
rye --eval "(+ 1 2)"
rye --file script.rye
rye -q
```

You can also pass multiple files; they run in order. Use `-q` or `--quiet` to start the REPL with a minimal banner.

**REPL options (when running from R):** You can control the REPL with options before calling `engine$repl()`: `rye.repl_quiet` (minimal banner), `rye.repl_use_history` (set to `FALSE` to avoid touching R's readline history), and `rye.repl_bracketed_paste` (enable/disable bracketed paste mode for cleaner multiline pastes).

## Evaluate Rye from R

If you want to evaluate Rye inside an R script, you can parse and evaluate
expressions directly:

```{r eval=FALSE}
engine <- RyeEngine$new()
exprs <- engine$read("(define x 10) (+ x 5)")
engine$eval(exprs[[1]])
engine$eval(exprs[[2]])
```

If you have multiple expressions, `engine$eval_exprs()` will evaluate them
sequentially and return the last value.

## Run Rye files

From the REPL, use `load` to run a file in the current environment so that its definitions are visible:

```lisp
(load "script.rye")
```

From R, `engine$load_file(path)` runs the file in an *isolated* environment: definitions and imports in that file are not visible in the engine's main environment or to later code. Use this when you want to execute a script without affecting the session (e.g. run a script and then continue in the REPL with a clean scope). To run a file and have its definitions visible in the engine (e.g. for use in the REPL), call `engine$load_file_in_env(path, engine$env$env)` or evaluate `(load "script.rye")` from the REPL.

```{r eval=FALSE}
engine <- RyeEngine$new()
engine$load_file("script.rye")  # isolated; definitions not visible
# Or, to make definitions visible in the engine:
engine$load_file_in_env("script.rye", engine$env$env)
```

## Loading stdlib modules

The engine loads all stdlib modules automatically, so functions like `when`,
`let`, `for`, `->`, and `try` are available immediately. If you want to
understand the module structure or are working with a bare engine, you can
import modules explicitly:

```lisp
(import control)   ; when/unless/cond/case
(import binding)   ; let/let*/letrec
(import looping)   ; for/loop/recur/until
(import threading) ; -> and ->>
(import error)     ; try/catch/finally
```

See [Modules and Imports](modules.html) for details on creating and importing
modules.

## Core syntax

```lisp
; Function definition
(define factorial
  (lambda (n)
    (if (< n 2)
      1
      (* n (factorial (- n 1))))))

; Lambda destructuring (pattern wrapper keeps defaults unambiguous)
(define sum-pair
  (lambda ((pattern (a b)))
    (+ a b)))

; Dotted rest destructuring
(define head-tail
  (lambda (x . (pattern (a b)))
    (list x a b)))

; Lists
(list 1 2 3)
(car (list 1 2 3))
(cdr (list 1 2 3))

; Quoting
'(+ 1 2)           ; => (+ 1 2)
`(list ,x 20 30)   ; => (list 10 20 30)

; Comments start with semicolon
; This line is ignored
```

For more details on the standard library and macros, see the other vignettes in
this package.

## Getting help

Rye has a built-in help system. Use `help` with a string to look up any
special form, macro, or function:

```lisp
(help "define")   ; special form
(help "when")     ; macro -- shows docstring and usage
(help "map")      ; stdlib function
```

For macros and functions defined with docstrings, `help` shows the signature
and description automatically. It also falls through to R's built-in help for
R functions.

You can also work with docstrings programmatically:

```lisp
(doc map)              ; retrieve the docstring from a function
(doc! my-fn "Does X") ; attach a docstring to an existing function
```

## Next steps

- [Modules and Imports](modules.html)
- [Macros and Quasiquote](macros.html)
- [R Interop and Data Workflows](r-interop.html)
- [Standard Library Overview](stdlib-reference.html)
