---
title: "Getting Started"
output: arl::arl_html_vignette
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
arl::register_knitr_engine()
```

Arl is a Lisp dialect implemented in and with access to R. This vignette
walks through installing Arl, running the REPL, and evaluating a few
expressions.

## Installation

```{r eval=FALSE}
# install.packages("arl")
devtools::install_github("wwbrannon/arl")
```

Arl is not yet on CRAN; install from GitHub with `devtools` as shown
above. Once a CRAN release is available, `install.packages("arl")` will
work. If you have a local clone of the repository, `devtools::install()`
from the repo directory also works.

## Start the REPL

```{r eval=FALSE}
library(arl)
engine <- Engine$new()
engine$repl()
```

The engine loads all stdlib modules automatically, so functions like `when`,
`let`, `map`, and `->` are available immediately.

At the prompt, you can enter Arl expressions:

```{arl}
(+ 1 2)
(define x 10)
(* x 2)
```

Type `(quit)` or press Ctrl+C to exit the REPL.

**REPL options:** You can control the REPL with options before calling
`engine$repl()`: `arl.repl_quiet` (minimal banner),
`arl.repl_use_history` (set to `FALSE` to avoid touching R's readline
history), and `arl.repl_bracketed_paste` (enable/disable bracketed paste
mode for cleaner multiline pastes).

## Run from the command line

Install the CLI wrapper once after installing the package:

```{r eval=FALSE}
arl::install_cli()
```

Then you can evaluate code without opening R:

```bash
arl --eval "(+ 1 2)"
arl --file script.arl
arl -q                    # quiet REPL (minimal banner)
arl --help                # see all options
```

You can also pass multiple files; they run in order in a shared engine, so
definitions from earlier files are visible to later ones. Use
`--no-stdlib` to start a bare engine without stdlib modules.

## Evaluate Arl from R

The simplest way to evaluate Arl inside an R script is `eval_text`, which
reads and evaluates in one step:

```{r eval=FALSE}
engine <- Engine$new()
engine$eval_text("(define x 10) (+ x 5)")
```

For finer control, you can parse and evaluate separately:

```{r eval=FALSE}
exprs <- engine$read("(define x 10) (+ x 5)")
engine$eval(exprs[[1]], exprs[[2]])
```

`eval()` accepts multiple expressions and evaluates them sequentially,
returning the last value.

## Run Arl files

From the REPL, use `load` to run a file in the current environment so that
its definitions are visible:

```{arl, eval=FALSE}
(load "script.arl")
```

Use `run` to execute a file in an isolated child environment (definitions
are not visible to later code):

```{arl, eval=FALSE}
(run "script.arl")
```

From R, `load_file_in_env` and `load_file_under_env` correspond to
`load` and `run` respectively:

```{r eval=FALSE}
engine <- Engine$new()

# Like (load ...): definitions visible in the engine
engine$load_file_in_env("script.arl", engine$get_env())

# Like (run ...): isolated; definitions not visible
engine$load_file_under_env("script.arl")
```

## Loading stdlib modules

The engine loads all stdlib modules automatically, so functions like `when`,
`let`, `for`, `->`, and `try` are available immediately. The `import` form is
primarily useful inside your own modules (which start with an empty scope) and
when working with a bare engine created via `Engine$new(load_stdlib = FALSE)`
or `arl --no-stdlib`:

```{arl, eval=FALSE}
(import control)   ; when/unless/cond/case
(import binding)   ; let/let*/letrec
(import looping)   ; for/loop/recur/until
(import threading) ; -> and ->>
(import error)     ; try/catch/finally
```

See [Modules and Imports](modules.html) for details on creating and importing
modules.

## Core syntax

### Truthiness

Arl follows R's truthiness rules: `#f`/`FALSE`, `#nil`/`NULL`, and `0` are
falsy; everything else is truthy. This differs from Scheme, where only `#f`
is falsy. See [Troubleshooting](troubleshooting.html) for common pitfalls.

### Definitions and functions

```{arl}
; Define a variable
(define greeting "hello")

; Define a function
(define factorial
  (lambda (n)
    (if (< n 2)
      1
      (* n (factorial (- n 1))))))

(factorial 5)
```

### Local bindings

```{arl}
; let binds variables in a local scope
(let ((x 10)
      (y 20))
  (+ x y))
```

### Conditionals

```{arl}
; if is the basic conditional
(if (> 3 2) "yes" "no")

; cond handles multiple branches
(define describe
  (lambda (n)
    (cond
      ((< n 0) "negative")
      ((= n 0) "zero")
      (#t "positive"))))

(describe 5)

; when is a one-armed conditional (no else branch)
(when (> 3 2)
  (display "3 is greater\n"))
```

### Sequencing

```{arl}
; begin evaluates expressions in order, returning the last value
(begin
  (define a 1)
  (define b 2)
  (+ a b))
```

### Lists and quoting

```{arl}
(list 1 2 3)
(car (list 1 2 3))
(cdr (list 1 2 3))

; Quoting prevents evaluation
'(+ 1 2)           ; => the unevaluated expression (+ 1 2)

; Quasiquote allows selective evaluation with ,
(define x 10)
`(list ,x 20 30)   ; => (list 10 20 30) -- x is substituted, rest is literal

; Comments start with semicolon
```

For more details on the standard library and macros, see the other vignettes in
this package.

## Getting help

Arl has a built-in help system. Use `help` with a string to look up any
special form, macro, or function:

```{arl, eval=FALSE}
(help "define")   ; special form
(help "when")     ; macro -- shows docs and usage
(help "map")      ; stdlib function
```

For functions with documentation, `help` shows the signature, description,
examples, and cross-references automatically. It also falls through to R's
built-in help for R functions.

### Documenting your functions

Arl provides two mechanisms for attaching documentation to functions and
macros:

- **`;;'` annotation comments** — Place roxygen-like tags (`@description`,
  `@examples`, `@seealso`, `@note`) immediately before a `define` or
  `defmacro`. The compiler bakes the documentation in at compile time with
  no runtime overhead. This is the recommended approach for source files.

- **`doc!`** — Attach or update documentation at runtime, useful for
  interactive work: `(doc! my-fn "Description here.")` or with keyword
  arguments like `(doc! my-fn :examples "(my-fn 3)")`.

Both produce the same `arl_doc` attribute, so `help` and `doc` work
identically regardless of how documentation was attached. See
[Documenting Functions and Macros](documenting-functions-macros.html) for the full reference.

## Next steps

- [Modules and Imports](modules.html)
- [Macros and Quasiquote](macros.html)
- [R Interop and Data Workflows](r-interop.html)
- [Standard Library Overview](stdlib-reference.html)
- [Examples](examples.html)
- [Troubleshooting](troubleshooting.html)
- [Arl Compared to Scheme](arl-vs-scheme.html)
