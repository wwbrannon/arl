---
title: "Standard Library: Equality and S3 Dispatch"
output:
  rmarkdown::html_vignette:
    highlight: null
vignette: >
  %\VignetteIndexEntry{Standard Library: Equality and S3 Dispatch}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- AUTO-GENERATED from inst/rye/ source files. Do not edit manually. -->
<!-- Regenerate with: make stdlib-docs -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

These functions are provided by the `equality` module (`inst/rye/equality.rye`).

## Equality Predicates

Rye provides `equal?` for deep structural equality with S3-style dispatch,
and `identical?` for R's native identity comparison. The Scheme predicates
`eq?` and `eqv?` are intentionally not implemented because R does not
provide the pointer-level semantics they require.

### equal? {#equal}

**Signature:** `(equal? a b [strict #f])`

**Examples:**
```lisp
(equal? 1 1)                    ; => #t
(equal? 1 1.0)                  ; => #t (type coercion)
(equal? 1 1.0 :strict #t)      ; => #f (strict mode, uses identical?)
(equal? (list 1 2) (list 1 2))  ; => #t (deep structural)
(equal? "hello" "hello")        ; => #t
```

**See also:** identical?, [eq?](#eq), [eqv?](#eqv), [set-method!](#set-method-bang)

---

### eq? {#eq}

**Not implemented in Rye.** Raises an error when called.

**Signature:** `(eq? a b)`

**Note:** True Scheme `eq?` semantics cannot be properly implemented in R because R does not provide reliable pointer equality for all object types. R's `identical()` does structural comparison for some types (lists, vectors) but pointer comparison for others (environments, reference classes). Use `identical?` for R's native equality, or `equal?` for deep structural equality.

**See also:** identical?, [equal?](#equal)

---

### eqv? {#eqv}

**Not implemented in Rye.** Raises an error when called.

**Signature:** `(eqv? a b)`

**Note:** True Scheme `eqv?` semantics cannot be properly implemented in R because R does not provide reliable pointer equality for all object types. Use `identical?` for R's native equality, or `equal?` for deep structural equality.

**See also:** identical?, [equal?](#equal)

---

## Helper Functions for Equal?

Internal helper functions used by the `equal?` dispatch methods to perform
recursive structural comparison of environments and lists.

### env-equal? {#env-equal}

Compare two environments by their bindings and values.

**Signature:** `(env-equal? env1 env2)`

**Examples:**
```lisp
(define e1 (new.env :parent emptyenv))
(define e2 (new.env :parent emptyenv))
(assign "x" 1 :envir e1)
(assign "x" 1 :envir e2)
(env-equal? e1 e2)              ; => #t
```

**Note:** Used internally by `equal?.environment`. Compares environments by sorting their bindings and recursively comparing values.

**See also:** [equal?.environment](#equal-environment)

---

### list-equal? {#list-equal}

Recursively compare list elements.

**Signature:** `(list-equal? lst1 lst2)`

**Examples:**
```lisp
(list-equal? (list 1 2 3) (list 1 2 3))  ; => #t
(list-equal? (list 1 2) (list 1 2 3))     ; => #f
(list-equal? (list 1 "a") (list 1 "a"))   ; => #t
```

**Note:** Used internally by `equal?.list`. Recursively compares list elements using `equal?`.

**See also:** [equal?.list](#equal-list)

---

## S3 Dispatch System

Rye implements a simplified S3-style dispatch system for generic functions
like `equal?`. Types are identified by their first S3 class, and methods
are registered as `generic.class` bindings in the stdlib environment.

### s3-type {#s3-type}

Extract the first S3 class from an object.

**Signature:** `(s3-type obj)`

**Examples:**
```lisp
(s3-type 42)                    ; => "numeric"
(s3-type "hello")               ; => "character"
(s3-type (list 1 2))            ; => "list"
(s3-type (new.env))             ; => "environment"
```

---

### check-s3-type-match {#check-s3-type-match}

Check if all objects have the same S3 type.

**Signature:** `(check-s3-type-match obj rest...)`

**Examples:**
```lisp
(check-s3-type-match 1 2 3)     ; => #t (all numeric)
(check-s3-type-match 1 "a")     ; => #f (numeric vs character)
```

**Note:** Internal function used by `equal?` to verify type consistency before dispatch.

---

### set-method! {#set-method-bang}

Register an S3-style method. Example: (set-method! 'equal? 'my-class (lambda (a b strict) ...)).

**Signature:** `(set-method! generic-name class-name method-fun)`

**Examples:**
```lisp
;; Register a custom equality method for "point" objects:
(set-method! 'equal? 'point
  (lambda (a b strict)
    (and (equal? ($ a "x") ($ b "x"))
         (equal? ($ a "y") ($ b "y")))))
```

**See also:** [use-method](#use-method)

---

### use-method {#use-method}

Dispatch to an S3 method based on object class.

**Signature:** `(use-method generic-name obj args)`

**Examples:**
```lisp
(use-method "equal?" (list 1 2) (list (list 1 2) (list 1 2) #f))  ; dispatches to equal?.list
```

**Note:** Internal function. Dispatches to the appropriate S3 method based on the object's class, falling back to the `.default` method if no class-specific method is found.

**See also:** [set-method!](#set-method-bang), [s3-type](#s3-type)

---

## Built-in Equal? Methods

These methods handle equality comparison for R's core types. The dispatch
system selects the appropriate method based on the S3 class of the first
argument. Users can register additional methods with `set-method!`.

### equal?.default {#equal-default}

**Signature:** `(equal?.default a b [strict #f])`

**Examples:**
```lisp
(equal?.default 1 1)             ; => #t
(equal?.default 1 1.0)           ; => #t (coercion via ==)
(equal?.default 1 1.0 :strict #t) ; => #f (strict uses identical?)
(equal?.default (c 1 2 3) (c 1 2 3))  ; => #t (element-wise)
```

---

### equal?.list {#equal-list}

**Signature:** `(equal?.list a b [strict #f])`

**Examples:**
```lisp
(equal?.list (list 1 2 3) (list 1 2 3))          ; => #t
(equal?.list (list 1 (list 2 3)) (list 1 (list 2 3)))  ; => #t (nested)
(equal?.list (list 1 2) (list 1 2 3))             ; => #f
```

---

### equal?.environment {#equal-environment}

**Signature:** `(equal?.environment a b [strict #f])`

**Examples:**
```lisp
(define e1 (new.env :parent emptyenv))
(define e2 (new.env :parent emptyenv))
(assign "x" 1 :envir e1)
(assign "x" 1 :envir e2)
(equal?.environment e1 e2)       ; => #t
```

---

## Migration from predicates Module

Equality predicates were previously in the `predicates` module. They are now
in the `equality` module:

```lisp
; Old (before reorganization)
(import predicates)

; New (after reorganization)
(import equality)  ; for equal?, identical?, eq?, eqv?
```

The function signatures and behavior remain unchanged.

