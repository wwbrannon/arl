---
title: "Arl Compared to Scheme"
output: arl::arl_html_vignette
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{Arl Compared to Scheme}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
arl::register_knitr_engine()
```

Arl is a Lisp dialect implemented in and with access to R. It borrows Lisp
syntax and macro conventions, but its runtime model and interop are rooted in
R. This vignette highlights key similarities with Scheme and the most important
differences. (The development of R was [heavily
influenced](https://cran.r-project.org/doc/html/interface98-paper/paper_1.html)
by Scheme, making the comparison natural.)

## Common ground

Arl and Scheme share a Lisp-family surface syntax and several familiar ideas:

- **S-expressions**: code and data use the same list syntax.
- **[Homoiconic](https://en.wikipedia.org/wiki/Homoiconicity) macros**:
  `defmacro` plus quasiquote/unquote are central.
- **First-class functions**: anonymous functions and higher-order patterns are
  idiomatic.
- **Lexical scoping**: bindings are local by default and resolve predictably.

## Core differences

The main differences come from Arl leaning on R's runtime:

### Evaluation model

Arl evaluates expressions via R's `eval()` and environments. That means:

- R's base functions are available without importing.
- R's evaluation and error semantics apply under the hood.

### Data model

Scheme has pairs and lists as the fundamental sequence type. Arl uses R data
structures:

- Lists are R lists or calls (R's type-generic vectors).
- Arl also has dotted pairs (R6 `Cons` objects, tested with `pair?`); `list-or-pair?` is true for non-empty lists or dotted pairs.
- Vectors are R vectors.
- `#nil` maps to R's `NULL`.

### Truthiness

Scheme typically treats only `#f` as false. Arl treats `#f`/`FALSE`,
`#nil`/`NULL`, and `0` as falsey; everything else is truthy.

### Numeric edge cases (R semantics)

Arl mirrors R's numeric behavior rather than Scheme's in several edge cases:

- **Division by zero**: `(/ 1 0)` yields `Inf` (and `(/ -1 0)` yields `-Inf`) instead of raising an error.
- **NaN comparisons**: `(== NaN NaN)` yields `NA` rather than `#f`, due to R's `NA` propagation rules.

This is intentional for R interop, but it is a meaningful semantic difference
from Scheme. Prefer predicates like `is.infinite`, `is.nan`, and `is.na` when
you need to branch on these values.

```{arl}
(/ 1 0)         ; => Inf
(== NaN NaN)    ; => NA
(is.infinite (/ 1 0))  ; => TRUE
(is.na (== NaN NaN))   ; => TRUE
```

```{arl, include=FALSE}
(assert-true (is.infinite (/ 1 0)))
(assert-true (is.na (== NaN NaN)))
```

### Numeric Tower Differences

Arl implements a numeric tower similar to Scheme's, but adapted for R's type system:

```
number?    (is.numeric OR is.complex)
├─ complex?  (is.complex)
└─ real?     (is.numeric AND NOT is.complex)
   ├─ ±Inf   (real but not rational)
   └─ rational? (real? AND is.finite)
      └─ integer? (is.finite AND is.numeric AND x == as.integer(x))
         └─ natural? (integer? AND x >= 0)

Orthogonal predicates:
exact?   (is.integer - storage type)
inexact? (number? AND NOT is.integer)
```

**Key differences from Scheme:**

1. R doesn't distinguish exact rationals from inexact reals - all are IEEE 754 floats
2. `rational?` means "finite real" in Arl (since all finite floats are rationally representable)
3. `exact?` checks storage type (integer vs. double), not mathematical exactness
4. All complex numbers in R are inexact (double-precision)

**Infinities and special values:**

```{arl}
(real? Inf)       ; => #t (infinities are real)
(rational? Inf)   ; => #f (but not rational)
(finite? Inf)     ; => #f
(real? NaN)       ; => #t
(finite? NaN)     ; => #f
```

```{arl, include=FALSE}
(assert-true (real? Inf))
(assert-false (rational? Inf))
(assert-false (finite? Inf))
(assert-true (real? NaN))
(assert-false (finite? NaN))
```

### Keywords and named arguments

Arl keywords (`:from`, `:to`) are self-evaluating and map to **named arguments**
in R calls. This is a major ergonomic difference from Scheme.

### Tail-call optimization

Scheme mandates full tail-call optimization (proper tail calls). Arl implements
**self-TCO**: the compiler detects `(define name (lambda ...))` or
`(set! name (lambda ...))` where the lambda body has self-calls in tail
position and rewrites them as `while` loops. This covers tail calls through
the `if` and `begin` special forms, as well as through macros in terms of them
like  `cond`, `let`, `let*`, `letrec`, etc. Because `letrec` expands into
`set!`, `letrec`-bound self-recursive lambdas are optimized automatically.

What is **not** covered:

- **Mutual recursion** (`f` calls `g` in tail position, `g` calls `f`).
- **`apply`-based tail calls** or indirect calls through higher-order functions.
- **Anonymous lambdas** which tail-recurse by use of a fixed-point combinator
  (no name for the compiler to detect self-calls against).

Like Scheme's proper tail calls, self-TCO elides recursive stack frames: on
error inside an optimized function, only the outermost call appears in the
stack trace rather than the full chain of recursive calls.

For cases not covered by self-TCO, use `loop`/`recur` for explicit
tail-recursive patterns.

```{arl}
;; Self-TCO optimizes this automatically
(define factorial
  (lambda (n acc)
    (if (< n 2) acc
        (factorial (- n 1) (* acc n)))))

;; loop/recur for explicit control
(loop ((i 10) (acc 1))
  (if (< i 2) acc
      (recur (- i 1) (* acc i))))
```

```{arl, include=FALSE}
(assert-equal 120 (factorial 5 1))
(assert-equal 3628800 (loop ((i 10) (acc 1))
  (if (< i 2) acc (recur (- i 1) (* acc i)))))
```

### Interop

Arl can call R functions directly:

```{arl}
(mean (c 1 2 3 4 5))
(seq :from 1 :to 10 :by 2)
```

```{arl, include=FALSE}
(assert-equal 3 (mean (c 1 2 3 4 5)))
```

Scheme code typically requires FFI layers for such interop; Arl treats it as
normal function application.

## Special forms and macros

Many familiar special forms exist (`quote`, `if`, `define`, `lambda`, `begin`),
but there are Arl-specific forms (`~`, `::`, `:::` for R formula definition and
package access) and macro helpers tuned for R interop. See the [language
reference](lang-reference.html) for more details.

## When to think "Scheme" vs "R"

- **Think Scheme** for macro structure and list processing patterns.
- **Think R** for data frames, formulas, statistical modeling, and named
  argument calls.

## Related guides

- [Getting Started](getting-started.html)
- [Macros and Quasiquote](macros.html)
- [R Interop and Data Workflows](r-interop.html)
